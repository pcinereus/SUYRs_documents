---
title: Data wrangling (tidyverse and friends)
author: "Murray Logan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-float: true
    page-layout: full
    number-sections: true
    number-depth: 3
    embed-resources: true
    code-fold: false
    code-tools: true
    code-summary: "Show the code"
    code-line-numbers: true
    code-block-border-left: "#ccc"
    code-copy: true
    highlight-style: atom-one
    theme: [default, ../resources/tut-style.scss]
    css: ../resources/tut-style.css
crossref:
  fig-title: '**Figure**'
  fig-labels: arabic
  tbl-title: '**Table**'
  tbl-labels: arabic
engine: knitr
bibliography: ../resources/references.bib
output_dir: "docs"
---

```{r setup, include=FALSE,warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning=FALSE, message=FALSE, cache = TRUE, comment = "")
options(tinytex.engine = 'xelatex')
cleanRmdInput <- function(x) {
#x <- gsub("```\\{r","```markdown\n`r ''```\\{r",x)
x <- gsub("^```$","`` `",x)  # the Makefile will then change this back to ``` after pandoc
x
}
library(tidyverse)
library(pander)
## FIG_PATH <- 'data_manipulations/figure-html/'
```
 

```{r makeData, echo=FALSE}
## dat.1
set.seed(1)
dat.1 <- expand.grid(Time = 1:4, Dose=c("H", "M", "L"), Plot = paste0("P", 1:4)) |>
    mutate(Dose = factor(as.character(Dose)),
           Treatment = gl(2, 24, 48, lab=c("Control", "Exclusion")),
           ## Time=rep(1:4, 3),
           M1 = ifelse(Treatment == "Control", 1, 2),
           M2 = ifelse(Dose == "H", 1, ifelse(Dose == "M", 2, 3)),
           Resp1 = round(rnorm(n(), (10 * M1) * M2 * Time, 3), 2),
           Resp2 = round(rnorm(n(), (rnorm(n(), 10, 5) * M1) * M2 * Time, 5), 2)) |>
    dplyr::select(Treatment, Plot, Dose, Time, Resp1, Resp2)

## tikus    
data(tikus, package='mvabund')
tikus <- cbind(tikus$x,tikus$abund)

## data.w
set.seed(1)
data.w <- expand.grid(Plot = paste("P", 1:4, sep = "")) |>
    mutate(Between = gl(2, 2, 4, lab = paste("A", 1:2, sep = ""))) |>
    cbind(matrix(rpois(12, 10),
                 ncol = 3,
                 dimnames = list(paste("R", 1:4, sep = ""),
                                 paste("Time", 0:2, sep = "."))))

##data
set.seed(1)
data <- expand.grid(Within = paste("B", 1:2, sep = ""),
                    Subplot = paste("S", 1:2, sep = ""),
                    Plot = paste("P", 1:6, sep = "")) |>
    mutate(Subplot = gl(12, 2, 24,lab = paste("S", 1:12, sep = "")),
           Between = gl(3, 4, 24, lab = paste("A", 1:3, sep="")),
           Resp1 = rpois(24, 10),
           Resp2 = rpois(24, 20)) |>
    dplyr::select(Resp1, Resp2, Between, Plot, Subplot, Within)

## data.d
set.seed(1)
data.d = data.frame(Date=sample(seq(as.Date('2008-01-01'),
                                    as.Date('2009-12-31'),
                                    by='day'), size=10),
                    Resp1=rnbinom(10,5,mu=30) * as.numeric(replicate(5,rbinom(2,1,0.8)))) |>
    separate(Date,into=c('year','month','day'))

## data.c
data.c <- data.frame(Year=paste0(sample(c('M','F'),10,replace=TRUE),rpois(10,30)),
                     Resp1=rnbinom(10,5,mu=30) * as.numeric(replicate(5,rbinom(2,1,0.8))))

## data.bio
set.seed(1)
data.bio <- expand.grid(Subplot = paste("S", 1:2, sep = ""),
                        Plot = paste("P", 1:6, sep = "")) |>
    mutate(Subplot = gl(12, 1, 12, lab = paste("S", 1:12, sep = "")),
           Between =  gl(3, 4, 12, lab = paste("A", 1:3, sep = "")),
           Resp1 = rpois(12, 10),
           Resp2 = rpois(12, 20)) |>
    select(Resp1, Resp2, Between, Plot, Subplot) |>
    slice(-3)

## data.chem
set.seed(1)
data.chem <- expand.grid(Subplot = paste("S", 1:2, sep = ""),
                         Plot = paste("P", 1:6, sep = "")) |>
    mutate(Subplot = gl(12, 1, 12, lab = paste("S", 1:12, sep="")),
           Between = gl(3, 4, 12, lab = paste("A", 1:3, sep = "")),
           Chem1 = rlnorm(12, 1),
           Chem2 = rlnorm(12, 0.5)) |>
    select(Chem1, Chem2, Between, Plot, Subplot) |>
    slice(-7)

## data.geo
set.seed(1)
data.geo <- expand.grid(Plot = paste("P", 1:6, sep = "")) |>
    mutate(LAT = c(17.9605, 17.5210, 17.0011, 18.235, 18.9840, 20.1154),
           LONG = c(145.4326, 146.1983, 146.3839, 146.7934, 146.0345, 146.4672))

## nasa
nasa = as.data.frame(GGally::nasa)
```

```{r saveData, results='markdown', eval=TRUE, echo=FALSE}
if (!dir.exists('../data')) dir.create('../data')
save(
    dat.1,
    data,
    data.d,
    data.c,
    data.bio,
    data.chem,
    data.geo,
    data.w,
    nasa,
    tikus,
    file = "../data/manipulationDatasets.RData")

dump(c('dat.1',
       'tikus',
       'data.w',
       'data',
       'data.d',
       'data.c',
       'data.bio',
       'data.chem',
       'data.geo',
       'nasa'
       ),
     file='../data/manipulationDatasets.R')

```

I apologize in advance, this tutorial requires quite a bit of
explaining and context before it can get into the code.... Good data
manipulation is an art form that requires the use of many specific
tools (functions) and expert data manipulation comes from the
integration of these tools together. Therefore it is necessary to have
an overview of the tool set before investigating any single tool.
     

# Manipulating data sets 

Rarely are data transcribed and organised into such simple and
ready-to-go data sets.  More typically, data are spread throughout
multiple sources and in a variety of formats (particularly if compiled
by multiple workers or instruments).  Consequently, prior to any
formal statistical analyses , it is necessary to compile very focused,
**tidy** data sets.

@Wickham-2014-59 suggested that there are many ways to organise data,
yet tidy data (data that are structured in such a consistent way as to
facilitate analyses) must adhere to a fairly strict set of structural
rules. Specifically, in tidy data: 

- **variables** are in columns
- **observations** are in rows - that is, for univariate data, there
  should be a separate row for each response observation.

```{tikz}
%| label: tidy1Tikz
%| engine: tikz
%| echo: false
%| fig_width: 6
%| fig_height: 3
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
%\tikzstyle{Title} = [font={\fontspec[Scale=1]{CompleteinHim}}]
\tikzstyle{Title} = [font={\fontspec[Scale=1]{ArchitectsDaughter-Regular}}]

%%\tikzstyle{Title} = [font={\fontspec[Scale=2,  ExternalLocation=../resources/]{Complete in Him.ttf}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{code} = [font={\fontspec[Scale=2]{Inconsolata}}]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 1/.style={
            nodes={text width=4em,font=\bfseries}
        },
        column 2/.style={
            nodes={text width=4em}
        },
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}


\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
Var1&Var2&Var3\\    
&  & \\    
&  & \\    
&  & \\    
&  & \\
};

\draw[latex-latex,line width=5pt] (first-2-1.north) --(first-5-1.south);
\draw[latex-latex,line width=5pt] (first-2-2.north) --(first-5-2.south);
\draw[latex-latex,line width=5pt] (first-2-3.north) --(first-5-3.south);

\matrix (second) [right=2cm of first,anchor=west,table,text width=4em]{
Var1&Var2&Var3\\        
&  & \\    
&  & \\    
&  & \\    
&  & \\
};
\draw[latex-latex,line width=5pt] (second-2-1.west) --(second-2-3.east);
\draw[latex-latex,line width=5pt] (second-3-1.west) --(second-3-3.east);
\draw[latex-latex,line width=5pt] (second-4-1.west) --(second-4-3.east);
\draw[latex-latex,line width=5pt] (second-5-1.west) --(second-5-3.east);

\node [Title,above=0.75cm of first.north,anchor=north] (Variables)  {Variables in Columns};
\node [Title,above=0.75cm of second.north,anchor=north] (Observations)  {Observations in Rows};

\end{tikzpicture}
```

To achieve tidy data, common data preparations include:

- Reshaping and rearranging data
- Merging multiple data sources
- Aggregating data to appropriate spatial/temporal scales
- Transforming data and deriving new variables
- Sorting and reordering data
- Relabelling data

This workshop will concentrate on these essential data preparation
phases.


Practical data manipulation will be demonstrated via a series of very
small artificial datasets.  These datasets are presented in tables
with black font and lines and the R code required to generate those
data will be presented in static code boxes either underneath or
adjacent the table.  A very basic description of the table and the
name of the data frame are displayed above the table.  The entire
collection of datasets used in this workshop can be obtained by
issuing the following command:

- (if online)

  ```{r GetData, eval = FALSE}
  source("https://github.com/ReefCloud/workshops/tree/main/data/manipulationDatasets.R")
  ##OR
  load(url("https://github.com/ReefCloud/workshops/tree/main/data/manipulationDatasets.R"))
  ```


- (if offline and are running this from a local version having first
  cloned the [ReefCloud Workshop github repository](https://github.com/ReefCloud/workshops)

  ```{r GetLocalData, eval = FALSE}
  source(file="data/manipulationDatasets.R")
  ##OR
  load(file = "data/manipulationDatasets.RData")
  ```

An overview of the example data sets follows.

An overview of the example data sets follows.

::: panel-tabset

## dat.1

These data comprise two Responses (`Resp1` and `Resp2`) that are each
observed on four occasions (`Time`) from each of three dosage
treatments (`Dose`) nested within four plots (`Plot`). Two of the four
plots completely excluded something and the other two were controls
(did not exclude the thing).

```{tikz}
%| label: tikz_dat1
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\begin{tikzpicture}
\coordinate (A) at (0,0);

\begin{scope}[local bounding box=P1a,anchor=north west, shift=(A),on background layer] 
\node [draw, minimum width=1cm, minimum height=1cm, Title, Messy] (P1D1) {H}; 
\node [draw, minimum width=1cm, minimum height=1cm, anchor=north west, Title, Messy] at ($(P1D1.south east) +(0.2,0)$) (P1D2) {M};
\node [draw, minimum width=1cm, minimum height=1cm, anchor=south west, Title, Messy] at ($(P1D2.north east) +(0.2,0)$) (P1D3) {L};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P1D1) (P1D2) (P1D3)}, draw, pattern = grid, pattern color=blue, opacity=0.2, Messy, thick] (P1) {};
\draw [Messy, thick] (P1.north west) -- (P1.south west) -- (P1.south east) -- (P1.north east) -- cycle;
\node [Title, anchor = south] at (P1.north) {P3};
\end{scope}

\begin{scope}[anchor=north, shift=(P1D3.south), yshift=-1.5cm, xshift=-2.5cm]
\node [draw, Title, Messy] (T1) {T1};
\node [draw, anchor=north west, xshift=0.15cm, Title, Messy] at (T1.north east) (T2) {T2};
\node [draw, anchor=north west, xshift=0.15cm, Title, Messy] at (T2.north east) (T3) {T3};
\node [draw, anchor=north west, xshift=0.15cm, Title, Messy] at (T3.north east) (T4) {T4};
\draw [latex-,Messy] (T1) -- (P1D2);
\draw [latex-,Messy] (T2) -- (P1D2);
\draw [latex-,Messy] (T3) -- (P1D2);
\draw [latex-,Messy] (T4) -- (P1D2);
\draw [Messy] (T1.south) -- ($(T1.south) +(0,-1)$);
\draw ($(T1.south) +(0,-0.5)$) -- ($(T1.south) +(0.5,-0.5)$) node [anchor=west, code]{Resp1};
\draw ($(T1.south) +(0,-1)$) -- ($(T1.south) +(0.5,-1)$) node [anchor=west, code]{Resp2};
\end{scope}

\begin{scope}[local bounding box=P2a, anchor=north west, shift=(P1a.north east), xshift=1cm]
\node [draw, minimum width=1cm, minimum height=1cm, Title, Messy] (P2D1) {L};
\node [draw, minimum width=1cm, minimum height=1cm, anchor=north west, Title, Messy] at ($(P2D1.south east) + (0.2,0)$) (P2D2) {H};
\node [draw, minimum width=1cm, minimum height=1cm, anchor=south west, Title, Messy] at ($(P2D2.north east) + (0.2,0)$) (P2D3) {M};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P2D1) (P2D2) (P2D3)}, draw, thick, Messy]  (P2) {};
\node [Title, anchor = south] at (P2.north) {P1};
\end{scope}

\begin{scope}[local bounding box=P3a, anchor=north west, shift=(P2a.north east), xshift=1cm]
\node [draw, minimum width=1cm, minimum height=1cm, Title, Messy] (P3D1) {M};
\node [draw, minimum width=1cm, minimum height=1cm, Title, anchor=north west, Messy] at ($(P3D1.south east) + (0.2,0)$) (P3D2) {H};
\node [draw, minimum width=1cm, minimum height=1cm, Title, anchor=south west, Messy] at ($(P3D2.north east) + (0.2,0)$) (P3D3) {L};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P3D1) (P3D2) (P3D3)}, draw, pattern = grid, pattern color=blue, opacity=0.2, Messy, thick]  (P3) {};
\draw [Messy, thick] (P3.north west) -- (P3.south west) -- (P3.south east) -- (P3.north east) -- cycle;
\node [Title, anchor = south] at (P3.north) {P4};
\end{scope}
	
\begin{scope}[local bounding box=P4a, anchor=north west, shift=(P3a.north east), xshift=1cm]
\node [draw, minimum width=1cm, minimum height=1cm, Title, Messy] (P4D1) {L};
\node [draw, minimum width=1cm, minimum height=1cm, Title, anchor=north west, Messy] at ($(P4D1.south east) +(0.2,0)$) (P4D2) {M};
\node [draw, minimum width=1cm, minimum height=1cm, Title, anchor= west, Messy] at ($(P4D2.north east) +(0.2,0)$) (P4D3) {H};
\end{scope}
\node [fit={(P4D1) (P4D2) (P4D3)}, draw, Messy, thick]  (P4) {};
\node [Title, anchor = south] at (P4.north) {P2};
\end{tikzpicture}
```

<details><summary>View data</summary>
```{r dat.1, echo=FALSE, results = 'asis'}
knitr::kable(dat.1, table.attr = "class=\"paperTable\"", format='html')
```
</details>

**Note** as this data set is 48 rows long, the majority examples that
feature this dataset will only show the first 6 (or 10) rows to save
on space.  This truncation will occur via the `head()` _function_.

## data.w

These data comprise a Response observed on three occasions (`Time.0`,
`Time.1` and `Time.2`) from each of two (`A1` and `A2`) treatments
(`Between`, gridded or not) nested within four plots (`Plot`).

```{tikz}
%| label: tikz_datw
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\begin{tikzpicture}
\coordinate (A) at (0,0);

\begin{scope}[local bounding box=P1a,anchor=north west, shift=(A),on background layer] 
\node [minimum width=1cm, minimum height=1cm, Title, Messy] (P1D1) {}; 
\node [ minimum width=1cm, minimum height=1cm, anchor=north west, Title, Messy] at ($(P1D1.south east) +(0.2,0)$) (P1D2) {};
\node [minimum width=1cm, minimum height=1cm, anchor=south west, Title, Messy] at ($(P1D2.north east) +(0.2,0)$) (P1D3) {};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P1D1) (P1D2) (P1D3)}, draw, pattern = grid, pattern color=blue, opacity=0.2, Messy, thick] (P1) {};
\draw [Messy, thick] (P1.north west) -- (P1.south west) -- (P1.south east) -- (P1.north east) -- cycle;
\node [Title, anchor = south] at (P1.north) {P1};
\end{scope}

\begin{scope}[anchor=north, shift=(P1D3.south), yshift=-2cm, xshift=-3cm]
\node [draw, Title, Messy] (T1) {Time.0};
\node [draw, anchor=north west, xshift=0.15cm, Title, Messy] at (T1.north east) (T2) {Time.1};
\node [draw, anchor=north west, xshift=0.15cm, Title, Messy] at (T2.north east) (T3) {Time.2};
\draw [latex-,Messy] (T1) -- (P1);
\draw [latex-,Messy] (T2) -- (P1);
\draw [latex-,Messy] (T3) -- (P1);
\draw [Messy] (T1.south) -- ($(T1.south) +(0,-0.5)$);
\draw ($(T1.south) +(0,-0.5)$) -- ($(T1.south) +(0.5,-0.5)$) node [anchor=west, code]{Count};
\end{scope}

\begin{scope}[local bounding box=P2a, anchor=north west, shift=(P1a.north east), xshift=1cm]
\node [minimum width=1cm, minimum height=1cm, Title, Messy] (P2D1) {};
\node [minimum width=1cm, minimum height=1cm, anchor=north west, Title, Messy] at ($(P2D1.south east) + (0.2,0)$) (P2D2) {};
\node [minimum width=1cm, minimum height=1cm, anchor=south west, Title, Messy] at ($(P2D2.north east) + (0.2,0)$) (P2D3) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P2D1) (P2D2) (P2D3)}, draw, pattern = grid, pattern color=blue, opacity=0.2, Messy, thick]  (P2) {};
\draw [Messy, thick] (P2.north west) -- (P2.south west) -- (P2.south east) -- (P2.north east) -- cycle;
\node [Title, anchor = south] at (P2.north) {P2};
\end{scope}

\begin{scope}[local bounding box=P3a, anchor=north west, shift=(P2a.north east), xshift=1cm]
\node [minimum width=1cm, minimum height=1cm, Title, Messy] (P3D1) {};
\node [minimum width=1cm, minimum height=1cm, Title, anchor=north west, Messy] at ($(P3D1.south east) + (0.2,0)$) (P3D2) {};
\node [minimum width=1cm, minimum height=1cm, Title, anchor=south west, Messy] at ($(P3D2.north east) + (0.2,0)$) (P3D3) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P3D1) (P3D2) (P3D3)}, draw, Messy, thick]  (P3) {};
\draw [Messy, thick] (P3.north west) -- (P3.south west) -- (P3.south east) -- (P3.north east) -- cycle;
\node [Title, anchor = south] at (P3.north) {P3};
\end{scope}
	
\begin{scope}[local bounding box=P4a, anchor=north west, shift=(P3a.north east), xshift=1cm]
\node [minimum width=1cm, minimum height=1cm, Title, Messy] (P4D1) {};
\node [minimum width=1cm, minimum height=1cm, Title, anchor=north west, Messy] at ($(P4D1.south east) +(0.2,0)$) (P4D2) {};
\node [minimum width=1cm, minimum height=1cm, Title, anchor= west, Messy] at ($(P4D2.north east) +(0.2,0)$) (P4D3) {};
\end{scope}
\node [fit={(P4D1) (P4D2) (P4D3)}, draw, Messy, thick]  (P4) {};
\node [Title, anchor = south] at (P4.north) {P4};
\end{tikzpicture}
```

<details><summary>View data</summary>
```{r data.w, echo=FALSE, results = 'asis'}
knitr::kable(data.w, table.attr = "class=\"paperTable\"", format='html')
```
</details>

## data

Similar to `dat.1`, these data comprise two Responses (`Resp1` and
`Resp2`).  However, these data have a different hierarchical structure.  Each response was measured from one of two `Subplot`s nested within one of six `Plot`s.  Within each `Subplot` each of two treatment levels (`B1` and `B2`) were applied and two of the `Plot`s where exposed to one of the three `Between` levels.

```{tikz}
%| label: tikz_data
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\begin{tikzpicture}
\coordinate (A) at (0,0);
\begin{scope}[local bounding box=P1a,anchor=north west, shift=(A),on background layer] 
\node [draw, minimum width=2cm, minimum height=2cm, Title, Messy, fill=orange, opacity=0.7] (P1S1B1) {B1}; 
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S1B1.north east) +(0.2,0)$) (P1S1B2) {B2};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S1B1.north west) +(0,2.-5.5)$) (P1S2B1) {B2};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, fill=orange,opacity=0.7,Title, Messy] at ($(P1S2B1.north east) +(0.2,0)$) (P1S2B2) {B1};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P1S1B1) (P1S1B2) +(0,1)}, draw, Messy, thick, Title, text height=0.5cm] (P1S1) {S1};
\node [fit={(P1S2B1) ($(P1S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P1S2) {S2};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P1S1) (P1S2) }, draw, pattern = grid, pattern color=blue, opacity=0.2, Messy, thick] (P1) {};
\draw [Messy, thick] (P1.north west) -- (P1.south west) -- (P1.south east) -- (P1.north east) -- cycle;
\node [Title, anchor = south] at (P1.north) {P1};
\end{scope}

\begin{scope}[anchor=north, shift=(P1S2.south), yshift=-1.5cm, xshift=-2.5cm]
\draw [Messy] (P1S2B1.south) -- ($(P1S2B1.south) +(0,-1.5)$);
\draw ($(P1S2B1.south) +(0,-1)$) -- ($(P1S2B1.south) +(0.5,-1)$) node [anchor=west, code]{Resp1};
\draw ($(P1S2B1.south) +(0,-1.5)$) -- ($(P1S2B1.south) +(0.5,-1.5)$) node [anchor=west, code]{Resp2};
\end{scope}

\begin{scope}[local bounding box=P2a,anchor=north west, shift=(P1a.north east),xshift =1cm, on background layer] 
\node [draw, minimum width=2cm, minimum height=2cm, Title, Messy, fill=orange, opacity=0.7] (P2S1B1) {B1}; 
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P2S1B1.north east) +(0.2,0)$) (P2S1B2) {B2};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west,fill=orange,opacity=0.7, Title, Messy] at ($(P2S1B1.north west) +(0,2.-5.5)$) (P2S2B1) {B1};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P2S2B1.north east) +(0.2,0)$) (P2S2B2) {B2};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P2S1B1) ($(P2S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P2S1) {S4};
\node [fit={(P2S2B1) ($(P2S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P2S2) {S3};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P2S1) (P2S2) }, draw,  Messy, thick] (P2) {};
\draw [Messy, thick] (P2.north west) -- (P2.south west) -- (P2.south east) -- (P2.north east) -- cycle;
\node [Title, anchor = south] at (P2.north) {P2};
\end{scope}

\begin{scope}[local bounding box=P3a,anchor=north west, shift=(P2a.north east),xshift =1cm, on background layer] 
\node [draw, minimum width=2cm, minimum height=2cm, Title, Messy] (P3S1B1) {B2}; 
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy, fill=orange, opacity=0.7] at ($(P3S1B1.north east) +(0.2,0)$) (P3S1B2) {B1};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west,fill=orange,opacity=0.7, Title, Messy] at ($(P3S1B1.north west) +(0,2.-5.5)$) (P3S2B1) {B1};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P3S2B1.north east) +(0.2,0)$) (P3S2B2) {B2};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P3S1B1) ($(P3S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P3S1) {S5};
\node [fit={(P3S2B1) ($(P3S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P3S2) {S6};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P3S1) (P3S2) }, draw,  pattern=fivepointed stars, pattern color=blue, opacity=0.2,Messy, thick] (P3) {};
\draw [Messy, thick] (P3.north west) -- (P3.south west) -- (P3.south east) -- (P3.north east) -- cycle;
\node [Title, anchor = south] at (P3.north) {P3};
\end{scope}

\begin{scope}[local bounding box=P4a,anchor=north west, shift=(P3a.north east),xshift =1cm, on background layer] 
\node [draw, minimum width=2cm, minimum height=2cm, Title, Messy] (P4S1B1) {B2}; 
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy, fill=orange, opacity=0.7] at ($(P4S1B1.north east) +(0.2,0)$) (P4S1B2) {B1};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P4S1B1.north west) +(0,2.-5.5)$) (P4S2B1) {B2};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, fill=orange,opacity=0.7, Title, Messy] at ($(P4S2B1.north east) +(0.2,0)$) (P4S2B2) {B1};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P4S1B1) ($(P4S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P4S1) {S8};
\node [fit={(P4S2B1) ($(P4S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P4S2) {S7};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P4S1) (P4S2) }, draw,  pattern=grid, pattern color=blue, opacity=0.2,Messy, thick] (P4) {};
\draw [Messy, thick] (P4.north west) -- (P4.south west) -- (P4.south east) -- (P4.north east) -- cycle;
\node [Title, anchor = south] at (P4.north) {P4};
\end{scope}

\begin{scope}[local bounding box=P5a,anchor=north west, shift=(P4a.north east),xshift =1cm, on background layer] 
\node [draw, minimum width=2cm, minimum height=2cm, Title, Messy, fill=orange, opacity=0.7] (P5S1B1) {B1}; 
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P5S1B1.north east) +(0.2,0)$) (P5S1B2) {B2};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P5S1B1.north west) +(0,2.-5.5)$) (P5S2B1) {B2};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west,fill=orange,opacity=0.7,  Title, Messy] at ($(P5S2B1.north east) +(0.2,0)$) (P5S2B2) {B1};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P5S1B1) ($(P5S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P5S1) {S9};
\node [fit={(P5S2B1) ($(P5S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P5S2) {S10};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P5S1) (P5S2) }, draw,  Messy, thick] (P5) {};
\draw [Messy, thick] (P5.north west) -- (P5.south west) -- (P5.south east) -- (P5.north east) -- cycle;
\node [Title, anchor = south] at (P5.north) {P5};
\end{scope}

\begin{scope}[local bounding box=P6a,anchor=north west, shift=(P5a.north east),xshift =1cm, on background layer] 
\node [draw, minimum width=2cm, minimum height=2cm, Title, Messy] (P6S1B1) {B2}; 
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy, fill=orange, opacity=0.7] at ($(P6S1B1.north east) +(0.2,0)$) (P6S1B2) {B1};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P6S1B1.north west) +(0,2.-5.5)$) (P6S2B1) {B2};
\node [draw, minimum width=2cm, minimum height=2cm, anchor=north west, fill=orange,opacity=0.7, Title, Messy] at ($(P6S2B1.north east) +(0.2,0)$) (P6S2B2) {B1};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P6S1B1) ($(P6S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P6S1) {S5};
\node [fit={(P6S2B1) ($(P6S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P6S2) {S6};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P6S1) (P6S2) }, draw,  pattern=fivepointed stars, pattern color=blue, opacity=0.2,Messy, thick] (P6) {};
\draw [Messy, thick] (P6.north west) -- (P6.south west) -- (P6.south east) -- (P6.north east) -- cycle;
\node [Title, anchor = south] at (P6.north) {P6};
\end{scope}
\end{tikzpicture}
```

<details><summary>View data</summary>
```{r data, echo=FALSE, results = 'asis'}
knitr::kable(data, table.attr = "class=\"paperTable\"", format='html')
```
</details>


## data.d

The `data.d` data comprise of a single response (`Resp1`) collected on different days.
The three different components of the dates have been recorded in three different columns corresponding to the `year`, `month` and `day`.

<details><summary>View data</summary>
```{r data.d, echo=FALSE, results = 'asis'}
knitr::kable(data.d, table.attr = "class=\"paperTable\"", format='html')
```
</details>

## data.bio

The `data.bio` dataset represents a design that is like a cut down
version of `data` in which there are no `Within` `Subplot` levels and
thus there are also fewer rows.

```{tikz}
%| label: tikz_databio
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\begin{tikzpicture}
\coordinate (A) at (0,0);

\begin{scope}[local bounding box=P1a,anchor=north west, shift=(A),on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P1S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S1B1.north east) +(0.2,0)$) (P1S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S1B1.north west) +(0,2.-5.5)$) (P1S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S2B1.north east) +(0.2,0)$) (P1S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P1S1B1) (P1S1B2) +(0,1)}, draw, Messy, thick, Title, text height=0.5cm] (P1S1) {S1};
\node [fit={(P1S2B1) ($(P1S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P1S2) {S2};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P1S1) (P1S2) }, draw, pattern = grid, pattern color=blue, opacity=0.2, Messy, thick] (P1) {};
\draw [Messy, thick] (P1.north west) -- (P1.south west) -- (P1.south east) -- (P1.north east) -- cycle;
\node [Title, anchor = south] at (P1.north) {P1};
\end{scope}

\begin{scope}[anchor=north, shift=(P1S2.south), yshift=-1.5cm, xshift=-2.5cm]
\draw [Messy] (P1S2B1.south) -- ($(P1S2B1.south) +(0,-1.5)$);
\draw ($(P1S2B1.south) +(0,-1)$) -- ($(P1S2B1.south) +(0.5,-1)$) node [anchor=west, code]{Resp1};
\draw ($(P1S2B1.south) +(0,-1.5)$) -- ($(P1S2B1.south) +(0.5,-1.5)$) node [anchor=west, code]{Resp2};
\end{scope}

\begin{scope}[local bounding box=P2a,anchor=north west, shift=(P1a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P2S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P2S1B1.north east) +(0.2,0)$) (P2S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P2S1B1.north west) +(0,2.-5.5)$) (P2S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P2S2B1.north east) +(0.2,0)$) (P2S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P2S1B1) ($(P2S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P2S1) {S4};
\node [fit={(P2S2B1) ($(P2S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P2S2) {S3};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P2S1) (P2S2) }, draw,  Messy, thick] (P2) {};
\draw [Messy, thick] (P2.north west) -- (P2.south west) -- (P2.south east) -- (P2.north east) -- cycle;
\node [Title, anchor = south] at (P2.north) {P2};
\end{scope}

\begin{scope}[local bounding box=P3a,anchor=north west, shift=(P2a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P3S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P3S1B1.north east) +(0.2,0)$) (P3S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P3S1B1.north west) +(0,2.-5.5)$) (P3S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P3S2B1.north east) +(0.2,0)$) (P3S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P3S1B1) ($(P3S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P3S1) {S5};
\node [fit={(P3S2B1) ($(P3S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P3S2) {S6};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P3S1) (P3S2) }, draw,  pattern=fivepointed stars, pattern color=blue, opacity=0.2,Messy, thick] (P3) {};
\draw [Messy, thick] (P3.north west) -- (P3.south west) -- (P3.south east) -- (P3.north east) -- cycle;
\node [Title, anchor = south] at (P3.north) {P3};
\end{scope}

\begin{scope}[local bounding box=P4a,anchor=north west, shift=(P3a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P4S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P4S1B1.north east) +(0.2,0)$) (P4S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P4S1B1.north west) +(0,2.-5.5)$) (P4S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P4S2B1.north east) +(0.2,0)$) (P4S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P4S1B1) ($(P4S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P4S1) {S8};
\node [fit={(P4S2B1) ($(P4S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P4S2) {S7};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P4S1) (P4S2) }, draw,  pattern=grid, pattern color=blue, opacity=0.2,Messy, thick] (P4) {};
\draw [Messy, thick] (P4.north west) -- (P4.south west) -- (P4.south east) -- (P4.north east) -- cycle;
\node [Title, anchor = south] at (P4.north) {P4};
\end{scope}

\begin{scope}[local bounding box=P5a,anchor=north west, shift=(P4a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P5S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P5S1B1.north east) +(0.2,0)$) (P5S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P5S1B1.north west) +(0,2.-5.5)$) (P5S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P5S2B1.north east) +(0.2,0)$) (P5S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P5S1B1) ($(P5S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P5S1) {S9};
\node [fit={(P5S2B1) ($(P5S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P5S2) {S10};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P5S1) (P5S2) }, draw,  Messy, thick] (P5) {};
\draw [Messy, thick] (P5.north west) -- (P5.south west) -- (P5.south east) -- (P5.north east) -- cycle;
\node [Title, anchor = south] at (P5.north) {P5};
\end{scope}

\begin{scope}[local bounding box=P6a,anchor=north west, shift=(P5a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P6S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P6S1B1.north east) +(0.2,0)$) (P6S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P6S1B1.north west) +(0,2.-5.5)$) (P6S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P6S2B1.north east) +(0.2,0)$) (P6S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P6S1B1) ($(P6S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P6S1) {S5};
\node [fit={(P6S2B1) ($(P6S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P6S2) {S6};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P6S1) (P6S2) }, draw,  pattern=fivepointed stars, pattern color=blue, opacity=0.2,Messy, thick] (P6) {};
\draw [Messy, thick] (P6.north west) -- (P6.south west) -- (P6.south east) -- (P6.north east) -- cycle;
\node [Title, anchor = south] at (P6.north) {P6};
\end{scope}

\end{tikzpicture}
```

<details><summary>View data</summary>
```{r data.bio, echo=FALSE, results = 'asis'}
knitr::kable(data.bio, table.attr = "class=\"paperTable\"", format='html')
```
</details>


## data.chem

The `data.chem` dataset represents the same design as the `data.bio`
data except that rather than contain two biological response, it has
two chemical measurements (`Chem1` and `Chem2`) collected from the
same sampling units as the biological responses.

```{tikz}
%| label: tikz_datachem
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]
\begin{tikzpicture}
\coordinate (A) at (0,0);

\begin{scope}[local bounding box=P1a,anchor=north west, shift=(A),on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P1S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S1B1.north east) +(0.2,0)$) (P1S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S1B1.north west) +(0,2.-5.5)$) (P1S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S2B1.north east) +(0.2,0)$) (P1S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P1S1B1) (P1S1B2) +(0,1)}, draw, Messy, thick, Title, text height=0.5cm] (P1S1) {S1};
\node [fit={(P1S2B1) ($(P1S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P1S2) {S2};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P1S1) (P1S2) }, draw, pattern = grid, pattern color=blue, opacity=0.2, Messy, thick] (P1) {};
\draw [Messy, thick] (P1.north west) -- (P1.south west) -- (P1.south east) -- (P1.north east) -- cycle;
\node [Title, anchor = south] at (P1.north) {P1};
\end{scope}

\begin{scope}[anchor=north, shift=(P1S2.south), yshift=-1.5cm, xshift=-2.5cm]
\draw [Messy] (P1S2B1.south) -- ($(P1S2B1.south) +(0,-1.5)$);
\draw ($(P1S2B1.south) +(0,-1)$) -- ($(P1S2B1.south) +(0.5,-1)$) node [anchor=west, code]{Chem1};
\draw ($(P1S2B1.south) +(0,-1.5)$) -- ($(P1S2B1.south) +(0.5,-1.5)$) node [anchor=west, code]{Chem2};
\end{scope}

\begin{scope}[local bounding box=P2a,anchor=north west, shift=(P1a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P2S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P2S1B1.north east) +(0.2,0)$) (P2S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P2S1B1.north west) +(0,2.-5.5)$) (P2S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P2S2B1.north east) +(0.2,0)$) (P2S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P2S1B1) ($(P2S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P2S1) {S4};
\node [fit={(P2S2B1) ($(P2S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P2S2) {S3};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P2S1) (P2S2) }, draw,  Messy, thick] (P2) {};
\draw [Messy, thick] (P2.north west) -- (P2.south west) -- (P2.south east) -- (P2.north east) -- cycle;
\node [Title, anchor = south] at (P2.north) {P2};
\end{scope}

\begin{scope}[local bounding box=P3a,anchor=north west, shift=(P2a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P3S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P3S1B1.north east) +(0.2,0)$) (P3S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P3S1B1.north west) +(0,2.-5.5)$) (P3S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P3S2B1.north east) +(0.2,0)$) (P3S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P3S1B1) ($(P3S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P3S1) {S5};
\node [fit={(P3S2B1) ($(P3S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P3S2) {S6};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P3S1) (P3S2) }, draw,  pattern=fivepointed stars, pattern color=blue, opacity=0.2,Messy, thick] (P3) {};
\draw [Messy, thick] (P3.north west) -- (P3.south west) -- (P3.south east) -- (P3.north east) -- cycle;
\node [Title, anchor = south] at (P3.north) {P3};
\end{scope}

\begin{scope}[local bounding box=P4a,anchor=north west, shift=(P3a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P4S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P4S1B1.north east) +(0.2,0)$) (P4S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P4S1B1.north west) +(0,2.-5.5)$) (P4S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P4S2B1.north east) +(0.2,0)$) (P4S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P4S1B1) ($(P4S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P4S1) {S8};
\node [fit={(P4S2B1) ($(P4S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P4S2) {S7};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P4S1) (P4S2) }, draw,  pattern=grid, pattern color=blue, opacity=0.2,Messy, thick] (P4) {};
\draw [Messy, thick] (P4.north west) -- (P4.south west) -- (P4.south east) -- (P4.north east) -- cycle;
\node [Title, anchor = south] at (P4.north) {P4};
\end{scope}

\begin{scope}[local bounding box=P5a,anchor=north west, shift=(P4a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P5S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P5S1B1.north east) +(0.2,0)$) (P5S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P5S1B1.north west) +(0,2.-5.5)$) (P5S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P5S2B1.north east) +(0.2,0)$) (P5S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P5S1B1) ($(P5S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P5S1) {S9};
\node [fit={(P5S2B1) ($(P5S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P5S2) {S10};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P5S1) (P5S2) }, draw,  Messy, thick] (P5) {};
\draw [Messy, thick] (P5.north west) -- (P5.south west) -- (P5.south east) -- (P5.north east) -- cycle;
\node [Title, anchor = south] at (P5.north) {P5};
\end{scope}

\begin{scope}[local bounding box=P6a,anchor=north west, shift=(P5a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P6S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P6S1B1.north east) +(0.2,0)$) (P6S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P6S1B1.north west) +(0,2.-5.5)$) (P6S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P6S2B1.north east) +(0.2,0)$) (P6S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P6S1B1) ($(P6S1B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P6S1) {S5};
\node [fit={(P6S2B1) ($(P6S2B2) +(1,2)$)}, draw, Messy, thick, Title, text height=0.5cm] (P6S2) {S6};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P6S1) (P6S2) }, draw,  pattern=fivepointed stars, pattern color=blue, opacity=0.2,Messy, thick] (P6) {};
\draw [Messy, thick] (P6.north west) -- (P6.south west) -- (P6.south east) -- (P6.north east) -- cycle;
\node [Title, anchor = south] at (P6.north) {P6};
\end{scope}

\end{tikzpicture}
```

<details><summary>View data</summary>
```{r data.chem, echo=FALSE, results = 'asis'}
knitr::kable(data.chem, table.attr = "class=\"paperTable\"", format='html')
```
</details>


## data.geo

The `data.geo` dataset represent geographical information about the
`Plot`s in the `data.bio` dataset.

```{tikz}
%| label: tikz_datageo
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]
\begin{tikzpicture}
\coordinate (A) at (0,0);

\begin{scope}[local bounding box=P1a,anchor=north west, shift=(A),on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P1S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S1B1.north east) +(0.2,0)$) (P1S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S1B1.north west) +(0,2.-5.5)$) (P1S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P1S2B1.north east) +(0.2,0)$) (P1S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P1S1B1) (P1S1B2) +(0,1)}, draw, thick, Title, text height=0.5cm] (P1S1) {};
\node [fit={(P1S2B1) ($(P1S2B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P1S2) {};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P1S1) (P1S2) }, draw, pattern = grid, pattern color=blue, opacity=0.2, Messy, thick] (P1) {};
\draw [Messy, thick] (P1.north west) -- (P1.south west) -- (P1.south east) -- (P1.north east) -- cycle;
\node [Title, anchor = south] at (P1.north) {P1};
\end{scope}

\begin{scope}[anchor=north, shift=(P1S2.south), yshift=-1.5cm, xshift=-2.5cm]
\draw [Messy] (P1S2B1.south) -- ($(P1S2B1.south) +(0,-1.5)$);
\draw ($(P1S2B1.south) +(0,-1)$) -- ($(P1S2B1.south) +(0.5,-1)$) node [anchor=west, code]{LAT};
\draw ($(P1S2B1.south) +(0,-1.5)$) -- ($(P1S2B1.south) +(0.5,-1.5)$) node [anchor=west, code]{LONG};
\end{scope}

\begin{scope}[local bounding box=P2a,anchor=north west, shift=(P1a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P2S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P2S1B1.north east) +(0.2,0)$) (P2S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P2S1B1.north west) +(0,2.-5.5)$) (P2S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P2S2B1.north east) +(0.2,0)$) (P2S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P2S1B1) ($(P2S1B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P2S1) {};
\node [fit={(P2S2B1) ($(P2S2B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P2S2) {};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P2S1) (P2S2) }, draw,  Messy, thick] (P2) {};
\draw [Messy, thick] (P2.north west) -- (P2.south west) -- (P2.south east) -- (P2.north east) -- cycle;
\node [Title, anchor = south] at (P2.north) {P2};
\end{scope}

\begin{scope}[local bounding box=P3a,anchor=north west, shift=(P2a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P3S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P3S1B1.north east) +(0.2,0)$) (P3S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P3S1B1.north west) +(0,2.-5.5)$) (P3S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P3S2B1.north east) +(0.2,0)$) (P3S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P3S1B1) ($(P3S1B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P3S1) {};
\node [fit={(P3S2B1) ($(P3S2B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P3S2) {};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P3S1) (P3S2) }, draw,  pattern=fivepointed stars, pattern color=blue, opacity=0.2,Messy, thick] (P3) {};
\draw [Messy, thick] (P3.north west) -- (P3.south west) -- (P3.south east) -- (P3.north east) -- cycle;
\node [Title, anchor = south] at (P3.north) {P3};
\end{scope}

\begin{scope}[local bounding box=P4a,anchor=north west, shift=(P3a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P4S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P4S1B1.north east) +(0.2,0)$) (P4S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P4S1B1.north west) +(0,2.-5.5)$) (P4S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P4S2B1.north east) +(0.2,0)$) (P4S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P4S1B1) ($(P4S1B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P4S1) {};
\node [fit={(P4S2B1) ($(P4S2B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P4S2) {};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P4S1) (P4S2) }, draw,  pattern=grid, pattern color=blue, opacity=0.2,Messy, thick] (P4) {};
\draw [Messy, thick] (P4.north west) -- (P4.south west) -- (P4.south east) -- (P4.north east) -- cycle;
\node [Title, anchor = south] at (P4.north) {P4};
\end{scope}

\begin{scope}[local bounding box=P5a,anchor=north west, shift=(P4a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P5S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P5S1B1.north east) +(0.2,0)$) (P5S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P5S1B1.north west) +(0,2.-5.5)$) (P5S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P5S2B1.north east) +(0.2,0)$) (P5S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P5S1B1) ($(P5S1B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P5S1) {};
\node [fit={(P5S2B1) ($(P5S2B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P5S2) {};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P5S1) (P5S2) }, draw,  Messy, thick] (P5) {};
\draw [Messy, thick] (P5.north west) -- (P5.south west) -- (P5.south east) -- (P5.north east) -- cycle;
\node [Title, anchor = south] at (P5.north) {P5};
\end{scope}

\begin{scope}[local bounding box=P6a,anchor=north west, shift=(P5a.north east),xshift =1cm, on background layer] 
\node [minimum width=2cm, minimum height=2cm, Title, Messy] (P6S1B1) {}; 
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P6S1B1.north east) +(0.2,0)$) (P6S1B2) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west,Title, Messy] at ($(P6S1B1.north west) +(0,2.-5.5)$) (P6S2B1) {};
\node [minimum width=2cm, minimum height=2cm, anchor=north west, Title, Messy] at ($(P6S2B1.north east) +(0.2,0)$) (P6S2B2) {};
\end{scope}
\begin{scope}[on background layer]
\node [fit={(P6S1B1) ($(P6S1B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P6S1) {};
\node [fit={(P6S2B1) ($(P6S2B2) +(1,2)$)}, draw, thick, Title, text height=0.5cm] (P6S2) {};
\end{scope} 
\begin{scope}[on background layer]
\node [fit={(P6S1) (P6S2) }, draw,  pattern=fivepointed stars, pattern color=blue, opacity=0.2,Messy, thick] (P6) {};
\draw [Messy, thick] (P6.north west) -- (P6.south west) -- (P6.south east) -- (P6.north east) -- cycle;
\node [Title, anchor = south] at (P6.north) {P6};
\end{scope}

\end{tikzpicture}
```

<details><summary>View data</summary>
```{r data.geo, echo=FALSE, results = 'asis'}
knitr::kable(data.geo, table.attr = "class=\"paperTable\"", format='html')
```
</details>

## tikus

The `tikus` dataset is a data.frame version of the data with the same
name that is provided as a list within the `mvabund` _package_.  The
data contain a the abundance of 75 coral species from different
locations (`rep`) over six years (`time`) at Tikus island.  The
abundance was measured as the length (in cm) of a 10m transect that
intersected with the coral species.

<details><summary>View data</summary>

Note, these data actually have 60 rows and 77 columns.  In order avoid
displaying a huge table in this quick view, I have trimmed the view to
just the first 10 rows and six columns.

```{r tikus, echo=FALSE, results = 'asis'}
knitr::kable(tikus[1:10,1:6], table.attr = "class=\"paperTable\"", format='html')
```
</details>


:::

The great folks over at Rstudio have produced an excellent set of
[cheatsheets](https://www.rstudio.com/resources/cheatsheets) on a
range of topics.  For this tutorial, the **Data Transformation Cheat
Sheet** and **Data Tidying Cheat Sheet** (mainly just the first page)
are useful summaries.
 
::: panel-tabset 

## Data importation

```{r data-import, cache=TRUE,echo=FALSE}
system("convert -resize 650x ../resources/data-import.pdf ../resources/data-import.png")
#system("mv ../docs/resources/data-import-0.png ../docs/resources/data-import.png") 
```
https://github.com/rstudio/cheatsheets/raw/main/data-import.pdf
![](../resources/data-import-0.png "data-import")
![](../resources/data-import-1.png "data-import")

## Data transformations

```{r data-transformation, cache=TRUE,echo=FALSE}
system("convert -resize 650x ../resources/data-transformation.pdf ../resources/data-transformation.png")
#system("mv ../docs/resources/data-import-0.png ../docs/resources/data-import.png") 
```
https://github.com/rstudio/cheatsheets/raw/main/data-transformation.pdf
![](../resources/data-transformation-0.png "data-transformation")
![](../resources/data-transformation-1.png "data-transformation")

## Tidy data

```{r tidyr, cache=TRUE,echo=FALSE}
system("convert -resize 650x ../resources/tidyr.pdf ../resources/tidyr.png")
#system("mv ../docs/resources/data-import-0.png ../docs/resources/data-import.png") 
```
https://github.com/rstudio/cheatsheets/raw/main/tidyr.pdf
![](../resources/tidyr-0.png "tidyr")
![](../resources/tidyr-1.png "tidyr")

## Working with factors

```{r factors, cache=TRUE,echo=FALSE}
system("convert -resize 650x ../resources/factors.pdf ../resources/factors.png")
#system("mv ../docs/resources/data-import-0.png ../docs/resources/data-import.png") 
```
https://github.com/rstudio/cheatsheets/raw/main/factors.pdf
![](../resources/factors.png "factors")

## Working with time/dates

```{r lubridate, cache=TRUE,echo=FALSE}
system("convert -resize 650x ../resources/lubridate.pdf ../resources/lubridate.png")
#system("mv ../docs/resources/data-import-0.png ../docs/resources/data-import.png") 
```
https://github.com/rstudio/cheatsheets/raw/main/lubridate.pdf
![](../resources/lubridate-0.png "lubridate")
![](../resources/lubridate-1.png "lubridate")

## Functional programming (`purrr`)

```{r purrr, cache=TRUE,echo=FALSE}
system("convert -resize 650x ../resources/purrr.pdf ../resources/purrr.png")
#system("mv ../docs/resources/data-import-0.png ../docs/resources/data-import.png") 
```
https://github.com/rstudio/cheatsheets/raw/main/purrr.pdf
![](../resources/purrr-0.png "purrr")
![](../resources/purrr-1.png "purrr")

## Regular expression 

```{r regex, cache=TRUE,echo=FALSE}
system("convert -resize 650x ../resources/regex.pdf ../resources/regex.png")
#system("mv ../docs/resources/data-import-0.png ../docs/resources/data-import.png") 
```
https://github.com/rstudio/cheatsheets/raw/main/regex.pdf
![](../resources/regex.png "regex")

## Strings

```{r strings, cache=TRUE,echo=FALSE}
system("convert -resize 650x ../resources/strings.pdf ../resources/strings.png")
#system("mv ../docs/resources/data-import-0.png ../docs/resources/data-import.png") 
```
https://github.com/rstudio/cheatsheets/raw/main/strings.pdf
![](../resources/strings-0.png "strings")
![](../resources/strings-1.png "strings")

## Tidy evaluation

```{r tidyeval, cache=TRUE,echo=FALSE}
system("convert -resize 650x ../resources/tidyeval.pdf ../resources/tidyeval.png")
#system("mv ../docs/resources/data-import-0.png ../docs/resources/data-import.png") 
```
https://github.com/rstudio/cheatsheets/raw/main/tidyeval.pdf
![](../resources/tidyeval-0.png "tidyeval")
![](../resources/tidyeval-1.png "tidyeval")

:::

# `tidyverse` - a data manipulation ecosystem within R

There are numerous packages and base R routines devoted to data
manipulation. Notable packages include `data.tables`, `plyr`, `dplyr`
and `doBy`. Indeed, earlier versions of this tutorial featured
examples of each of these packages. However, an entire family of
packages from Hadley Wickem's group now stands out as a comprehensive,
intuitive suite of tools for data manipulation and visualisation.

Importantly, all of these packages are designed to integrate together
and complement one another with a consistent interface. To simplify
installing an entire data ecosystem, the tidyverse package is
available. Installing this package (via
`install.packages('tidyverse')`) will install the following packages
(bold entries are automatically loaded into the global environment
when loading the `tidyverse` _package_):

:::: {.columns}

::: {.column width='50%'}
- **`dplyr` - for dataframe manipulation**
- **`tidyr` - for data tidying**
- **`readr` - for importing data**
- **`ggplot2` - for visualising data**
- **`purrr` - for functional programming**
- **`tibble` - for tibbles**
- **`stringr` - for string manipulation**
- **`forecats` - for factor (categorical) manipulation**
- `lubridate` - for dates/times manipulation
:::

::: {.column width='45%'}
- `hmms` - for time manipulation
- `broom` - for tidying model outputs
- `DBI` - for database interactions
- `haven` - for importing SAS, SPSS and Stata files
- `httr` - for web API's
- `jsonlite` - for working with JSON
- `rvest` - for web scraping
- `xml2` - for manipulating XML structures
- `modelr` - for model manipulation
:::
::::

As this tutorial will focus largely on the `tidyverse` ecosystem, we
will now load (attach) this library (actually, eight libraries) to the
global environment so that the functionality is available.

```{r unloadlibrary, echo=FALSE, eval=TRUE, cache=FALSE}
detach(package:tidyverse)
detach(package:dplyr)
detach(package:readr)
## detach(package:gganimate)
detach(package:ggplot2)
detach(package:tidyr)
detach(package:purrr)
detach(package:tibble)
detach(package:stringr)
detach(package:forcats)
detach(package:pander)
```

```{r} 
#| label: libraryA
#| message: true
#| warning: true
#| include: true
#| cache: false
library(tidyverse)
```

```{r libraryPander, eval = TRUE, echo = FALSE, cache = FALSE}
library(pander)
```

Note that when loading the `tidyverse` _package_, we are given
feedback about which other packages have been attached.  Importantly,
also notice that the output highlights a number of **conflicts**.  In
the above example, this indicates that the definition of the `filter`
_function_ is now taken from the the `dplyr` _package_ rather than the
`stats` _package_.  Essentially, both packages define a function
called `filter` and this is just indicating that in the current
environment, the `filter` _function_ from the `dplyr` _package_ will
be the one used.

On a case by case basis, this can be overruled by prefixing the
function name with the package _namespace_.  For example, to ensure
that the `stats` _package_ version of `filter` is used, we can engage
it as `stats::filter()`.

## The grammar of data manipulation

Hadley and his collaborators argue that there is a grammar of data
manipulation and that manipulations comprises a set of verbs.
Furthermore, the philosophy adheres to the UNIX ideal that rather than
attempt to build large complex tools that perform a large set of
operations, it is better (with regards to usability and robustness) to
build a tool set in which each tool performs a single, specific task
and that the individual tools can be bolted together to achieve the
complex operations.

The core of the `tidyverse` data manipulation ecosystem tools (verbs)
can be organised into five categories within two types on the basis
of what aspects of the data they operate on:

- operate on a single data set
  - operate on the rows
    - [`dplyr::arrange`](#sorting-data-arrange) - changing the order of the
      rows (sorting)
    - [`dplyr::filter`](#subset-of-rows-filter) - subset of rows based on
      column values
    - [`dplyr::slice`](#subset-of-rows-by-position-slice) - subset of rows
      based on position
  - operate on the columns
    - [`dplyr::select`](#subset-columns-select) - subset of columns
    - [`dplyr::rename`](#renaming-columns-rename) - change the names of columns
    - [`dplyr::pull`](#select-a-single-column-pull) - extract a single
      column as a vector
    - [`dplyr::distinct`](#distinct) - unique combinations of column
      values
    - [`dplyr::mutate`](#adding-modifying-columns-mutate) - adding columns
      and modifying column values
    - [`tidyr::unite`](#combining-columns-unite) - combine multiple
      columns together
    - [`tidyr::separate`](#separating-columns-separate) - separating a
      single column into multiple columns
  - operate on groups of columns
    - [`dplyr::summarise`](#summarising) - aggregating (collapsing) to a
      single row
    - [`dplyr::count`](#count) - count the number of unique
      combinations single row
    - [`dplyr::group_by`](#grouping) - define groups of rows
  - reshapes (pivots) the data
    - [`tidyr::pivot_longer`](#wide-to-long-pivot_longer) - lengthen
      data from wide format
    - [`tidyr::pivot_wider`](#long-to-wide-pivot_wider) - widen
      data from long format
- operate of two data sets
  - [`_join`](#merging-_join_data_sets) - merge (join) two data sets
    together based on common field(s)

In base R, variables (columns) are referred to by either their name
(as a prefix to the environment - the data.frame etc), name (as a
string) or their index (position).  For example to access a variable
called "Var1" within a dataset called "data", we could use either
`data$Var1`, `data[,"Var1"]` or `data[,1]` (if the focal variable was
in the first column).

The `tidyverse` ecosystem adopts an alternative concept called **tidy
evaluation** to make referring to columns more flexible.

- **data-masking** - refer to variables as if they were directly
  attached to the current environment (e.g. `Var1` instead of
  `data$Var1`.  This form of variable referral is used within:
  - `arrange()` 
  - `filter()`
  - `count()`
  - `mutate()`
  - `summarise()`
  - `group_by()`
- **tidy selection** - refer to variables by their position, name or
  type (e.g. `starts_with("var")`).  This form of variable referral is
  used within:
  - `select()`
  - `rename()`
  - `pull()`
  - `across()` - which brings _tidy selection_ semantics to
    _data-masking_ (and thus functions like `mutate()`)

  The following table highlights the various _tidy-selection_ options.
  The examples all illustrate a hypothetical data set (`data`) with
  hypothetical columns (`Var1`, `Var2`, etc) and cannot be evaluated
  directly. They all mostly illustrate the concept using the
  `select()` _function_.
 
<table class='table table-primary table-bordered table-sm paramsTable' id = 'tidy-select-table'>
<thead>
<tr class = 'header'>
<th align = 'left' width="180px">_tidy-selection_</th>
<th align = 'left'>Description</th>
<th align = 'left' width='250px'>Examples</th>
</tr>
</thead>
<tbody>
<tr class = 'odd'>
<td align = 'left'>Bare names</td>
<td align = 'left'>

Select columns based on their names.<br>Columns can be excluded by
prepending the name with a negative sign (`-`).

</td>
<td align = 'left'>
```{r, eval = FALSE, class = "plain"}
select(data, Var1)
```
```{r, eval = FALSE, class = "plain"}
select(data, Var1, Var2)
```
```{r, eval = FALSE, class = "plain"}
select(data, c(Var1, Var2))
```
```{r, eval = FALSE, class = "plain"}
select(data, -Var1)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>Ranges of columns</td>
<td align = 'left'>

Select columns based on their a range of names or column numbers.  The
selections will be inclusive.  Prepending with a negative sign (`-`)
acts as an exclusion.

</td>
<td align = 'left'>
```{r, eval = FALSE, class = "plain"}
select(data, Var1:Var3)
```
```{r, eval = FALSE, class = "plain"}
select(data, 2:4)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>Boolean helper functions<br>
-`contains()`<br>
-`starts_with()`<br>
-`ends_with()`<br>
-`matches()`<br>
-`num_range()`<br>
-`everything()`<br>
-`where()`<br>
-`all_of()`<br>
-`any_of()`<br>
</td>
<td align = 'left'>

Select columns based on evaluating functions on the column names<br>
- `contains()` - names containing the string<br>
- `starts_with()` - names starting with the string<br>
- `ends_with()` - names starting with the string<br>
- `matches()` - names matched with a [regex](#Gregular-expression)<br>
- `num_range()` - names that start with string followed by numbers<br>
- `everything()` - all variables - useful in combination with other selections<br>
- `where()` - variable inclusion predicated by a function<br>
- `all_of()` - all variables included in a character vector<br>
- `any_of()` - any variables included in a character vector<br><br>
Each of the above can be reversed by prepending with either a exclamation sign (`!`) or negative sign (`-`).<br>
Also note that by default, these are not case sensitive.

</td>
<td align = 'left'>
```{r, eval = FALSE, class = "plain"}
select(data, contains("Var"))
```
```{r, eval = FALSE, class = "plain"}
select(data, !contains("Var"))
```
```{r, eval = FALSE, class = "plain"}
select(data, starts_with("Var"))
```
```{r, eval = FALSE, class = "plain"}
select(data, ends_with("Var"))
```
```{r, eval = FALSE, class = "plain"}
select(data, matches("^.var[1-5]$"))
```
```{r, eval = FALSE, class = "plain"}
select(data, num_range("Var", 1:2))
```
```{r, eval = FALSE, class = "plain"}
select(data, Var3, everything())
```
```{r, eval = FALSE, class = "plain"}
select(data, where(is.numeric))
```
```{r, eval = FALSE, class = "plain"}
vars <- c("Var1", "Var2")
select(data, all_of(vars))
```
```{r, eval = FALSE, class = "plain"}
vars <- c("Var1", "Other")
select(data, any_of(vars))
```
</td>
</tr>
</table>

## Piping

Typically, data manipulation/preparations comprise multiple steps and
stages in which a series of alterations, additions etc are performed
sequentially such that the data are progressively molded into a form
appropriate for analysis etc.  That is, to achieve the desired result,
we must bolt multiple tools (verbs) together.

Traditionally, this would have involved a separate expression for each
step often resulting in the generation of numerous intermediate data
sets. Furthermore, in an attempt to reduce the number of intermediate
steps, functions are often nested within other functions such that
alterations are made inline within another function.

For example, the following pseudo code examples illustrates the
traditional and nested approaches to achieving numerous data
manipulation steps:

:::: {.columns style="display:flex; justify-content:space-evenly;"}

::: {.column width='45%'}
Traditional<br>
```{r pseudo1, eval=FALSE}
data1 <- select(data, ...)
data2 <- group_by(data1, ...)
data3 <- summarise(data2, ...)
```
:::

::: {.column width='45%'}
Nested functions<br>
```{r pseudo2, eval=FALSE}
data <- summarise(group_by(select(data, ...)))
```
:::
::::

Collectively, these practices can yield code that is very difficult to
read and interpret.

A long honoured unix coding principle is that each application should
focus on performing one action and performing that function well. In
order to perform a sequence of actions therefore involves piping (via
the unix pipe character `|`) the output of one application to the
input of another application and so on in a chain. The grammar of data
wrangling also adopts the principle of each tool specializing on one
action and tools should be piped together to achieve a sequence of
actions.

The piping (glue) operator in R (as of version 4.1) is `|>`. An object on the
left hand side of the `|>` operator is passed as the **first
argument** of the function on the right hand side.

::: {.callout-note  collapse="true"}
## Native vs the `magrittr` (`%>%`) pipe
Prior to the native adoption of the pipe character in R, piping was
supported via the `magrittr` package. Within this package, the pipe
operator is `%>%`. Although both the native and `magrittr` pipe
operators are somewhat analogous, they are not homologous.

- **Syntax:**

  - Native pipe: Simple `|>` symbol placed between the expression and
    function call.
  - Magrittr pipe: Double percentage signs `%>%` offering visual
    distinction from surrounding code.

- **Placeholder:**

  - Native pipe: No built-in placeholder for piped-in values.
    Functions need to handle them explicitly.
  - Magrittr pipe: Dot placeholder (`.`), allowing concise access to
    piped-in values within the function call.

- **Functionality:**

  - Native pipe: More basic functionality, primarily focused on
    function chaining.
  - Magrittr pipe: Offers additional features like:
    - Exposition pipe (`%~$%`): Displays the values passed through the
      pipe, facilitating debugging.
    - Interjection pipe (`~>%`): Modifies the piped-in value before
      passing it to the next function.
    - Lazy evaluation: Delays intermediate calculations until
      necessary, potentially improving performance.

- **Scope:**

  - Native pipe: Recently introduced, integrated directly into R Base
    package.
  - Magrittr pipe: A separate package, offering more extensibility and
    customization options.

- **Adoption:**

  - Native pipe: Gaining popularity due to its simplicity and
    integration with base R.
  - Magrittr pipe: Widely used, having established a large community
    and ecosystem of compatible packages.

- **Choosing between them depends on:**

  - Personal preference: Some prefer the visual clarity of %>%, while
    others favor the simplicity of `|>`.
  - Project requirements: Consider the need for features like the dot
    placeholder or additional pipe types.
  - Team collaboration: Choose a consistent style for shared code or
    adhere to project standards.

Ultimately, both pipes are powerful tools for data manipulation in R.
Understanding their differences helps you choose the most appropriate
option for your specific needs and coding style.

:::

In pseudo code, the piping approach to the above manipulation would
be:

```{r pseudo3, eval=FALSE}
data <- data |>
    select(...) |>
    group_by(...) |>
    summarise(...)
```

If the code is set out as above (with each verb on a separate line),
it gives an opportunity to provide a short comment to the right side
of each line to provide useful documentation.

<details><summary>A more specific example</summary> 

As a motivating (if not a bit extreme) example, lets say we wanted to
calculate the logSumExp function:
			
$$
log(\sum^{n}_{i=1} e^{x_i})
$$

```{r eg, eval=TRUE, cache=FALSE}
## Generate some data
set.seed(123)
x <- rgamma(10,5,1)
## Calculate the logSumExp
log(sum(exp(x)))
## OR
x1 <- exp(x)
x2 <-sum(x1)
log(x2)
```

The piping approach could be:

```{r eg1, eval=TRUE, cache=FALSE}
x |> exp() |> sum() |> log()
```

To reiterate, the following three are equivalent:
```{r eg2, eval=TRUE, cache=FALSE}
exp(x)
x |> exp()
```

as are the following:
```{r eg3, eval=TRUE}
log(x, base=10)
x |> log(base=10)
```

</details>

Most of the following examples will demonstrate isolated data
manipulation actions (such as filtering, summarising or joining) as
this focuses on the specific uses of these functions without the
distractions and complications of other actions.  For isolated uses,
piping has little (if any) advantages.  Nevertheless, in recognition
that data manipulations rarely comprise a single action (rather they
are a series of linked actions), for all remaining examples
demonstrated in the `tidyverse` (`dplyr`/`tidyr`) context, piping will
be used.

## Tibbles

`data.frame`'s are collections of variables of the identical length
(yet not necessarily the same type) that the fundamental data
structures used by most modelling routines in R.  Nevertheless, there
are numerous properties of data.frames that make them less than ideal.
`tibbles` have been more recently engineered to address these shortcomings:

- if a `data.frame` is very large, the `print` method can result
  output that is too large to be useful.  By contrast, `tibbles`
  truncate the output to a maximum of 10 rows and as many columns as
  will fit in the output.  The `tibble` `print` _method_ also displays
  the class (type) of each column (variable).

  <details><summary>show comparison</summary>
  :::: {.columns style="display:flex; justify-content:space-evenly;"}
  
  ::: {.column width="49%"}
  ```{r, cache=FALSE}
  dat.1 |> as.data.frame() 
  ```
  :::
	  
  ::: {.column width="49%"}
  ```{r, cache=FALSE}
  dat.1 |> as_tibble()
  ```
  :::
   
  ::::
  </details>
- `data.frame`s have very strict column naming rules and when these
  are not satisfied, the names will be altered in order to adhere to
  the rules.  `tibble`s permit a wider range of names.
  <details><summary>show comparison</summary>
  :::: {.columns style="display:flex; justify-content:space-evenly;"}
  
  ::: {.column width="49%"}
  ```{r, cache=FALSE}
  data.frame('1.3' = 1:6, 'Wt (kg)' = 1:6)
  ```
  :::
	  
  ::: {.column width="49%"}
  ```{r, cache=FALSE}
  tibble('1.3' = 1:6, 'Wt (kg)' = 1:6)
  ```
  :::
  
  ::::
  </details>
- character vectors are often coerced into factors (categorical
  variables).  This is not the case with `tibble`s.
- when vectors are added that are of a different length to the others
  in the `data.frame`, the values of the shorter vector(s) are
  recycled until all vectors are the same length.  This behaviour can
  be dangerous and is not permitted in tibbles (except for vectors of
  length of one).

  <details><summary>show comparison</summary>
  :::: {.columns style="display:flex; justify-content:space-evenly;"}
  
  ::: {.column width="49%"}
  ```{r, cache=FALSE}
  data.frame(Var1 = 1:6, Var2 = 1:2, Var3 = 1)
  ```
  :::
	  
  ::: {.column width="49%"}
  ```{r, cache=FALSE, error = TRUE}
  tibble(Var1 = 1:6, Var2 = 1:2, Var3 = 1)
  tibble(Var1 = 1:6, Var2 = 1)
  ```
  :::
  
  ::::
  </details>
- when sub-setting via column indices, `data.frame`s return a vector
  (when only a single index is provided) or a data.frame (if multiple
  indices are provided).  This inconsistency is problematic in the
  context of a processing pipeline.  `tibble`'s will always return a
  `tibble` from column indices.

  <details><summary>show comparison</summary>
  :::: {.columns style="display:flex; justify-content:space-evenly;"}
  
  ::: {.column width="49%"}
  ```{r, cache=FALSE}
  as.data.frame(dat.1)[,2]
  ```
  :::
	  
  ::: {.column width="49%"}
  ```{r, cache=FALSE, error = TRUE}
  as_tibble(dat.1)[,2]
  ```
  :::
  
  ::::
  </details>
- `data.frame`s permit partial matching via `$` indexing.  This can be
  problematic in the context of a processing pipeline.  `tibble`s
  expressly forbid this.

  <details><summary>show comparison</summary>
  :::: {.columns style="display:flex; justify-content:space-evenly;"}
  
  ::: {.column width="49%"}
  ```{r, cache=FALSE}
  as.data.frame(dat.1)$Plo
  ```
  :::
	  
  ::: {.column width="49%"}
  ```{r, cache=FALSE, error = TRUE, warning = TRUE}
  as_tibble(dat.1)$Plo
  ```
  :::
  
  ::::
  </details>
- `data.frame`s have very clumsy support for _list columns_ (a list
  column is a column whose cells contain lists).  List columns are
  better supported in `tibble`s.  The ability to support list columns
  is an integral for the _functional programming_ routines of the
  `purrr` package.

  <details><summary>show comparison</summary> 
  
  In this fictitious example, I would like to store three different
  `data.frames` (or any three objects for that matter) in the three
  cells of a variable (e.g. `Var2`).  This is not possible in a
  `data.frame` - it will coerce the `Var2` column into multiple
  columns (one for each object) and thus will also recycle the length
  of each to ensure they are all the same length.  Once the data have
  been coerced into a `data.frame`, the structure is lost (we can no
  longer access `Var2`).
 
  These issues are addressed in the `tibble`.

  :::: {.columns style="display:flex;justify-content:space-evenly;"}
  
  ::: {.column width="49%"}
  ```{r, cache=FALSE}
  D <- data.frame(Var1 = LETTERS[1:3],
             Var2 = list(
                 data.frame(a = 1:6),
                 data.frame(a = 1:3),
                 data.frame(a = 1:2)
             ))
  D
  D$Var2
  ```
  :::
	  
  ::: {.column width="49%"}
  ```{r, cache=FALSE, error = TRUE, warning = TRUE}
  D <- tibble(Var1 = LETTERS[1:3],
         Var2 = list(
             data.frame(a = 1:6),
             data.frame(a = 1:3),
             data.frame(a = 1:2)
             ))
  D
  D$Var2
  ```
  :::
  
  ::::
  </details>

# Summary and vectorised functions

Many data manipulation actions involve the use of specific auxiliary
_functions_ to act on specific parts of the data set. For example, if
we wish to summarise a data set, we might apply a `mean()` _function_
to the numeric vectors (variables) and `levels()` or `unique()`
_function_ to character or factor vectors. That is, the function is
applied to each vector as a whole.  Such functions are called
**summary** _functions_.

On the other hand, if we wish to generate log-transformed versions of
the numeric vectors, then we would apply the `log()` _function_ to
each value within those numeric vectors. Furthermore, we might use
other auxiliary functions that return vectors of either boolean values
(TRUE or FALSE) or integers that can represent row or column indices
to determine which observations to perform actions on.

:::: {.columns style="display:flex;justify-content:space-evenly;"}

::: {.column style="width:45%;font-size:8pt;"}

```{tikz}
%| label: tikz_summary
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| out-width: 90%
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=1.5]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!20,
                text=white,
                font=\bfseries
            }
        }
    }
}

\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
\\
\\
\\
\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!60!black!60]|\\
};

%\shadedraw[left color=gray,right color=green, draw=green!50!black]
%(0,0) -- (3mm,0mm) arc (0:30:3mm) -- cycle;

%\shadedraw[draw,left color=red, right color=blue] (0,1) -- (2,0.5) -- (2,0.75) -- (3,0() -- (2,-0.75) -- (2,-0.5) -- (0,-1) -- cycle;
 
%\shadedraw[draw,left color=black!20, right color=blue!60] ($(first.north east) + (0,-0.2)$) -- 
\shadedraw[draw,left color=black!20, right color=blue!60] ($(first.north east) + (0,-0.2)$) -- 
%\draw[draw,fill=blue!60] ($(first.north east) + (0,-0.2)$) -- 
 ($($(first.north east) !0.75! (first.east)$) +(4,0)$) --
 ($($(first.north east) !0.5! (first.east)$) +(4,0)$) -- (6,0) --
 ($($(first.south east) !0.5! (first.east)$) +(4,0)$) --
 ($($(first.south east) !0.75! (first.east)$) +(4,0)$) --
 ($(first.south east) + (0,0.2)$) -- cycle;
\node [anchor=center,Title] at (3,0) (text) {\begin{minipage}{2cm}summary\\function\end{minipage}};
%\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {summaryFnct()} ++(second);
  
\end{tikzpicture}
```

:::

::: {.column style="width:45%;font-size:8pt;"}

```{tikz}
%| label: tikz_vectorised
%| engine: tikz
%| echo: false
%| cache: true
%| out-width: 90%
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=1.5]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!20,
                text=white,
                font=\bfseries
            }
        }
    }
}

\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
\\
\\
\\
\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!60!black!60]|\\
|[fill=blue!60!black!60]|\\
|[fill=blue!60!black!60]|\\
|[fill=blue!60!black!60]|\\
};

%\shadedraw[left color=gray,right color=green, draw=green!50!black]
%(0,0) -- (3mm,0mm) arc (0:30:3mm) -- cycle;

%\shadedraw[draw,left color=red, right color=blue] (0,1) -- (2,0.5) -- (2,0.75) -- (3,0() -- (2,-0.75) -- (2,-0.5) -- (0,-1) -- cycle;
 
\shadedraw[draw,left color=black!20, right color=blue!60] ($($(first.north east) !0.5! (first.east)$) +(0,0)$) -- 
 ($($(first.north east) !0.5! (first.east)$) +(4,0)$) --
 ($($(first.north east) !0.25! (first.east)$) +(4,0)$) -- (6,0) --
 ($($(first.south east) !0.25! (first.east)$) +(4,0)$) --
 ($($(first.south east) !0.5! (first.east)$) +(4,0)$) --
 ($($(first.south east) !0.5! (first.east)$) +(0,0)$) -- cycle;
\node [anchor=center,Title] at (3,0) (text) {\begin{minipage}{2cm}vectorized\\function\end{minipage}};
%\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {vectorizedFnct()} ++(second);
  
\end{tikzpicture}
```

:::

::::


Broadly speaking, **summary** functions take a vector and return a
single value. Familiar examples of summary functions are `mean()`,
`var()`, `min()` etc. By contrast, **vectorised** functions take a
vector and return a vector of the same length as the original input
vector. `rank()`, `cumsum()` and `log()` are all examples of such
vectorised (window) functions.

The `dplyr` _package_ introduces a number of additional summary and
vectorised functions that are deemed useful augmentations of the
standard set of functions available in base R. The following tables
describes the most useful functions (from `base` and `dplyr`) along with
which manipulation functions they can be applied. Those functions
defined in `dplyr` include the `dplyr` **namespace**.


There are also some operations that appear to provide a mixture of
both summary and vectorised functions.  The `scale()` _function_
(which centres and scales a vector), for example, returns a vector of
scaled values as well as storing the original mean and standard
deviation (summaries) as attributes.

To demonstrate summary and vectorised functions, the following vectors
will be used.

```{r summary_vectorised}
## set a random seed to ensure the same values each time
set.seed(123)
## a numeric vector generated from random draws from a gamma distribution
(x <- rgamma(10, 5, 1))
## a character vector
(A <- sample(letters[1:2], size = 10, replace = TRUE))
## a boolean vector
(B <- sample(c(TRUE, FALSE), size = 10, replace = TRUE))
```

## Summary functions

<table class='table table-primary table-bordered table-sm paramsTable'>
<thead>
<tr class = 'header'>
<th align = 'left'>Function</th>
<th align = 'left'>Description</th>
<th align = 'left' width='300px'>Examples</th>
</tr>
</thead>
<tbody>
<tr class = 'odd'>
<td align = 'left'>`mean()`, `median()`</td>
<td align = 'left'>Arithmetic mean and median.<br>

Note, boolean vectors are stored as a set of 0 (FALSE) and 1 (TRUE)
and thus mathematical functions operate on them as if they were
numbers.

</td>
<td align = 'left'>
```{r summaryFn1, class = "plain"}
mean(x)
median(B)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`sum()`, `prod()`</td>
<td align = 'left'>Sum and product.
</td>
<td align = 'left'>
```{r summaryFn2, class = "plain"}
sum(x)
prod(B)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`var()`, `sd()`</td>
<td align = 'left'>Variance and standard deviation.
</td>
<td align = 'left'>
```{r summaryFn3, class = "plain"}
var(x)
sd(B)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`mad()`, `IQR()`</td>
<td align = 'left'>Median Absolute Deviation and Inter-Quartile Range.
</td>
<td align = 'left'>
```{r summaryFn4, class = "plain"}
mad(x)
IQR(B)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`min()`, `max()`</td>
<td align = 'left'>Minimum and maximum.
</td>
<td align = 'left'>
```{r summaryFn5, class = "plain"}
min(x)
max(B)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`quantile()`</td>
<td align = 'left'>Quantiles
</td>
<td align = 'left'>
```{r summaryFn6, class = "plain"}
quantile(x)
quantile(x, p = 0.25)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`dplyr::first()`, `dplyr::last()`, `dplyr::nth()`</td>
<td align = 'left'>First, laste and nth value.
</td>
<td align = 'left'>
```{r summaryFn7, class = "plain"}
first(x)
first(x, order_by = A)
last(B)
nth(A, n = 4)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`dplyr::n()`, `dplyr::n_distinct()`</td>
<td align = 'left'>Number of values, number of distinct values.<br>

`n()` is a special case that can only be used within the context of a
`data.frame` or `tibble`.

</td>
<td align = 'left'>
```{r summaryFn8, class = "plain"}
n_distinct(A)
```
</td>
</tr>
</table>

## Vectorised functions

<table class='table table-primary table-bordered table-sm paramsTable'>
<thead>
<tr class = 'header'>
<th align = 'left'>Function</th>
<th align = 'left'>Description</th>
<th align = 'left' width='300px'>Examples</th>
</tr>
</thead>
<tbody>
<tr class = 'odd'>
<td align = 'left'>`+,-,*,/,^,%/%, %%`</td>
<td align = 'left'>typical arithmetic operators</td>
<td align = 'left'>
```{r vectorFn1, R.options = list(width = 45), class = "plain"}
x + 2
x * B
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`log()`,`log2()`,`log10()`, `exp()`</td>
<td align = 'left'>logarithms and exponentials</td>
<td align = 'left'>
```{r vectorFn2, R.options = list(width = 45), class = "plain"}
log(x)
log10(x)
exp(x)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`<,<=,>,>=,!=,==`</td>
<td align = 'left'>logical operators</td>
<td align = 'left'>
```{r vectorFn3, R.options = list(width = 45), class = "plain"}
x < 5
B == TRUE
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`between()`</td>
<td align = 'left'>Whether a value is between two numbers</td>
<td align = 'left'>
```{r vectorFn4, R.options = list(width = 45), class = "plain"}
between(x, 3, 5)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`near()`</td>
<td align = 'left'>A safe way of assessing equality (`==`) in floating points</td>
<td align = 'left'>
```{r vectorFn5, R.options = list(width = 45), class = "plain"}
x == 3.39
near(x, y = 3.39, tol =0.01)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`lag()`, `lead()`</td>
<td align = 'left'>shift cases down/up by one</td>
<td align = 'left'>
```{r vectorFn6, R.options = list(width = 45), class = "plain"}
lag(x)
lead(x)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`cummax()`, `cummin()`, `dplyr::cummean()`</td>
<td align = 'left'>Cumulative max, min and mean</td>
<td align = 'left'>
```{r vectorFn7, R.options = list(width = 45), class = "plain"}
cummax(x)
cummin(B)
cummean(x)
cummean(x > 2)
cummean(B)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`cumsum()`, `cumprod()`</td>
<td align = 'left'>Cumulative sum and product</td>
<td align = 'left'>
```{r vectorFn8, R.options = list(width = 45), class = "plain"}
cumsum(x)
cumsum(x > 3)
cumprod(B)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`dplyr::cumall()`, `dplyr::cumany()`</td>
<td align = 'left'>Cumulative all and any (mainly for use with filtering).</td>
<td align = 'left'>
```{r vectorFn9, R.options = list(width = 45), class = "plain"}
cumall(x)
cumall(x > 2)
cumany(x > 4)
cumany(B)
cumall(B)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`rank()`, `order()`</td>
<td align = 'left'>Rank and order of items</td>
<td align = 'left'>
```{r vectorFn10, R.options = list(width = 45), class = "plain"}
rank(x)
order(x)
rank(B)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`dplyr::min_rank()`, `dplyr::dense_rank()`, `dplyr::percent_rank()`</td>
<td align = 'left'>Rank in which ties = min, without gaps and expressed as a percentage.</td>
<td align = 'left'>
```{r vectorFn11, R.options = list(width = 45), class = "plain"}
min_rank(x)
dense_rank(x)
percent_rank(x)
rank(B)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`dplyr::row_number()`</td>
<td align = 'left'>Rank in which ties = first.</td>
<td align = 'left'>
```{r vectorFn12, R.options = list(width = 45), class = "plain"}
row_number(x)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`dplyr::cume_dist()`</td>
<td align = 'left'>Cumulative empirical distribution (proportion less than current value).</td>
<td align = 'left'>
```{r vectorFn13, R.options = list(width = 45), class = "plain"}
cume_dist(x)
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`dplyr::ntile()`</td>
<td align = 'left'>Partition into (n) bins.</td>
<td align = 'left'>
```{r vectorFn14, R.options = list(width = 45), class = "plain"}
ntile(x, n = 3)
```
</td>
</tr>
<tr class = 'odd'>
<td align = 'left'>`dplyr::if_else()`</td>
<td align = 'left'>Elementwise (case by case) if and else.</td>
<td align = 'left'>
```{r vectorFn15, R.options = list(width = 45), class = "plain"}
if_else(x > 3, true = "H", false = "L")
```
</td>
</tr>
<tr class = 'even'>
<td align = 'left'>`dplyr::case_when()`</td>
<td align = 'left'>Elementwise multiple if and else.</td>
<td align = 'left'>
```{r vectorFn16, R.options = list(width = 45), class = "plain"}
case_when(x <= 3 ~ "L",
          x > 3 & x <= 6 ~ "M",
          x > 6 ~ "H")
```
</td>
</tr>
</table>

# Sorting data (`arrange`)

```{tikz}
%| label: tikz_arrange
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 1/.style={
            nodes={text width=2em,font=\bfseries}
        },
        column 2/.style={
            nodes={text width=2em}
        },
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}
\begin{tikzpicture}
\matrix (first) [table,text width=4em]{
&  &   & \\    
&  & |[fill=black!80]| & \\    
&  & |[fill=black!20]|  & \\    
&  & |[fill=black!60]|  & \\    
&  & |[fill=black!40]|  & \\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
&  &   & \\    
&  & |[fill=black!20]| & \\    
&  & |[fill=black!40]|  & \\    
&  & |[fill=black!60]|  & \\    
&  & |[fill=black!80]|  & \\
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {arrange()} ++(second);
\node [Title,above=0.75cm of first.north,anchor=north] (Raw)  {Raw data};
\node [Title,above=0.75cm of second.north,anchor=north] (Sorted)  {Sorted data};
\end{tikzpicture}
```

Most statistical analyses are invariant to the data order and thus
data reordering is typically only for aesthetics in tables and
figures.

Sorting data has the potential to be one of the most dangerous forms
of data manipulation - particularly in spreadsheets in which there is
no real binding between individual columns or rows. It is far to easy
to accidentally sort the data in a single column (or row) without
applying the ordering to all the other columns in the data set thereby
resulting in broken data.

Whilst the above apocalypse is still possible in R, the data
structures and manipulation interfaces mean that you really have to
try to break the data in this way. Furthermore, you are encouraged to
store reordered data in a different object to the original data, and
hence 'rolling' back is trivial.
 
<!--
:::: {.columns style="display:flex;justify-content:space-evenly;"}

::: {.column style="width:40%;font-size:8pt;"}
-->
```{r dat1View, cache=FALSE, echo=FALSE}
dat.1 |>
    head(10) |>
    knitr::kable(table.attr = "class=\"paperTable table-condensed\"", format='html',
                 caption="First 10 rows of the `dat.1` data.frame")
```
<!--
:::

::: {.column style="width:60%;font-size:10pt;"}
-->

::: {.panel-tabset .tabset-left}

### Sort by Resp1

```{r arrange1, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> arrange(Resp1) |>
    head()
```

### Sort by Resp1 (descending order)

```{r arrange2, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> arrange(desc(Resp1)) |>
    head()
```

### Sort by Dose and then Resp1

```{r arrange3, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> arrange(Dose, Resp1) |>
    head()
```

### Sort by sum of Resp1 and Resp2

```{r arrange4, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> arrange(Resp1 + Resp2) |>
    head()
```

### Sort by Dose then by mean of Resp1 and Resp2 

```{r arrange5, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> arrange(Dose, mean(c(Resp1, Resp2))) |>
    head()
```
<!--
:::

::::
-->

:::

# Subsets of data

We regularly want to run an analysis or generate tabular/graphic
summaries for a sub-set of the data.  For example, we may wish to
reduce the number of columns in the data frame to remove excessive and
unwanted data fields.  Alternatively (or additionally), we may wish to
focus on a subset of the rows.  These two forms of sub-setting are:

- `select`ing - reducing the number of columns
- `filter`ing - reducing the number of rows

## Subset columns (`select`) 

Selecting works by either including (or excluding) the column names
that you indicate or via special selection 'Helper' functions that
pass a vector of column indices to include in the subset data.

```{tikz}
%| label: tikz_select
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 1/.style={
            nodes={text width=2em,font=\bfseries}
        },
        column 2/.style={
          nodes={text width=2em, fill=blue!40}
        },
        column 3/.style={
          nodes={text width=2em, fill=blue!40}
        },
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}
\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
& |[fill=blue!70]| & |[fill=blue!70]| & & |[fill=blue!70]|\\    
&  &  & &\\    
&  &  & &\\    
&  &  & &\\    
&  &  & &\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!70]|& |[fill=blue!70]| & |[fill=blue!70]| \\    
|[fill=blue!40]|&  &  \\    
|[fill=blue!40]|&  &  \\    
|[fill=blue!40]|&  &  \\    
|[fill=blue!40]|&  &  \\
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {select()} ++(second);
\node [Title,above=0.75cm of first.north,anchor=north] (Raw)  {Raw data};
\node [Title,above=0.75cm of second.north,anchor=north] (Subset)  {Subset data};
\end{tikzpicture}
```

:::: {.columns style="display:flex;justify-content:space-evenly;"}

::: {.column style="width:40%;font-size:8pt;"}

```{r dat1View, cache=FALSE, echo=FALSE}
```

:::
 
::: {.column style="width:60%;font-size:10pt;"}
<!--
| Helper function | Select variables ...                                                        |
|-----------------|-----------------------------------------------------------------------------|
| `contains()`    | Whose name contains the "string"                                            |
| `starts_with()` | Whose name starts with "string"                                             |
| `ends_with()`   | Whose name ends with "string"                                               |
| `matches()`     | Whose name is matched with a [regex](#Gregular-expression)                  |
| `num_range()`   | Whose name starts with "string" followed by "numbers"                       |
| `everything()`  | All variables - useful in combination with other selection helper functions |
| `all_of()`      | Checks that all nominated variables are present                             |
| `any_of()`      | Acts on any nominated variables that are present                            |
| `where()`       | Whose variable is predicated by a function                                  |
Note, by default, the above searchers are NOT case sensitive
-->
:::

::::

```{css, echo=FALSE}
```

    
	
The `select()` _function_ users [_tidy-select_ semantics](#tidy-select-table).

::: {.panel-tabset .tabset-left}

### Inclusion / exclusion of from bare names
Select specific variables	
```{r select1, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(Treatment, Dose, Time, Resp1) |>
    head() 
```
Exclude specific variables
```{r select2, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(-Plot, -Resp2) |>
    head()
```

### Inclusion / exclusion based on position

Include columns `Treatment` through to `Time`
```{r select7, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(Treatment:Time) |>
    head() 
```
Exclude columns `Treatment` through to `Time`
```{r select7a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(-(Treatment:Time)) |>
    head() 
```
Exclude columns `Treatment` through to `Time`
```{r select7b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(!(Treatment:Time)) |>
    head() 
```
### Inclusion / exclusion from name predicates
Names containing and 'r' (case insensitive)
```{r select3, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(contains("R")) |>
    head() 
```
Names starting with 'r' (case insensitive)
```{r select4, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(starts_with("R")) |>
    head() 
```
Names ending in 'e' (case insensitive)
```{r select5, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(ends_with("e")) |>
    head() 
```
Names that are exactly four characters long
```{r select6, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(matches("^.{4}$")) |>
    head()
```

### Select and `num_range`

```{r select8, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(num_range("Resp", 1:2)) |>
    head()
```

### Reorder columns...

```{r select9, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(num_range("Resp", 1:2),
                 everything()) |>
    head() 
```

### Select and `all_of` / `any_of` 
Select from a vector of strings
```{r select10, cache=FALSE, error = TRUE, warning = TRUE}
Vars <- c("Resp1", "Resp2")
dat.1 |> select(all_of(Vars)) |>
    head()
```

Select from string vector of strings...
```{r select11, cache=FALSE, error = TRUE, warning = TRUE}
Vars <- c("Resp1", "Resp2", "Resp3")
dat.1 |> select(any_of(Vars)) |>
    head() 
```

```{r select12, cache=FALSE, error = TRUE, warning = TRUE}
Vars <- c("Resp1", "Resp2", "Resp3")
dat.1 |> select(-any_of(Vars)) |>
    head() 
```

### Select and `where`

```{r select13, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> select(where(is.numeric)) |>
    head() 
```
:::

Since `tibble`s permit column names that have special characters in
them, in order to refer to a column that has a name with special
characters, it is necessary to enclose the name in backticks.  For
example, to select the variable, `Pocillopora damicornis` (which
contains a space in the name - these are not permitted in
`data.frame`s, yet are permitted in `tibble`s) and `print` the first
six rows:

```{r select14, cache=FALSE, error = TRUE, warning = TRUE}
tikus |>
    select(`Pocillopora damicornis`) |>
    head()
```


## Renaming columns (`rename`)
Note, it is possible to have column names renamed during a `select`
action.

Both the `rename()` and `select()` _functions_ user [_tidy-select_ semantics](#tidy-select-table).

```{r select15, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |>
    select("Weight" = Resp1) |>
    head()
```
If we want to retain the other variables, we would also have to include them in the `select` either explicitly, or via a helper function.

```{r select16, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |>
    select(everything(), "Weight" = Resp1) |>
    head()
```
However, note that this might not retain the order of the columns.  Hence, for simple renaming of columns, the `rename` _function_ is more convenient.

```{r rename, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |>
    rename("Weight" = Resp1) |>
    head()
```

It is also possible to rename columns based on a lookup (list or
data.frame).  This is handy for cases when data columns have
conveniently abbreviated names yet you are preparing data for tabular
output - and thus need more descriptive column names.

```{r rename1, cache=FALSE, error = TRUE, warning = TRUE}
lookup <- list("Response 1" = "Resp1",
               "Response 2" = "Resp2")
dat.1 |>
    rename(!!!lookup) |>
    head()
```

In the above example, the _big bang operator _ `!!!` forces-splice a
list operator.  That is, the elements of the list are spliced into the
statement as if they had been included directly.

To do the same from a data.frame lookup..

```{r rename2, cache=FALSE, error = TRUE, warning = TRUE}
lookup <- tribble(
    ~Abbr_name, ~Long_name,
    "Resp1",     "Response 1",
    "Resp2",     "Response 2")
## Convert to list of pairs
lookup <- lookup |>
    select(Long_name, Abbr_name) |> 
    deframe() |>
    list()
dat.1 |>
    rename(!!!lookup) |>
    head()
```

    
## Select a single column (`pull`)

As indicated earlier, single column indices on `tibble`s return a single column `tibble`.  To extract a single column as a vector, there is a `pull` _function_.

The `pull()` _function_ users [_tidy-select_ semantics](#tidy-select-table).

```{r pull, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> pull(Resp1) 
```


## Subset of rows (`filter`)

Filtering selects rows for which a condition is evaluated to be
TRUE. Hence, any logical expression or vectorized function that
returns Boolean values (TRUE or FALSE) can be used for filtering.

The `filter()` _function_ users [_data-masking_ semantics](#the-grammar-of-data-manipulation).

```{tikz}
%| label: tikz_filter
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}
\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
&  &  &\\    
&  &  &\\    
|[fill=blue!40]| & |[fill=blue!40]| & |[fill=blue!40]| & |[fill=blue!40]| \\    
|[fill=blue!40]| & |[fill=blue!40]| & |[fill=blue!40]| & |[fill=blue!40]| \\    
&  &  &\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!70]|& |[fill=blue!70]| & |[fill=blue!70]| & |[fill=blue!70]|  \\    
|[fill=blue!40]|& |[fill=blue!40]| & |[fill=blue!40]| & |[fill=blue!40]|  \\    
|[fill=blue!40]|& |[fill=blue!40]| & |[fill=blue!40]| & |[fill=blue!40]|  \\    
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {filter()} ++(second);

\node [Title,above=0.75cm of first.north,anchor=north] (Raw)  {Raw data};
\node [Title,above=0.75cm of second.north,anchor=north] (Filtered)  {Filtered data};
\end{tikzpicture}
```

:::: {.columns style="display:flex;justify-content:space-evenly;"}

::: {.column style="width:45%;font-size:10pt;"}

```{r dat1View, cache=FALSE, echo=FALSE}
```

:::
 
::: {.column style="width:55%;font-size:12pt;"}

: {.primary .bordered .sm .paramsTable}

| Helper function | Combine multiple selections ... |
|-----------------|---------------------------------|
| `if_any()`      | With an an *OR*                 |
| `if_all()`      | With an *AND*)                  |
Note, by default, the above searchers are NOT case sensitive


: {.primary .bordered .sm .paramsTable}

| Logical/Boolean function | Description                 |
|--------------------------|-----------------------------|
| `==`                     | is equal to                 |
| `!=`                     | is not equal to             |
| `<`                      | is less than                |
| `>`                      | is greater than             |
| `<=`                     | is less than or equal to    |
| `>=`                     | is greater than or equal to |
| `is.na()`                | is equal to `NA`            |
| `!is.na()`               | is not equal to `NA`        |
| `%in%`                   | is in the following vector  |
| `!`                      | not                         |
| `&`  `&&`                | logical AND                 |
| `|` `||`                 | logical OR                  |
| `xor()`                  | elementwise OR              |
| `isTRUE()`               | is true                     |
| `isFALSE()`              | is false                    |
:::

::::

::: {.panel-tabset .tabset-left}

### Filter by category level
	
```{r filter1, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(Dose == "H")
```

### Filter by multiple category levels
	
```{r filter2, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(Dose %in% c("H", "M"))
```

### Filter by numeric
	
```{r filter2a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(Resp1 < 25)
```

### Filter and `between`
	
```{r filter2b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(between(Resp1, 15, 25))
```

### Filter by numeric (cumulative functions)
Keep all cases after a value of Resp1 has exceeded 200	
```{r filter2c, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(cumany(Resp1 > 200))
```
Keep all cases until the first case of Resp1 < 25
```{r filter2d, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(cumall(Resp1 < 25))
```

### Filter by multiple filters (AND)
	
```{r filter3, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(Dose == "H", Resp1 < 25)
##OR
dat.1 |> filter(Dose == "H" & Resp1 < 25)
```

### Filter by multiple filters (OR)
	
```{r filter4, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(Dose == "H" | Resp1 < 25)
```

### Filter by multiple selection filters (AND)
	
```{r filter5, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(if_all(starts_with("Resp"), ~ . < 25))
```

### Filter by multiple selection filters (OR)
	
```{r filter6, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> filter(if_any(starts_with("Resp"), ~ . < 25))
```
:::

## Subset of rows by position (`slice`) 

::: {.panel-tabset .tabset-left}

### Keep rows 1 through to 4
	
```{r slice1, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> slice(1:4)
```

### Keep rows 1 through to 4 and 7
	
```{r slice2, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> slice(c(1:4, 7))
```

:::

## Random selection of rows (`sample_n`) 

In each of the examples, I will set the random seed to ensure we can
all repeat the example exactly.

::: {.panel-tabset .tabset-left}

### Random sample of rows
Random sample of 10 rows (without replacement)	
```{r sample1, cache=FALSE, error = TRUE, warning = TRUE}
set.seed(123)
dat.1 |> sample_n(10, replace = FALSE)
```

### Random fractional sample of rows
Random sample of 25% of the rows (without replacement)	
```{r sample2, cache=FALSE, error = TRUE, warning = TRUE}
set.seed(123)
dat.1 |> sample_frac(0.25, replace = FALSE)
```

:::

## Effects of filtering on factor levels

In R, categorical variables (_factors_) are actually stored as vectors
of integers (1, 2, 3, ...) along with an attribute that registers the
names (and order) of the levels.  We can see this, if we ask to see
the _structure_ of any categorical variable:

```{r levels}
str(dat.1$Dose)
```

In the above, we see that the levels of the `Dose` variable are "H",
"L", "M" (by default, levels of an unordered factor are
alphabetical). The first four cases are all `1`, which is mapped to
"H".  The next four are `3` which maps to "M" and so on.

Alternatively, we can explore the levels _attribute_ of a factor via
the `levels()` _function_:

```{r levels1}
levels(dat.1$Dose)
levels(dat.1$Plot)
levels(dat.1$Treatment)
```

Although subsets of rows (`filter`, `sample_n` etc) may appear to
completely remove particular levels of a categorical variable, these
actions do not update factor attributes.  Consequently, many routines
that operate on such factors (such as plots and statistical models)
will proceed as if all factor levels are present (e.g. plots will
contain gaps where space has been provisioned for all levels even
though there may be no data associated with all levels).

To illustrate this, we will filter the `dat.1` data such that it only
includes cases for which `Plot` equals "P1" and then explore the
_levels_ attribute of some of the categorical variables.

```{r levels2}
dat.2 <- dat.1 |>
    filter(Plot == "P1")
dat.2
levels(dat.2$Dose)
levels(dat.2$Plot)
levels(dat.2$Treatment)
```

So although the data only contains `Plot` values of "P1" (and
`Treatment` values of "Control"), the levels are still listed as "P1",
"P2", "P3", and "P4".

To ensure that the attributes reflect the subset data, it is necessary
to use the `droplevels()` _function_:

```{r levels3}
dat.2 <- dat.1 |>
    filter(Plot == "P1") |>
    droplevels()
levels(dat.2$Dose)
levels(dat.2$Plot)
levels(dat.2$Treatment)
```

# Adding/modifying columns (`mutate`)

```{tikz}
%| label: tikz_mutate
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]


\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 1/.style={
            nodes={text width=2em,font=\bfseries}
        },
        column 2/.style={
            nodes={text width=2em}
        },
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}
\begin{tikzpicture}
\matrix (first) [table,text width=4em]{
&  &  & \\    
&  &  & \\    
&  &  & \\    
&  &  & \\    
&  &  & \\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
&  &  & & |[fill=blue!70]| \\    
&  &  & &\\    
&  &  &  &\\    
&  &  &  &\\    
&  &  &  & \\
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {mutate()} ++(second);
\node [Title,above=0.75cm of first.north,anchor=north] (Raw)  {Raw data};
\node [Title,above=0.75cm of second.north,anchor=north] (Mutated)  {Transformed data};
\end{tikzpicture}
```

To add to (mutate) a data set, a **vectorised** function is applied either
once or across one or more existing columns.  

The `mutate()` _function_ users [_data-masking_ semantics](#the-grammar-of-data-manipulation) and can use [_tidy-select_ semantics](#tidy-select-table) via `across()`.

Whether transforming/scaling existing variables or generating new
variables derived from existing variables it is advisable that
existing variables be retained (unless the data are huge and storage
is tight).

```{r mutate}
dat.1 |> mutate(Sum = Resp1 + Resp2) |>
    head()
```

Multiple additions/modifications can be defined in a single `mutate`
call and the changes occur sequentially.  Consequently, subsequent
changes can build upon early changes.  To illustrate this, we will
create a new variable (`cResp1`) that is a centred version of the
`Resp1` variable (centring is when the mean of a variable is
subtracted from each value resulting in a variable whose mean is
exactly zero, yet all other properties are unaffected.).

```{r mutate1}
dat.1 |> mutate(meanResp1 = mean(Resp1),
                 cResp1 = Resp1 - meanResp1) |>
    head()
```

The following table lists some of the more useful vectorised functions
to use with `mutate`.  Importantly, vectorised functions return a
vector of the same length as they receive since all `mutate` edits
must preserve the number of rows.

```{r dat1View, cache=FALSE, echo=FALSE}
```

## Mathematical functions

| Function                          | Description                                         |
|-----------------------------------|-----------------------------------------------------|
| `+,-,*,/,^,%/%, %%`               | typical arithmetic operators                        |
| `log()`,`log2()`,`log10()`, `exp()` | logarithms/exponentials                             |
| `<,<=,>,>=,!=,==`                 | logical operators                                   |
| `between()`                       | whether a case is between to numbers                |
| `near()`                          | a safe way of assessing equality in floating points |

: {.primary .bordered .sm .paramsTable}

::: {.panel-tabset .tabset-left}

### arithmetic operators
 	
```{r mutate2a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(Sum = Resp1 + Resp2,
                 Div = Resp1 / Resp2) |>
    head()
```

### logarithmic operators
	
```{r mutate2b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(logResp1 = log(Resp1),
                 expResp2 = exp(Resp2)) |>
    head()
```

### logical operators
	
```{r mutate2c, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(largeResp1 = Resp1 > 25) |>
    head()
```

### near
	
```{r mutate2d, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(
              A = Resp1 == 8.1,
              B = near(Resp1, 8.1, tol = 0.1)) |>
    head()
```

### between
	
```{r mutate2e, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(mediumResp1 = between(Resp1, 15, 25)) |>
    head()
```

:::

## Offset functions 

| Function                   | Description                                                      |
|----------------------------|------------------------------------------------------------------|
| `lag()`                    | shift cases down one                                             |
| `lead()`                   | shift cases up one                                               |

: {.primary .bordered .sm .paramsTable}

::: {.panel-tabset .tabset-left}

### lags
	
```{r mutate2, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(lagResp1 = lag(Resp1)) |>
    head()
```

### leads
	
```{r mutate3, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(leadResp1 = lead(Resp1)) |>
    tail()
```

:::

## Cumulative aggregate functions

| Function         | Description                                                      |
|------------------|------------------------------------------------------------------|
| `cummax()`       | cumulative maximum                                               |
| `cummin()`       | cumulative minimum                                               |
| `cummean()`      | cumulative mean                                                  |
| `cumprod()`      | cumulative product                                               |
| `cumsum()`       | cumulative sum                                                   |
| `rank()`         | rank of current case (ties averaged)                             |
| `min_rank()`     | rank of current case (minimum rank for ties)                     |
| `dense_rank()`   | rank of current case (minimum rank for ties, no gaps)            |
| `percent_rank()` | `min_rank` of current case (scaled to [0,1])                     |
| `cume_dist()`    | cumulative empirical distribution (prop. less than current rank) |
| `row_number()`   | rank of current case (first row for ties)                        |
| `ntile()`        | bin into (n) buckets                                             |

: {.primary .bordered .sm .paramsTable}

::: {.panel-tabset .tabset-left}

### cummmax/ cummin/ cummean

```{r mutate3a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(Cummin = cummin(Resp1),
                 Cummax = cummax(Resp1),
                 Cummean = cummean(Resp1)) |>
    head()
```

### cumsum/ cumprod

```{r mutate3b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(Cumsum = cumsum(Resp1),
                 Cumprod = cumprod(Resp1)) |>
    head()
```

### rank/ min_rank/ dense_rank/ percent_rank

```{r mutate3c, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(Rank = rank(Resp1),
                 minRank = min_rank(Resp1),
                 denseRank = dense_rank(Resp1),
                 percentRank = percent_rank(Resp1)) |>
    head()
```

### cumulative empirical distribution

```{r mutate3d, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(cume_dist(Resp1)) |>
    head()
```

### rank row number

```{r mutate3e, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(row_number(Resp1)) |>
    head()
```

### bin into buckets

```{r mutate3f, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(ntile(Resp1, 5)) |>
    head()
```

:::

## Miscellaneous 

| Function                   | Description                                                      |
|----------------------------|------------------------------------------------------------------|
| `if_else()`                | elementwise (case by case) if and else                           |
| `case_when()`              | elementwise multiple `if_else`                                   |
| `na_if()`                  | elementwise replace nominated value with `NA`                    |
| `pmax()`                   | elementwise maximum across multiple columns                      |
| `pmin()`                   | elementwise minimum across multiple columns                      |

: {.primary .bordered .sm .paramsTable}

::: {.panel-tabset .tabset-left}


### if_else

```{r mutate4a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(Size = if_else(Resp1 > 25, "Big", "Small")) |>
    head()
```

### case_when

```{r mutate4b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(Size = case_when(Resp1 < 15 ~ "Small",
                               Resp1 < 25 ~ "Medium",
                               Resp1 >= 25 ~ "Big")) |>
    head()
```

:::

## Summary functions

Summary functions (those that return a single value) are also
permissible - the value will be recycled for the total length of the
input vector.  A table of useful summary functions can be found in the
[Summarise section](#summarise).

```{r mutate5a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(meanResp1 = mean(Resp1)) |>
    head()
```

Another important summary function is the `n()` _function_.  This
function returns the total number of rows.  In the following example,
we will use it to create a column that just provides a running row
counter (e.g. a row index variable).

```{r mutate5b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(N = 1:n()) |>
    head()
```


## Multiple mutations (`across`)

In the [section on `select`](#subset-columns-select), a set of select
helper functions were described to facilitate convenient ways to
select columns based on properties of the column names etc.  The
`across()` _function_ allows us to bring those same selection helper
functions to mutate.

The `across()` _function_ has the following form:

```{r across, eval=FALSE}
across(.cols, .fns, .names)
```
where:

- `.cols` - a tidy selection (e.g. selection helper function)
- `.fns` - a function (or list of functions) to apply to each
  selected column
- `.names` - a `glue` specification determining the format of the new
  variable names.  By default the glue will be either `{.col}` (when
  there is only a single function) or `{.col}.{fn}` (when a list of
  functions)


::: {.panel-tabset .tabset-left}

### Simple selections

```{r across1, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(across(c(Resp1, Resp2), log)) |>
    head()
```

### Simple selections with naming

```{r across2, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(across(c(Resp1, Resp2),
                        .fns = log,
                        .names = "l{.col}")) |>
    head()
```

### `where` selections with naming

```{r across3, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(across(where(is.numeric),
                        .fns = log,
                        .names = "l{.col}")) |>
    head()
```

### `num_range` selections with naming

```{r across4, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(across(num_range("Resp", 1:2),
                        .fns = log,
                        .names = "l{.col}")) |>
    head()
```


### Multiple selections and functions

```{r across5, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(across(c(Resp1, Resp2),
                        .fns = list(l = log, s = sqrt),
                        .names = "{.fn}.{.col}")) |>
    head()
```

### Additional arguments to the function(s)

Centring all numeric variables (note the use of the `purrr` style
*lambda* formula for functions that require additional arguments.
When applying the function, the focal variable is assigned the name of
`.x`.

```{r across6, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(across(c(Resp1, Resp2),
                        .fns = list(c =  ~ scale(.x, scale = FALSE)),
                        .names = "{.fn}{.col}")) |>
    head()
```

:::


## Changing vectors

::: {.panel-tabset .tabset-left}

### Cast to different class
Convert `Time` (a numeric) into a factor
```{r mutate6a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(Time = factor(Time)) |>
    tibble()
```

### Change factor labels
Change the labels of the "H" and "M" levels of `Dose`
```{r mutate6b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> mutate(Dose = fct_recode(Dose, High = 'H',  Medium = 'M')) |>
    tibble()

dat.1 |> mutate(Dose = fct_recode(Dose, High = 'H',  Medium = 'M')) |>
    str()
```

### Change factor levels
Change the level order of the `Dose` factor to something more natural.
```{r mutate6c, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> pull(Dose)
dat.1 |>
    mutate(Dose = fct_relevel(Dose, c("L", "M", "H"))) |> 
    as_tibble() |>
    pull(Dose)
```

### Change factor levels and labels
Change the labels and level order of the `Dose` factor to something more natural.
```{r mutate6d, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> pull(Dose)
dat.1 |> mutate(
              Dose = fct_relevel(Dose, c("L", "M", "H")),
              Dose = fct_recode(Dose, High = 'H',  Medium = 'M')
              ) |>
    as_tibble |> 
    pull(Dose)
```

### Change factor levels to reflect data order
```{r mutate6e, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> pull(Dose)
dat.1 |> mutate(Dose = fct_reorder(Dose, 1:n())) |>
    as_tibble |> 
    pull(Dose)
```

### Change factor levels according to a numeric variable
Change the order of `Dose` levels according to the median `Resp1` values
```{r mutate6f, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> pull(Dose)
dat.1 |> mutate(Dose = fct_reorder(Dose, Resp1, median)) |>
    as_tibble |> 
    pull(Dose)
```

:::


# Summarising

```{tikz}
%| label: tikz_summarise
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 1/.style={
            nodes={text width=2em,font=\bfseries}
        },
        column 2/.style={
            nodes={text width=2em}
        },
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}
\begin{tikzpicture}
\matrix (first) [table,text width=4em]{
&  &   & \\    
&  &   & \\    
&  &   & \\    
&  &   & \\    
&  &   & \\    
};
 
\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!70]| & |[fill=blue!70]| &  |[fill=blue!70]| & |[fill=blue!70]| \\    
|[fill=blue!40]| & |[fill=blue!40]| & |[fill=blue!40]| & |[fill=blue!40]|\\ 
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {summarize()} ++(second);
\node [Title,above=0.75cm of first.north,anchor=north] (Raw)  {Raw data};
\node [Title,above=0.75cm of second.north,anchor=north] (Summarized)  {Summarized data};
\end{tikzpicture}
```

Data are often collected and transcribed at finer temporal/spatial
scales and with greater fidelity than is required for all
analyses. Furthermore, there is often a desire to present information
summarised to a courser level.  Therefore an important phase of data
preparation/presentation is also to summarise the data into the
spatial/temporal scales appropriate for the desired graphical and
statistical analyses.

Summarising involves applying one or more summarising functions to one
or more variables such that the data are reduced to a single row.

The `summarise()` _function_ users [_data-masking_ semantics](#the-grammar-of-data-manipulation) and can use [_tidy-select_ semantics](#tidy-select-table) via `across()`.

:::: {.columns style="display:flex;justify-content:space-evenly;"}

::: {.column style="width:45%;font-size:10pt;"}

```{r dat1View, cache=FALSE, echo=FALSE}
```

:::
 
::: {.column style="width:55%;font-size:12pt;"}

| Function                     | Description                                     |
|------------------------------|-------------------------------------------------|
| `n()`                        | number of rows/values                           |
| `n_distinct()`               | number of unique rows/values                    |
| `mean()`, `median()`         | mean/median                                     |
| `sum()`, `prod()`            | sum/product                                     |
| `var()`, `sd()`              | variance/standard deviation                     |
| `mad()`, `IQR()`             | median absolute deviation / interquartile range |
| `min()`, `max()`             | minimum / maximum                               |
| `quantile()`                 | nth quantile                                    |
| `first()`, `last()`, `nth()` | first / last / nth value                        |

: {.primary .bordered .sm .paramsTable}

:::

::::

::: {.panel-tabset .tabset-left}

### Count functions

Calculate the number of rows in the data as well as the number of
distinct (unique) values of `Dose`.

```{r summarise1a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> summarise(N = n(),
                    NDose = n_distinct(Dose))
```

### Simple math functions
	
Calculate the number of rows in the data as well as the number of
distinct (unique) values of `Dose`.

```{r summarise2a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> summarise(Mean = mean(Resp1),
                    Median = median(Resp1)) 
```

Calculate the number of rows in the data as well as the number of
distinct (unique) values of `Dose`.

```{r summarise2b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> summarise(Sum = sum(Resp1),
                    Prod = prod(Resp1)) 
```

Calculate the number of rows in the data as well as the number of
distinct (unique) values of `Dose`.

```{r summarise2c, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> summarise(Var = var(Resp1),
                    MAD = mad(Resp1)) 
```

Calculate the number of rows in the data as well as the number of
distinct (unique) values of `Dose`.

```{r summarise2d, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> summarise(Min = min(Resp1),
                    Max = max(Resp1)) 
```

### quantile functions

Calculate the number of rows in the data as well as the number of
distinct (unique) values of `Dose`.

```{r summarise2e, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> summarise(Q = t(quantile(Resp1)))
```

### first / last / nth functions

Calculate the number of rows in the data as well as the number of
distinct (unique) values of `Dose`.

```{r summarise2f, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> summarise(First = first(Resp1),
                    Last = last(Resp1),
                    Fifth = nth(Resp1, 5)) 
```

### `Across` functions

```{r summarise3a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> summarise(across(c(Resp1, Resp2),
                           list(Mean = mean, Var = var),
                           .names = "{.fn}.{.col}"),
                    N = n()) 
```

### Multiple variables / functions

```{r summarise3b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> summarise(across(where(is.numeric),
                           list(Mean = mean, Var = var),
                           .names = "{.fn}.{.col}"),
                    across(where(is.factor), n_distinct),
                    N = n())
```

```{r summarise3c, cache=FALSE, error = TRUE, warning = TRUE}
Var <- c("Resp1", "Resp2", "Resp3")
dat.1 |> summarise(across(any_of(Var),
                           list(Mean = mean, Var = var)))
```

:::

## Count

The `count()` _function_ provides a convenient way to count up the
number of unique combinations of factors.

::: {.panel-tabset .tabset-left}

### Count single factor

```{r count1, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> count(Dose)
```

### Count multiple factors

```{r count2, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> count(Dose, between(Resp1, 30, 50))
```

:::


# Grouping

```{tikz}
%| label: tikz_groupby
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]


\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 1/.style={
            nodes={text width=2em,font=\bfseries}
        },
        column 2/.style={
            nodes={text width=2em}
        },
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}
\begin{tikzpicture}
\matrix (first) [table,text width=4em]{
&  &   & \\    
|[fill=orange!10]| &  &   & \\    
|[fill=orange!30]| &  &   & \\    
|[fill=orange!50]| &  &   & \\    
|[fill=orange!70]| &   &   & \\    
};
 
\matrix (second) [above right=1cm and 5cm of first,anchor=north west,table,text width=4em]{
&  &   & \\    
|[fill=orange!10]| &  &   & \\    
|[fill=orange!30]| &  &   & \\    
};

\matrix (third) [below=1cm of second,anchor=north,table,text width=4em]{
&  &   & \\    
|[fill=orange!50]| &  &   & \\    
|[fill=orange!70]| &  &   & \\    
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {group\_by()} ++($(second.west|-first) +(-0.5cm, 0)$);
\node [Title,above=0.75cm of first.north,anchor=north] (Raw)  {Raw data};
\node [Title,above=0.75cm of second.north,anchor=north] (Grouped)  {Grouped data};
\end{tikzpicture}
```

Base R has a family of _apply_ functions that apply a function (such as
`mean()`) to a continuous variable separately for:

:::: {.columns style="display:flex;justify-content:space-evenly;"}

::: {.column style="width:45%;"}

Apply the `mean()` _function_ to each column (`MARGIN = 2`) of a
dataset comprising only of "Resp1" and "Resp2".

```{r apply1}
apply(dat.1[, c("Resp1", "Resp2")],
      MARGIN = 2,
      FUN = mean)
```

:::

::: {.column style="width:5%;"}

:::

::: {.column style="width:45%;"}

Apply the `mean()` _function_ to each level of the `Dose` _factor_.<br><br>

```{r apply2}
tapply(dat.1$Resp1,
       INDEX = dat.1$Dose,
       FUN = mean)
```

:::

::::

The above apply functions involve a sort of **split, apply, combine**
process. This process became the inspiration for the `plyr` package
(also out of the Wickham lab) which built on and super-charged the
process. The `dplyr` package represents the next iteration of the
process (for _data frames_ and _tibbles_ only as most data are in data
frame format).

Central to the modern split/apply/combine process is the idea of
**groups**. Groups are the basis of splitting the data. Functions applied
to grouped data are applied to each group (subset) separately before
the results are combined back into a single data frame (actually
tibble). Hence grouped data are most powerful when combined with the
`summarise()` or `mutate()` families of functions.

Groups are defined via the `group_by()` _function_.  For example, to
indicate that all subsequent manipulations should occur separately for
each level of the `Dose` variable, we would:

```{r groupby}
dat.1 |> group_by(Dose)
```

Note, in the above, we have only defined the grouping structure, not
any subsequent manipulations.  Consequently, the _tibble_ remains
unchanged.  Do note however, that above the tabular output, the output
specifies a `Group` _attribute_ as a visual reminder.

It is in combination with other data manipulation routines that
`group_by()` is most useful.  For example, to calculate the mean of
"Resp1" within each `Dose`:

```{r groupby2}
dat.1 |> group_by(Dose) |>
    summarise(Mean = mean(Resp1))
```

In the above output, you may have noticed that the data (means) have
been rounded.  This is a behaviour of the _print_ method for
_tibbles_.  When stored, the full precision of the data are retained.

Before providing a list of examples, it is worth using `group_by()` to
highlight the difference between `mutate()` and `summarise()`.

:::: {.columns style="display:flex;justify-content:space-evenly;"}

::: {.column style="width:55%;"}

```{r groupby3a}
dat.1 |> group_by(Dose) |>
    mutate(MeanResp1 = mean(Resp1)) |>
    head()
```

:::

::: {.column style="width:5%;"}

:::

::: {.column style="width:40%;"}

```{r groupby3b}
dat.1 |> group_by(Dose) |>
    summarise(Mean = mean(Resp1))
```

:::

::::

- `mutate()` maintains the number of rows.  Notice how the mean for
  each group is repeated for each case.
- `summarise()`reduces the number of rows to one (per group).
- `mutate()` retains all the columns
- `summarise()` only returns the columns specifically involved (either
  as the Groups or manipulated variables).

When multiple variables are used to define the groups, the subsequent
manipulations are applied to each unique combination of the factors.

```{r groupby4}
dat.1 |> group_by(Treatment, Dose) |>
    summarise(Mean = mean(Resp1))
```

Importantly, once all the manipulations that need to be performed
separately per group have been performed, it is good practice to
remove the group _attribute_.  Forgetting to do so will continue to
cause all subsequent manipulations (and possibly analyses and
graphics) to be inadvertently performed separately per group - such
downstream issues can be difficult to diagnose.

To remove the group _attribute_, we use the `ungroup()` _function_.

```{r groupby5}
dat.1 |> group_by(Treatment, Dose) |>
    summarise(Mean = mean(Resp1)) |>
    ungroup()
```

::: {.panel-tabset .tabset-left}

### Grouped summaries

```{r groupby6a, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> group_by(Treatment, Dose) |>
    summarise(meanResp1 = mean(Resp1),
              varResp1 = var(Resp1),
              N = n())
```

### Grouped summaries (with `across`)

```{r groupby6b, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> group_by(Treatment, Dose) |>
    summarise(across(starts_with("Resp"),
                     list(Mean = mean, Var = var),
                     .names = "{.fn}{.col}"),
              N = n())
```

### Grouped filter

```{r groupby6c, cache=FALSE, error = TRUE, warning = TRUE}
dat.1 |> group_by(Treatment, Dose) |>
    filter(Resp1 < 25)
```

:::


# Reshaping data

## Wide to long (`pivot_longer`)

Whilst wide data formats are often more compact and typically easier
to manage for data entry (particularly in the field), the data are not
in the appropriate format for most analyses (traditional repeated
measures and multivariate analyses are two exceptions). Most analyses
require that each replicate is in its own row and thus it is necessary
to be rearrange or reshape (melt) the data from this wide format to
the long (molten) format.

```{tikz}
%| label: tikz_pivot
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}
\begin{tikzpicture}
\matrix (first) [table,text width=4em]{
&|[fill=blue!40!black!40]|  & |[fill=blue!60!black!60]|  & |[fill=blue!80!black!80]|\\
&|[fill=blue!40!white!40]|  & |[fill=blue!60!white!60]|  & |[fill=blue!80!white!80]|\\ 
&|[fill=blue!40!white!40]|  & |[fill=blue!60!white!60]|  & |[fill=blue!80!white!80]|\\ 
&|[fill=blue!40!white!40]|  & |[fill=blue!60!white!60]|  & |[fill=blue!80!white!80]|\\     
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
& |[fill=black!60]|& |[fill=black!60]| \\
& |[fill=blue!40!black!40]|& |[fill=blue!40!white!40]|\\
& |[fill=blue!40!black!40]|& |[fill=blue!40!white!40]|\\
& |[fill=blue!60!black!60]|& |[fill=blue!60!white!60]|\\
& |[fill=blue!60!black!60]|& |[fill=blue!60!white!60]|\\
& |[fill=blue!80!black!80]|& |[fill=blue!80!white!80]|\\
& |[fill=blue!80!black!80]|& |[fill=blue!80!white!80]|\\
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {pivot\_longer()} ++(second);


\node [Title,above=0.75cm of first.north,anchor=north] (Wide)  {Wide data};
\node [Title,above=0.75cm of second.north,anchor=north] (Long)  {Long data};
\end{tikzpicture}
```

Whilst there are numerous routines in R for reshaping data, we will
only explore those that are formally part of the tidyverse ecosystem.

The `pivot_longer()` function (`tidyr` _package_) is very useful for
converting wide (repeated measures-like) into long format. The
important parameters to specify are:

```{r pivot_longer, eval=FALSE}
pivot_longer(data, cols, names_to, values_to, values_drop_na)
```
where:

- `data` - the input _dataframe_ or _tibble_
- `cols` - a tidy select specification of the columns to be lengthened
  into a single column
- `names_to` - a name (string) to give a new column into which to
  store the names of the old wide column names
- `values_to` - a name (string) to give the new column containing the
  values that were previously in the old columns.
- `values_drop_na` - whether or not to drop rows that only contain
  `NA` values in the new value column.
  
To illustrate, we will use the `dat.w` dataframe.

```{r datawView, cache=FALSE, echo=FALSE}
data.w |>
    knitr::kable(table.attr = "class=\"paperTable table-condensed\"", format='html',
                 caption="The `data.w` data.frame")
```

::: {.panel-tabset .tabset-left}

### Pivot longer

```{r pivot_longer2, cache=FALSE, error = TRUE, warning = TRUE}
data.w |> pivot_longer(Time.0:Time.2,
                        names_to = "Time",
                        values_to = "Count")
```

### Pivot longer (with `starts_with`)

```{r pivot_longer3, cache=FALSE, error = TRUE, warning = TRUE}
data.w |> pivot_longer(starts_with("Time"),
                        names_to = "Time",
                        names_prefix = "Time.",
                        values_to = "Count"
                        )
```

:::

## Long to wide (`pivot_wider`)

The opposite of making a data set longer is to make a data set wider.
Whilst analytical and graphical routines might require data to be in
long format, wide tabular summaries are typically more compact and
familiar.


```{tikz}
%| label: tikz_pivot2
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}
\begin{tikzpicture}
\matrix (first) [table,text width=4em]{
& |[fill=black!60]|& |[fill=black!60]| \\
& |[fill=blue!40!black!40]|& |[fill=blue!40!white!40]|\\
& |[fill=blue!40!black!40]|& |[fill=blue!40!white!40]|\\
& |[fill=blue!60!black!60]|& |[fill=blue!60!white!60]|\\
& |[fill=blue!60!black!60]|& |[fill=blue!60!white!60]|\\
& |[fill=blue!80!black!80]|& |[fill=blue!80!white!80]|\\
& |[fill=blue!80!black!80]|& |[fill=blue!80!white!80]|\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
&|[fill=blue!40!black!40]|  & |[fill=blue!60!black!60]|  & |[fill=blue!80!black!80]|\\
&|[fill=blue!40!white!40]|  & |[fill=blue!60!white!60]|  & |[fill=blue!80!white!80]|\\ 
&|[fill=blue!40!white!40]|  & |[fill=blue!60!white!60]|  & |[fill=blue!80!white!80]|\\ 
&|[fill=blue!40!white!40]|  & |[fill=blue!60!white!60]|  & |[fill=blue!80!white!80]|\\     
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {pivot\_wider()} ++(second);


\node [Title,above=0.75cm of first.north,anchor=north] (Long)  {Long data};
\node [Title,above=0.75cm of second.north,anchor=north] (Wide)  {Wide data};
\end{tikzpicture}
```

Widening is performed via the `pivot_wider()` _function_, the most
important parameters of which are:

```{r pivot_wider, eval=FALSE}
pivot_wider(data, id_cols, names_from, values_from
```

where:

- `data` - the input _dataframe_ or _tibble_
- `id_cols` - a tidy select specification of the columns that uniquely
  identify the case - these columns will not be widened.
- `names_from` - a tidy select specification of the column(s) that
  contain the names to be used as new column names.
- `values_from` - a tidy select specification of the column(s) that
  contain the values to be used as values in the new columns (e.g, the
  data to be widened).

To illustrate, we will use the `dat.w` dataframe.

```{r datalView, cache=FALSE, echo=FALSE}
data |>
    knitr::kable(table.attr = "class=\"paperTable table-condensed\"", format='html',
                 caption="The `data` data.frame")
```

Note, these data are not as long as they could be.  Purely "long" data
should have each observation in its own row.  The `data` dataframe has
two observations (one for "Resp1" and one for "Resp2") per row.

::: {.panel-tabset .tabset-left}

### Pivot wider for Resp1 only
Widen the "Resp1" variable by the levels of the `Between` factor.
```{r pivot_wider2, cache=FALSE, error = TRUE, warning = TRUE}
data |> select(-Resp2) |>
    pivot_wider(names_from = Within,
                values_from = c(Resp1))
```

### Pivot wider for Resp1 and Resp2
Widen the "Resp1" and "Resp2" variables by the levels of the `Between` factor.
```{r pivot_wider3, cache=FALSE, error = TRUE, warning = TRUE}
data |> pivot_wider(names_from = Within,
                values_from = starts_with("Resp"))
```
Alternatively we could make the data longer before widening
```{r pivot_wider4, cache=FALSE, error = TRUE, warning = TRUE}
data |>
    pivot_longer(cols = starts_with("Resp")) |>
    pivot_wider(names_from = c(name, Within),
                values_from = value)
```

:::

# Combining columns (`unite`)

If data are recorded with excessive fidelity, it may be useful to
combine multiple fields into a single field. For example, if the date
was recorded across three fields (year, month and day, we may like to
combine these to form a single date field.

```{tikz}
%| label: tikz_unite
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}

\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
&  & |[fill=blue!60!black!60]|& |[fill=blue!60!black!60]|& |[fill=blue!60!black!60]|\\
&  & |[fill=blue!60!white!60]|& |[fill=blue!60!white!60]|& |[fill=blue!60!white!60]|\\
&  & |[fill=blue!60!white!60]|& |[fill=blue!60!white!60]|& |[fill=blue!60!white!60]|\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
&  & |[fill=blue!60!black!60]|\\
&  & |[fill=blue!60!white!60]|\\
&  & |[fill=blue!60!white!60]|\\
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {unite()} ++(second);


\node [Title,above=0.75cm of first.north,anchor=north] (Raw)  {Raw data};
\node [Title,above=0.75cm of second.north,anchor=north] (United)  {United data};
\end{tikzpicture}
```

```{r datadView, cache=FALSE, echo=FALSE}
data.d |>
    knitr::kable(table.attr = "class=\"paperTable table-condensed\"", format='html',
                 caption="The `data.d` data.frame")
```

Lets take those data and combine (unite) the separate date components
into a single date column before coercing it into a `date` object.

```{r unite2, cache=FALSE, error = TRUE, warning = TRUE}
data.d |> unite(year,month,day,col='Date',sep='-') |>
    mutate(Date = as.Date(Date))
```


# Separating columns (`separate`)

Separating variables is the opposite of uniting them. A field is
separated by either indicating a character(s) to use as a separator,
or else providing a fixed width format.

```{tikz}
%| label: tikz_separate
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\bfseries
            }
        }
    }
}

\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
&  & |[fill=blue!60!black!60]|\\
&  & |[fill=blue!60!white!60]|\\
&  & |[fill=blue!60!white!60]|\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
&  & |[fill=blue!60!black!60]|& |[fill=blue!60!black!60]|& |[fill=blue!60!black!60]|\\
&  & |[fill=blue!60!white!60]|& |[fill=blue!60!white!60]|& |[fill=blue!60!white!60]|\\
&  & |[fill=blue!60!white!60]|& |[fill=blue!60!white!60]|& |[fill=blue!60!white!60]|\\
};

\draw[-latex,line width=8pt] (first) -- node[code,above,scale=2] {separate()} ++(second);


\node [Title,above=0.75cm of first.north,anchor=north] (Raw)  {Raw data};
\node [Title,above=0.75cm of second.north,anchor=north] (Separated)  {Separated data};
\end{tikzpicture}
```

```{r datacView, cache=FALSE, echo=FALSE}
data.c |>
    knitr::kable(table.attr = "class=\"paperTable table-condensed\"", format='html',
                 caption="The `data.c` data.frame")
```

For this example, we will split the `Year` column into two columns,
one that specifies the gender and one that specifies the age.  The
values are going to be separated after the first character.

```{r separate2, cache=FALSE, error = TRUE, warning = TRUE}
data.c |> separate(Year,
                    into = c("Gender", "Age"),
                    sep = 1)
```

# Merging (`_join`) data sets

It is common to have data associated with a particular study organised
into a number of separate data tables (databases etc). In fact, large
data sets are best managed in databases. However, statistical analyses
generally require all data to be encapsulated within a single data
structure. Therefore, prior to analysis, it is necessary to bring
together multiple sources.

This phase of data preparation can be one of the most difficult to get
right and verify that it is correct (particularly for large data
sets).

Merging (or joining) involves creating a new data set that comprises
information from two data sets. The resulting joined data set contains
all fields from both data sets. The data sets are alignd together
according to fields they have in common. Matching records in these
common fields are used to select a row from each input data set to be
combined.

There are numerous alternative ways of defining what should happen in
the event that common records do not occur in both sets. For example,
we could specify that only fully matching records be included in the
final data set. Alternatively, we could specify that all records be
included from both sets and thus the resulting data set will contain
missing values. The following describe these various options.

- left join
  - return all rows and columns from the left data set
  - return all columns from the right data set
  - new columns for unmatched rows from the right data sets receive NA
    values
  - when there are multiple matches, all combinations included

```{tikz}
%| label: tikz_leftjoin
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20,
            font=\ttfamily\bfseries
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\ttfamily\bfseries
            }
        }
    }
}

\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
x1&x2\\
A& 1\\
B& 2\\
C& 3\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!60!black!60]| x1 & |[fill=blue!60!black!60]| x3\\
|[fill=blue!60!white!60]| A& |[fill=blue!60!white!60]| T\\
|[fill=blue!60!white!60]| B& |[fill=blue!60!white!60]| F\\
|[fill=blue!60!white!60]| D& |[fill=blue!60!white!60]| T\\
};

\matrix (third) [right=5cm of second,anchor=west,table,text width=4em]{
x1 & x2 & |[fill=blue!60!black!60]| x3\\
A & 1 & |[fill=blue!60!white!60]| T\\
B & 2 & |[fill=blue!60!white!60]| F\\
C & 3 & |[fill=none]| NA\\
};

\draw [-latex,line width=8pt](second) -- (third);
\node at ($(first.east) !0.5! (second.west)$) [code,scale=2] (leftjoin) {left\_join()};

\node [Title,above=0.75cm of first.north,anchor=north] (A)  {Left dataset};
\node [Title,above=0.75cm of second.north,anchor=north] (B)  {Right dataset};
\end{tikzpicture}
```

- right join
  - return all rows and columns from the right data set
  - return all columns from the left data set
  - new columns for unmatched rows from the left data sets receive NA
    values
  - when there are multiple matches, all combinations included
  
```{tikz}
%| label: tikz_rightjoin
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20,
            font=\ttfamily\bfseries
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\ttfamily\bfseries
            }
        }
    }
}

\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
x1&x2\\
A& 1\\
B& 2\\
C& 3\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!60!black!60]| x1 & |[fill=blue!60!black!60]| x3\\
|[fill=blue!60!white!60]| A& |[fill=blue!60!white!60]| T\\
|[fill=blue!60!white!60]| B& |[fill=blue!60!white!60]| F\\
|[fill=blue!60!white!60]| D& |[fill=blue!60!white!60]| T\\
};

\matrix (third) [right=5cm of second,anchor=west,table,text width=4em]{
|[fill=blue!60!black!60]| x1 & |[fill=blue!60!black!60]| x3 &  x2\\
|[fill=blue!60!white!60]| A & |[fill=blue!60!white!60]| T &  1\\
|[fill=blue!60!white!60]| B & |[fill=blue!60!white!60]| F & 2\\
|[fill=blue!60!white!60]| D & |[fill=blue!60!white!60]| T & |[fill=none]| NA\\
};

\draw [-latex,line width=8pt](second) -- (third);
\node at ($(first.east) !0.5! (second.west)$) [code,scale=2] (rightjoin) {right\_join()};

\node [Title,above=0.75cm of first.north,anchor=north] (A)  {Left dataset};
\node [Title,above=0.75cm of second.north,anchor=north] (B)  {Right dataset};
\end{tikzpicture}
``` 

- inner join
  - return all columns from the left and right data set
  - return only rows that match from left and right data sets
  - when there are multiple matches, all combinations included

```{tikz}
%| label: tikz_innerjoin
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20,
            font=\ttfamily\bfseries
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\ttfamily\bfseries
            }
        }
    }
}

\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
x1&x2\\
A& 1\\
B& 2\\
C& 3\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!60!black!60]| x1 & |[fill=blue!60!black!60]| x3\\
|[fill=blue!60!white!60]| A& |[fill=blue!60!white!60]| T\\
|[fill=blue!60!white!60]| B& |[fill=blue!60!white!60]| F\\
|[fill=blue!60!white!60]| D& |[fill=blue!60!white!60]| T\\
};

\matrix (third) [right=5cm of second,anchor=west,table,text width=4em]{
x1 & x2 & |[fill=blue!60!black!60]| x3\\
A & 1 & |[fill=blue!60!white!60]| T\\
B & 2 & |[fill=blue!60!white!60]| F\\
};

\draw [-latex,line width=8pt](second) -- (third);
\node at ($(first.east) !0.5! (second.west)$) [code,scale=2] (innerjoin) {inner\_join()};

\node [Title,above=0.75cm of first.north,anchor=north] (A)  {Left dataset};
\node [Title,above=0.75cm of second.north,anchor=north] (B)  {Right dataset};
\end{tikzpicture}
```

- semi join
  - return all rows from the left data set that match with rows from
    the right data set
  - keep only the columns from the left data set

```{tikz}
%| label: tikz_semijoin
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20,
            font=\ttfamily\bfseries
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\ttfamily\bfseries
            }
        }
    }
}
\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
x1&x2\\
A& 1\\
B& 2\\
C& 3\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!60!black!60]| x1 & |[fill=blue!60!black!60]| x3\\
|[fill=blue!60!white!60]| A& |[fill=blue!60!white!60]| T\\
|[fill=blue!60!white!60]| B& |[fill=blue!60!white!60]| F\\
|[fill=blue!60!white!60]| D& |[fill=blue!60!white!60]| T\\
};

\matrix (third) [right=5cm of second,anchor=west,table,text width=4em]{
x1 & x2\\
A & 1\\
B & 2\\
};

\draw [-latex,line width=8pt](second) -- (third);
\node at ($(first.east) !0.5! (second.west)$) [code,scale=2] (semijoin) {semi\_join()};

\node [Title,above=0.75cm of first.north,anchor=north] (A)  {Left dataset};
\node [Title,above=0.75cm of second.north,anchor=north] (B)  {Right dataset};
\end{tikzpicture}
```

- anti join
  - return only the rows from the left data set that do not match with
    rows from the right data set
  - keep only the columns from the left data set

```{tikz}
%| label: tikz_antijoin
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20,
            font=\ttfamily\bfseries
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\ttfamily\bfseries
            }
        }
    }
}
\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
x1&x2\\
A& 1\\
B& 2\\
C& 3\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!60!black!60]| x1 & |[fill=blue!60!black!60]| x3\\
|[fill=blue!60!white!60]| A& |[fill=blue!60!white!60]| T\\
|[fill=blue!60!white!60]| B& |[fill=blue!60!white!60]| F\\
|[fill=blue!60!white!60]| D& |[fill=blue!60!white!60]| T\\
};

\matrix (third) [right=5cm of second,anchor=west,table,text width=4em]{
x1 & x2\\
C & 3\\
};

\draw [-latex,line width=8pt](second) -- (third);
\node at ($(first.east) !0.5! (second.west)$) [code,scale=2] (antijoin) {anti\_join()};

\node [Title,above=0.75cm of first.north,anchor=north] (A)  {Left dataset};
\node [Title,above=0.75cm of second.north,anchor=north] (B)  {Right dataset};
\end{tikzpicture}
```

- full join
  - return all rows and columns from the left and right data set
  - unmatched rows from either left data sets receive NA values in the
    associated new columns

```{tikz}
%| label: tikz_fulljoin
%| engine: tikz
%| echo: false
%| cache: true
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-standalone.tex"
\usetikzlibrary{shapes,arrows,shadows,positioning,mindmap,backgrounds,decorations, calc,fit, decorations.pathreplacing,decorations.pathmorphing, shadings,shapes.geometric, shapes.multipart,patterns}
\tikzstyle{Title} = [font={\fontspec[Scale=2]{ArchitectsDaughter-Regular}}]
\tikzstyle{code} = [font=\ttfamily]
\tikzstyle{Messy} = [decorate,decoration={random steps,segment length=3pt, amplitude=0.3pt},thick]

\tikzset{ 
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            rectangle,
            draw=white,
            align=center,
            fill=black!20,
            font=\ttfamily\bfseries
        },
        minimum height=1.5em,
        text depth=0.5ex,
        text height=2ex,
        nodes in empty cells,
%%
        %%every even row/.style={
        %%    nodes={fill=gray!30}
        %%},
        column 5/.style={
            nodes={
                text width=4em, 
                fill=blue!40
            }
        },
        row 1/.style={
            nodes={
                fill=black!40,
                text=white,
                font=\ttfamily\bfseries
            }
        }
    }
}

\begin{tikzpicture}

\matrix (first) [table,text width=4em]{
x1&x2\\
A& 1\\
B& 2\\
C& 3\\
};

\matrix (second) [right=5cm of first,anchor=west,table,text width=4em]{
|[fill=blue!60!black!60]| x1 & |[fill=blue!60!black!60]| x3\\
|[fill=blue!60!white!60]| A& |[fill=blue!60!white!60]| T\\
|[fill=blue!60!white!60]| B& |[fill=blue!60!white!60]| F\\
|[fill=blue!60!white!60]| D& |[fill=blue!60!white!60]| T\\
};

\matrix (third) [right=5cm of second,anchor=west,table,text width=4em]{
x1 & x2 & |[fill=blue!60!black!60]| x3\\
A & 1 & |[fill=blue!60!white!60]| T\\
B & 2 & |[fill=blue!60!white!60]| F\\
C & 3 & |[fill=none]| NA\\
D & |[fill=none]| NA & |[fill=blue!60!white!60]| T\\
};

\draw [-latex,line width=8pt](second) -- (third);
\node at ($(first.east) !0.5! (second.west)$) [code,scale=2] (fulljoin) {full\_join()};

\node [Title,above=0.75cm of first.north,anchor=north] (A)  {Left dataset};
\node [Title,above=0.75cm of second.north,anchor=north] (B)  {Right dataset};
\end{tikzpicture}
```

To illustrate the above, we will use the `data.bio` and `data.chem`
datasets.  The `data.bio` dataset mimics a typical ecological data set
in which there are a number of ecological responses (`Resp1` and
`Resp2`) along with the associated hierarchical design structure.
This data set is intentionally missing data for `Subplot` `S3`. The
`data.chem` dataset has the same hierarchical design structure, yet
records the two chemical analytes (`Chem1` and `Chem2`).  This data
set is intentionally missing data for `Subplot` `S7`.

:::: {.columns style="display:flex;justify-content:space-evenly;"}

::: {.column style="width:48%;"}

```{r join1a, echo=FALSE}
knitr::kable(data.bio, table.attr = "class=\"paperTable\"", format='html')
```

:::

::: {.column style="width:4%;"}

:::

::: {.column style="width:48%;"}

```{r join1b, echo=FALSE}
knitr::kable(data.chem, table.attr = "class=\"paperTable\"", format='html')
```

:::

::::

::: {.panel-tabset .tabset-left}

### Retain all data (`full_join`)
A full or _outer_ join between `data.bio` and `data.chem`
```{r full_join, cache=FALSE, error = TRUE, warning = TRUE}
data.bio |> full_join(data.chem)
```

Note that although all `Subplot`s are present, there are missing
values for `Subplot` `S3` (last row) and `S7`.

### Only retain full matches (`inner_join`)
An inner join between `data.bio` and `data.chem`
```{r inner_join, cache=FALSE, error = TRUE, warning = TRUE}
data.bio |> inner_join(data.chem)
```

Note that both `Subplot`s `S3` and `S7` are missing.

### Retain all left data at expense of right (`left_join`)
A left join between `data.bio` and `data.chem`
```{r left_join, cache=FALSE, error = TRUE, warning = TRUE}
data.bio |> left_join(data.chem)
```

Note that both `Subplot` `S3` are missing and `Subplot` `S7` only has
NA values for the chem data.

### Retain all right data at expense of left (`right_join`)
A left join between `data.bio` and `data.chem`
```{r right_join, cache=FALSE, error = TRUE, warning = TRUE}
data.bio |> right_join(data.chem)
```

Note that both `Subplot` `S7` are missing and `Subplot` `S3` only has
NA values for the bio data.

### Return the rows of left that are not matched in right (`anti_join`)
An anti join between `data.bio` and `data.chem`
```{r anti_join, cache=FALSE, error = TRUE, warning = TRUE}
data.bio |> anti_join(data.chem)
```

Note that `Subplot` `S7` is returned indicating that it in the right
dataset, yet absent from the left.

### Return the rows and columns of the left that are matched in the right (`anti_join`)
An semi join between `data.bio` and `data.chem`
```{r semi_join, cache=FALSE, error = TRUE, warning = TRUE}
data.bio |> semi_join(data.chem)
```

Note that `Subplot` `S3` and `S7` are missing and only the bio data
are included.

:::


## VLOOKUP in R

Lookup tables provide a way of inserting a column of data into a large
data set such that the entries in the new column are determined by a
relational match within another data set (the lookup table). For
example, the main data set might contain data collected from a number
of sites (Plots). Elsewhere we may have a data set that just contains
the set of sites and their corresponding latitudes and longitudes
(geographical lookup table). We could incorporate these latitudes and
longitudes into the main data set by merging against the geographical
lookup table. In Excel, this is referred to as vlookup, in a
relational database (and in `tidyverse`) it is referred to as a join.

If we again consider our `data.bio` data, but this time also consider
the `data.geo` data.  This later dataset contains the latitude and
longitude of each of the plots.

:::: {.columns style="display:flex;justify-content:space-evenly;"}

::: {.column style="width:48%"}

```{r join1a, echo=FALSE}
```

:::

::: {.column style="width:48%;"}

```{r vlookup1b, echo=FALSE}
knitr::kable(data.geo, table.attr = "class=\"paperTable\"", format='html')
```

:::

::::

::: {.panel-tabset .tabset-left}

### Keep all bio information (`left_join`)
```{r vlookup2, cache=FALSE, error = TRUE, warning = TRUE}
data.bio |> left_join(data.geo)
```
:::



