---
title: Containerisation - docker and singularity
author: "Murray Logan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-float: true
    page-layout: full
    number-sections: true
    number-depth: 3
    embed-resources: true
    code-fold: false
    code-tools: true
    code-summary: "Show the code"
    code-line-numbers: true
    code-block-border-left: "#ccc"
    code-copy: true
    highlight-style: atom-one
    theme: [default, ../resources/tut-style.scss]
    css: ../resources/tut-style.css
crossref:
  fig-title: '**Figure**'
  fig-labels: arabic
  tbl-title: '**Table**'
  tbl-labels: arabic
engine: knitr
bibliography: ../resources/references.bib
output_dir: "docs"
---

```{r setup, include=FALSE,warning=FALSE, cache=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning=FALSE, message=FALSE, cache = TRUE, comment = "")
options(tinytex.engine = 'xelatex')
cleanRmdInput <- function(x) {
#x <- gsub("```\\{r","```markdown\n`r ''```\\{r",x)
x <- gsub("^```$","`` `",x)  # the Makefile will then change this back to ``` after pandoc
x
}
library(tidyverse)
library(pander)
FIG_PATH <- '12_docker_files/figure-html/'

# save the built-in output hook
hook_output <- knitr::knit_hooks$get("output")

# set a new output hook to truncate text output
knitr::knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$out.lines)) {
    x <- xfun::split_lines(x)
    more <- "..."
    n <- eval(parse(text=n))
    if (length(n) == 1) {
      if (length(x) > n) {
        # truncate the output
        x <- c(head(x, n), "....\n")
        }
    } else {
        x <- c(more, x[n], more)
    }    
    x <- paste(x, collapse = "\n")
  }
  hook_output(x, options)
})
```

# Background information

In the previous tutorial, we discussed why it is important that your
codebase is under version control and backed up to help ensure that
your analyses can be evaluated and replicated by you and others both
now and into the future.  However, having access to the code (and
data) does not always guarantee full reproducibility - this can also
be effected by the exact software environment in which the code is
run.

In the context of statistical analyses performed in R for example, R
as well as the various packages that you have elected to use in
support your analyses can (and do) evolve over time.  Some functions
get modified and some even get depreciated.  Hence, over time, code
that once worked perfectly (or at least adequately) can become _broken_.

Early solutions to this facet of reproducibility focused on **virtual
machines**.  Virtual machines (VM) build entire software environments on
top of a software layer that mimics a physical computer such that each
VM runs on a _host_ computer is a completely separate self-contained
entity.  Whilst VMs do permit great flexibility (as virtually any
operating system can be installed on a VM), they are considerably
slower and less efficient than physical machines.  Moreover, it is
typically necessary to allocate a fixed amount of computer resources
(particularly CPU) to the VM in advance.

More modern solutions focus instead on **Containers**.  In contrast to
VMs, containers do not mimic a physical computer, rather they only
virtualise layers on top of the host operating system.  Indeed,
containers share (read only) the host OS kernel and binaries/libraries
and thus containers and the applications contained therein can be very
"light" and are typically are almost as performant as applications run
natively on the host.

Time for some container terminology:

- **Container image** is a static (unchangeable) file (or collection of
  files) that bundles code and all its dependencies (such as the
  necessary system libraries, code, runtime and system
  tools). Essentially, the image has all the information required to
  reproduce an software environment on any compatible machine.
  However, an image is just a snapshot which serves as a template to
  build a **container**. In other words, a container is a running image,
  and cannot exist without the image, whereas an image can exist
  without a container.

- **Container** is a standard (linux) process whose software environment
  is defined by the contents of a container image and that runs on top
  of the host's OS.

# Preparations

If you intend to follow along with this tutorial, you may like to:
 
- create a new folder (hereafter referred to as the _sandpit folder_)
  in which to create some files. On my local machine, I have a folder
  (`tmp`) in my home folder into which I will place a folder (called
  `docker_tests`) for this very purpose.  On Linux and MacOSX that
  would be achieved via the following:

  ```{r}
  #| label: prepareFolder1
  #| results: hide
  #| eval: true
  #| echo: false
  unlink('~/tmp/docker_tests', recursive=TRUE, force=TRUE)
  if (!dir.exists('~/tmp')) dir.create('~/tmp')
  ```
  ```{bash}
  #| label: prepareFolder
  #| echo: true
  #| eval: true
  #| classes: terminal
  #| class-source: terminal
  #| code-line-numbers: false
  #| highlight-style: zenburn
  mkdir ~/tmp/docker_tests
  ```
 </br>

- install [Docker](www.docker.com)

- install [apptainer/singularity](https://apptainer.org/) (if you
intend to follow along with containers on a HPC).

# Docker

Currently, the most popular container engine in use today is [Docker](www.docker.com).
Docker is easy to install on most operating systems and comes with
tools to build, manage, run and distribute container images (the later
of which is supported via the [DockerHub](https://hub.docker.com) container ecosystem.


```{tikz}
%| label: DockerOverviewFig1
%| engine: tikz
%| echo: false
%| cache: true
%| eval: false
%| dependson: common
%| class: tikz
%| engine-opts:
%|   template: "../resources/tikz-commit.tex"
\usetikzlibrary{positioning,shapes.callouts}
\tikzstyle{fileText} = [font={\fontspec[Scale=1]{InconsolataSemiCondensed-Regular}}] 
\newcommand{\file}[3] {
 \coordinate (#3) at (#1);
 \draw[thick,anchor=top left](#1) -- ++(2,0) -- ++(0.5,-0.5) -- ++(0,-3) -- ++(-2.5,0) -- ++(0,3.5);
 \draw[thick,anchor=top left]($(#1) +(2,0)$) -- ++(0,-0.5) -- ++(0.5,0); 	 
 \node [anchor=north west,fileText] at ($(#1) +(0,-0.1)$) {#2};
}

\usetikzlibrary{calc,fit,positioning}
\definecolor{OS}{rgb}{1,0.8,0.4}%
\definecolor{Docker}{rgb}{0.26,0.65,0.91}%
\definecolor{Bin}{rgb}{0.9,0.9,0.2}%
\definecolor{Container}{rgb}{0.90,0.9,0.9}%
\sf

\begin{tikzpicture}
\node [draw, anchor=south west,fill=Container] at (0,0) (Container1) {
 \begin{tikzpicture}
   \node [anchor=west] (title) at (0,0) {\textbf{Container 1}};
   \node [draw, anchor=west, fill=white] at ($(title.west) + (0,-1.5)$) (App) {
   \scalebox{0.5}{\begin{tikzpicture}
     \node (Code) {\huge Apps, Code etc};
     \commit{below = 1.5cm of Code}{A}{color_inactive}{}{}
     \commit{right = 1cm of A}{B}{color_inactive}{}{}
     \commit{right = 1cm of B}{C}{color_commit}{}{}
     \draw [-,line width=3pt,draw=black!60] (A) -- ++(-1,0);
     \draw [-,line width=3pt,draw=black!60] (B) -- (A);
     \draw [-,line width=3pt,draw=black!60] (C) -- (B);
     \commit{above = 0.5cm of B}{D}{color_inactive}{}{}
     \draw [-,line width=3pt,draw=black!60] (A.east) to[out=0,in=180] (D);
     \main{right = 0.5cm of C}\draw[->,line width=3pt,draw=black!60] (main) -- (C);
     \HEAD{right = 0.5cm of main}\draw[->,line width=3pt,draw=black!60] (HEAD) -- (main);
     \branch{right = 0.5cm of D}{Feature}\draw[->,line width=3pt,draw=black!60] (Feature) -- (D);
     \end{tikzpicture}}};
     \node [draw,anchor=north,inner sep=0pt, fit=(App.south west)(App.south east), fill=Bin, minimum height = 1.75em, label={center:Bins/libs}] {};
 \end{tikzpicture}
};
\node [draw, anchor=south west,fill=Container] at ($(Container1.south east) + (0.2,0)$) (Container2) {
 \begin{tikzpicture}
   \node [anchor=west] (title) at (0,0) {\textbf{Container 2}};
   \node [draw, anchor=west, fill=white,minimum width=4cm] at ($(title.west) + (0,-1)$) (App) {Apps, Code etc};
   \node [draw, anchor=north west, fill=Bin, minimum width=4cm] at ($(App.south west) + (0,-0)$) {Bins/libs};
 \end{tikzpicture}
};

\node [draw,fit=(Container1.south west)(Container2.south east), anchor=north,inner sep=0pt,fill=Docker, minimum height=2em, label={center:Docker Engine}] (Docker)  {};
\node [draw,fit=(Docker.south west)(Docker.south east), anchor=north,inner sep=0pt,fill=OS, minimum height=2em, label={center:Host OS}] (OS)  {};
\end{tikzpicture}
```

## Simple overview

1. **Create a Docker definition file.**

   The `Dockerfile` contains a set of instructions that Docker uses to
   build your container with the correct specifications. For now you
   do not need to know all the bits and pieces here (though please see
   this
   [link](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
   for a more in-depth understanding of what the Dockerfile is capable
   of).

   Lets start with a very simple `Dockerfile` (which should be a plain
   text file located in the root of a project directory).  This first
   example will be a very minimal example and much of the rest of the
   Docker section of this tutorial will then progressively build on
   this example to introduce more and more complexity.
   
   The image we will build will start with a very minimal Debian Linux
   base called [minidep](https://hub.docker.com/r/bitnami/minideb)
   sourced from Dockerhub.  This provides a fully functioning Linux
   operating system complete with the typical terminal power tools.
   
   To then extend the image by updating the package lists (location of
   repositories) before adding (installing) a small fun terminal
   application
   ([cowsay](https://github.com/tnalpgge/rank-amateur-cowsay)) that
   generates ASCII art of a cow (or other animals) along with a speech
   bubble. 

   ```{bash}
   #| label: createDockerfile
   #| echo: false
   #| eval: true
   #| cache: false
   #| engine: bash
   cd ~/tmp/docker_tests
   echo 'FROM bitnami/minideb:bookworm' > Dockerfile
   echo 'LABEL maintainer="Author"' >> Dockerfile
   echo 'LABEL email="author_email@email.com"' >> Dockerfile
   echo '' >> Dockerfile
   echo '## Install the os packages' >> Dockerfile
   echo 'RUN apt-get update \' >> Dockerfile
   echo '  && apt-get install -y --no-install-recommends \' >> Dockerfile
   echo '    cowsay \' >> Dockerfile
   echo '  && rm -rf /var/lib/apt/lists/*' >> Dockerfile
   ```

   ```{r}
   #| label: Text
   #| cache: false
   #| eval: true
   list.files()
   list.files("~")
   list.files("~/tmp")
   list.files("~/tmp/docker_tests")
   ```

   In the above `Dockerfile`:

   - the three first rows in contain information on the base image on
     which to construct your docker container image (in this case
     bitnami/minideb:stretch container freely provided by the bitnami
     team), as well as information about yourself. `minideb` is a
     minimal debian operating system.

   - the **FROM** command points to a parent image.  Typically, this
     will point to a specific image within a registry on Docker hub.
     This generates the base layer of the container image.

   - the **LABEL** command is one of numerous _environmental
     variables_ and is used to add metadata to an image.  In this
     case, there are two entries to specify information about the
     maintainer and their contact details.  Note, entries must be
     key-value pairs and values must be enclosed in double quotes.

   - the **RUN** command runs shell commands in a new layer on top of
     the current image and commits the result.  Each RUN generates a
     new layer.  The above example, first updates the packages list 
     and then installs an additional package (`cowsay`).



::: {.raw} 
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script type='text/javascript'>
$(document).ready(function () {
$('div.terminal').prepend("<div class='head'><a href='#' class='mbtn'>&#10005;</a><a href='#' class='mbtn stnd'>&#9472;</a><a href='#' class='mbtn stnd max'>&#9723;</a><span>murray@arch:~</span></div>");
$('div.terminal-docker').prepend("<div class='head'><a href='#' class='mbtn'>&#10005;</a><a href='#' class='mbtn stnd'>&#9472;</a><a href='#' class='mbtn stnd max'>&#9723;</a><span>#</span></div>");
});
</script>

:::
