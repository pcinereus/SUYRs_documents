{
  "hash": "4ba3af88ba3ec966e36e85ccc44c6a0a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Introduction to R \nauthor: \"Murray Logan\"\ndate: \"15 July, 2024\"\nformat: \n  html:\n    toc: true\n    toc-float: true\n    page-layout: full\n    number-sections: true\n    number-depth: 3\n    embed-resources: true\n    code-fold: false\n    code-tools: true\n    code-summary: \"Show the code\"\n    code-line-numbers: true\n    code-block-border-left: \"#ccc\"\n    code-copy: true\n    highlight-style: atom-one\n    theme: [default, ../resources/tut-style.scss]\n    css: ../resources/tut-style.css\ncrossref:\n  fig-title: '**Figure**'\n  fig-labels: arabic\n  tbl-title: '**Table**'\n  tbl-labels: arabic\nengine: knitr\nbibliography: ../resources/references.bib\noutput_dir: \"docs\"\n---\n\n\n\n\n# Installing R\n\nThe latest version of an R installation binary (or source code) can be\ndownloaded from one of the [Comprehensive R Archive Network (or CRAN)\nmirrors](https://cran.r-project.org/mirrors.html). Having selected one\nof the (Australian) mirrors, follow one of the sets of instructions\nbelow (depending on your operating system).\n\n::: panel-tabset \n\n## Windows\n\n- **Download R:** \n  - Go to the CRAN R-project website <https://cran.r-project.org/> and\n  click on \"Download R for Windows\".\n  - Select the \"base\" subdirectory\n  - Select the \"Download R-X.X.X for Windows\" option (where X.X.X are\n  a series of version and release numbers) to download.\n\n- **Run the installer:** Double-click the downloaded .exe file and\n  follow the installation wizard. Accept the default settings unless\n  you have specific needs.\n\n- **Optional:** Set R as the default: Check the checkbox to set R as\n  the default for R scripts during installation. This allows you to\n  run R scripts by double-clicking them.\n\n- **Verify installation:** \n  - Open a new command prompt (Start > Run > cmd) and type `R`. If the R\n  console opens, the installation was successful.\n  - Alternatively, search for R in the Start menu\n\n## MacOSx\n\n- **Download R:** \n  - Go to the CRAN R-project website (https://cran.r-project.org/) and\n    click on \"Download R for macOS\".\n  - Choose the latest stable version that is appropriate for your\n    architecture.\n- **Open the disk image:** Double-click the downloaded .pkg file and\n  drag the R application icon to your Applications folder.\n  \n- **Verify installation:**\n  - Open Terminal: Go to Applications > Utilities and open Terminal.\n  - Type `R` in the Terminal window. If the R console opens, the\n  installation was successful.\n\n## Linux\n\n- **Open Terminal:** You can access Terminal through your application\n  launcher or search bar.\n\n- **Install R:** The commands vary slightly depending on your Linux distribution. Here are common examples:\n  - Debian/Ubuntu: `sudo apt install r-base`\n  - Fedora/CentOS: `sudo yum install R`\n  - Arch Linux: `sudo pacman -S R`\n\n- **Verify installation:** Type `R` in the Terminal window. If the R\n  console opens, the installation was successful.\n\n:::\n\n# Basic Syntax\n\n## The R environment and command line\n\nUpon opening R, you are presented with the R Console along with the\ncommand prompt (`>`). R is a command driven application (as opposed to\na 'point-and-click' application) and despite the steep learning curve,\nthere are many very good reasons for this.\n\nCommands that you type are evaluated once the Enter key has been\npressed\n\nEnter the following command (`5+1`) at the command prompt (`>`);\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5+1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\n:::{.callout-note}\n\nI have suppressed the command prompt (`<`) from almost all code blocks\nthroughout these workshop and tutorial series to make it easier for\nyou to cut and paste code into your own scripts or directly into R.\n\n:::\n\n:::{.callout-tip}\n\nIn this tutorial series, the R code to be entered appears to the right\nhand side of the vertical bar. The number of the left side of the bar\nis a line number. For single line code snippets, such as the example\nabove, line numbers are not necessary. However, for multi-line code\nsnippets, line numbers help for identifying and describing different\nparts of the code.\n\n:::\n\nThe above R code evaluates the command five plus one and returns the\nresult (six).. The [1] before the 6 indicates that the object\nimmediately to its right is the first element in the returned object.\nIn this case there is only one object returned. However, when a large\nset of objects (e.g. numbers) are returned, each row will start with\nan index number thereby making it easier to count through the\nelements.\n\n::: {.callout-note collapse=\"true\"}\n### Important definitions\n\nObject\n  : As an object oriented language, everything in R is an object.\n    Data, functions even output are objects.\n\nVector\n  : A collection of one or more objects of the same type (e.g. all\n    numbers or all characters).\n\nFunction\n  : A set of instructions carried out on one or more objects.\n    Functions are typically wrappers for a sequence of instructions\n    that perform specific and common tasks.\n\nParameter\n  : The kind of information passed to a function.\n\nArgument\n  : The specific information passed to a function.\n\nOperator\n  : A symbol that has a pre-defined meaning. Familiar operators\n    include `+` `-` `*` and `/`.\n\nAssignment operators\n  : `<-` Assigning a name to an object (left to right)\n  : `->` Assigning a name to an object (right to left)\n  : `=` Used when defining and specifying function arguments\n\nLogical operators (return `TRUE` or `FALSE`)\n  : `<` Less than\n  : `>` Greater than\n  : `<=` Less than or equal\n  : `>=` Greater than or equal\n  : `==` Is the left hand side equal to the right hand side (a query)\n  : `!=` Is the left hand side NOT equal to the right hand side (a query)\n  : `&&` Are BOTH left hand and right hand conditions TRUE\n  : `||` Are EITHER the left hand OR right hand conditions TRUE\n\nPipe operator\n  : `|>` piping the output of one operation to the input of the next\n:::\n\n### Expressions, Assignment and Arithmetic\n\nInstead of evaluating a statement and printing the result directly to\nthe console, the results of evaluations can be stored in an object via\na process called 'Assignment'. Assignment assigns a name to an object\nand stores the result of an evaluation in that object. The contents of\nan object can be viewed (printed) by typing the name of the object at\nthe command prompt and hitting `Enter`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar1 <- 2 + 3\nvar1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\nOn line 1 above, the name `var1` was assigned to the result of the sum\nof 2 and 3. On line 2, the contents of this object are printed to the\nscreen.\n\nA single command (statement) can spread over multiple lines. If the\nEnter key is pressed before R considers the statement complete, the\nnext line in the console will begin with the prompt `+` indicating\nthat the statement is not complete. For this example, I will include\nthe command prompt in order to demonstrate the above point.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> var2 <-\n+   2 + 3\n> var2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\nWhen the contents of an object are numbers, standard arithmetic applies;\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar2 - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nans1 <- var1 * var2\nans1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip}\nGenerally, spaces are ignored in R. Hence, the above and the following\nare both equally valid.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nans1<-var1*var2\nans1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\nNevertheless, the former version (with spaces) is much more readable.\n\n:::\n\nCompatible objects can be concatenated (joined together) to create\nobjects with multiple entries. Object concatenation can be performed\nusing the `c()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 6\n```\n\n\n:::\n\n```{.r .cell-code}\nc(var1, var2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 5\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note}\nIn both examples above, objects were not assigned names. As a result,\nthe expressions were evaluated and directly printed to the consol\nwithout being stored in any way. Doing so is useful for experimenting,\nhowever as the results are not stored, they cannot be used in\nsubsequent actions.\n:::\n\nIn addition to the typical addition, subtraction, multiplication and\ndivision operators, there are a number of special operators, the\nsimplest of which are the quotient or integer divide operator (`%/%`)\nand the remainder or modulus operator (`%%`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n7 / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.333333\n```\n\n\n:::\n\n```{.r .cell-code}\n7 %/% 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n7 %% 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n### Operator precedence\n\nThe rules of operator precedence are listed (highest to lowest) in the\nfollowing table. Additionally, expressions within parentheses '`()`'\nalways have highest precedence.\n\n\n| Operator                    | Description                                         |\n|-----------------------------|-----------------------------------------------------|\n| `[` `[[`                    | indexing                                            |\n| `::`                        | namespace                                           |\n| `$`                         | component                                           |\n| `^`                         | exponentiation (evaluated right to left)            |\n| `-`                         | +\tsign (unary)                                   |\n| `:`                         | sequence                                            |\n| `%special%`                 | special operators (e.g. `%/%`, `%%`, `%*%`, `%in%`) |\n| `*` `/`                     | multiplication and division                         |\n| `+`                         | -\taddition and subtraction                       |\n| `>` `<` `>=` `<=` `==` `!=` | ordering and comparison                             |\n| `!`                         | logical negation (not)                              |\n| `&` `&&`                    | logical AND                                         |\n| `|` `||`                    | logical OR                                          |\n| `~`                         | formula                                             |\n| `->` `->>`                  | assignment (left to right)                          |\n| `=`                         | argument assignment (right to left)                 |\n| `<-` `<<-`                  | assignment (right to left)                          |\n| `?`                         | help                                                |\n\n: {.primary .bordered .sm .paramsTable}\n\n### Command history\n\nEach time a command is entered at the R command prompt, the command is\nalso added to a list known as the command history. The up and down\narrow keys scroll backward and forward respectively through the\nsession's command history list and place the top most command at the\ncurrent R command prompt. Scrolling through the command history\nenables previous commands to be rapidly re-executed, reviewed or\nmodified and executed.\n\n### Object names\n\nEverything created within R are objects. Objects are programming\nconstructs that not only store values (the visible part of an object),\nthey also define other properties of the object (such as the type of\ninformation contained in the object) and sometimes they also define\ncertain routines that can be used to store, retrieve and manipulate\ndata within the object.\n\nImportantly, all objects within R must have unique names to which they\ncan be referred. Names given to any object in R can comprise virtually\nany sequence of letters and numbers providing that the following rules\nare adhered to:\n\n- Names must begin with a letter (names beginning with numbers or\n  operators are not permitted)\n- Names cannot contain the following characters; space `,` `-` `+` `*`\n  `/` `#` `%` `&` `[` `]` `{` `}` `(` `)` `~`\n\nWhilst the above rules are necessary, the following naming conventions\nare also recommended:\n\n- only use lowercase letters and numbers\n- use underscores (`_`) to separate words (e.g. _snake case_)\n- try to use names that are both concise and meaningful. \n  - names should reflect the content of the object. One of the\n    powerful features of R is that there is virtually no limit to the\n    number of objects (variables, datasets, results, models, etc) that\n    can be in use at a time. However, without careful name management,\n    objects can rapidly become misplaced or ambiguous. Therefore, the\n    name of an object should reflect what it is, and what has happened\n    to it. For example, the name `log_fish_wts` might be given to an\n    object that contains log transformed fish weights. Moreover, many\n    prefer to prefix the object name with a lowercase letter that\n    denotes the type of data containing in the object. For example,\n    `d_mean_head_length` might indicate that the object contains the\n    mean head lengths stored as a double floating point (real\n    numbers).\n  - although there are no restrictions on the length of names, shorter\n    names are quicker to type and provide less scope for typographical\n    errors and are therefore recommended (of course within the\n    restrictions of the point above). \n- where possible, avoid using names of common predefined functions and\n  variables as this can provide a source of confusion for both you and\n  R. For example, to represent the mean of a head length variable, use\n  something like `mean_head_length` rather than `mean` (which is the\n  name of a predefined function within R that calculates the mean of a\n  set of numbers).\n\n## R Sessions and Workspaces\n\nA number of objects have been created in the current session (a\nsession encapsulates all the activity since the current instance of\nthe R application was started). To review the names of all of the\nobjects in the users current workspace (storage of user created\nobjects);\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ans1\" \"var1\" \"var2\"\n```\n\n\n:::\n:::\n\n\n\nYou can also refine the scope of the `ls()` function to search for\nobject names that match a pattern:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls(pat = \"var\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"var1\" \"var2\"\n```\n\n\n:::\n\n```{.r .cell-code}\nls(pat = \"a*1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ans1\" \"var1\"\n```\n\n\n:::\n:::\n\n\n\nThe longer the session is running, the more objects will be created\nresulting in a very cluttered workspace. Unneeded objects can be\nremoved using the `rm()` function. The `rm()` function only performs a\n_side effect_ (deletes objects), if the function succeeds, it does not\nreturn any output. If it does return anything, it will be a warning or\nerror.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(var1, var2)   #remove the VAR1 and VAR2 objects\nrm(list = ls())  #remove all user defined objects\n```\n:::\n\n\n\n::: {.callout-note}\nIn the above examples, comments were appended to each line of code.\nComments begin with a hash (`#`) character. Anything that follows a\nhash character will be ignored (until the end of the line).\n\nComments provide a convenient way to annotate your code so as to\nprovide more explanation and clarity as to the intention and purpose\nof the associated code.\n:::\n\n### Current working directory\n\nThe R working directory (location from which files/data are read and\nwritten) is by default, either the location of the R executable (or\nexecution path in Linux) or the users _home_ directory. The current\nworking directory can be reviewed and changed (for the session) using\nthe `getwd()` function and `setwd()` functions respectively. Note that\nR uses the Unix/Linux style directory subdivision markers. That is, R\nuses the forward slash `/` in path names rather than the regular `\\`\nof Windows.\n\nWhen using `setwd()`, you can provide either an absolute path (the\nfull path) or a relative path (relative to the current location).\nObviously, you will get a different result to me when you issue the\nfollowing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()                    #review the current working directory\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/runner/work/SUYRs_documents/SUYRs_documents/tut\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsetwd(\"../\")               #change to the parent directory of the current working directory\nlist.files(path = getwd()) #list all files (and directories) in the current working directory\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data\"      \"docs\"      \"Makefile\"  \"resources\" \"tut\"      \n```\n\n\n:::\n:::\n\n\n\n\n### Workspaces\n\nThroughout an R session, all objects (including loaded packages, see\n@sec-packages) that have been added are stored within the R global\nenvironment, called the workspace. Occasionally, it is desirable to\nsave the workspace and thus all those objects (vectors, functions,\netc) that were in use during a session so that they are available\nduring subsequent sessions. This can be done using the `save.image()`\nfunction. Note, this will save the workspace to a file called `.RData`\nin the current working directory (usually the R startup directory),\nunless a `file` (filename and path) is supplied as an argument to the\n`save.image()` function. A previously saved workspace can be loaded by\nproviding a full path and filename as an argument to the `load()`\nfunction.\n\nWhilst saving a workspace image can sometimes be convenient, it can\nalso contribute greatly to organisational problems associated with\nlarge numbers of obsolete or undocumented objects. Instead, it is\nusually better to specifically store each of the objects you know you\nare going to want to have access to across sessions separately.\n\n### Quitting elegantly\n\nTo quit R, issue the following command; Note in Windows and MacOSX,\nthe application can also be terminated using the standard Exiting\nprotocols.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq()\n```\n:::\n\n\n\nYou will then be asked whether or not you wish to save the current\nworkspace. If you do, enter 'Y' otherwise enter 'N'. **Unless you have\na very good reason to save the workspace, I would suggest that you do\nnot**. A workspace generated in a typical session will have numerous\npoorly named objects (objects created to temporarily store information\nwhilst testing). Next time R starts, it could (likely will) restore\nthis workspace thereby starting with a cluttered workspace, and\nbecoming a potential source of confusion if you inadvertently refer to\nan object stored during a previous session. Moreover, if the workspace\nincludes additional extension packages, these packages may also be\nloaded which will prevent them from being updated (often necessary\nwhen installing additional packages that depend on other packages).\n\n## Functions\n\nAs wrappers for collections of commands used together to perform a\ntask, _functions_ provide a convenient way of interacting with all of\nthese commands in sequence. Most functions require one or more inputs\n(_parameters_), and while a particular function can have multiple\nparameters, not all are necessarily required (some could have default\nvalues). Parameters are parsed to a function as _arguments_ comprising\nthe name of the parameter, an equals operator and the value of the\nparameter. Hence, arguments are specified as name/value pairs.\n\nConsider the `seq()` function, which generates a sequence of values (a\nvector) according to the values of the arguments. We can see that the\ndefault version of this function has the following definition:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(seq.default)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (from = 1, to = 1, by = ((to - from)/(length.out - 1)), length.out = NULL, \n    along.with = NULL, ...)  \n```\n\n\n:::\n:::\n\n\n\n- if the `seq()` function is called without any arguments (e.g.\n  `seq()`), it will return a single number 1. Using the default\n  arguments for the function, it returns a vector starting at 1 (`from\n  = 1`), going up to 1 (`to = 1`) and thus having a length of 1.\n\n- we can alter this behavior by specifically providing values for the\n  named arguments. The following generates a sequence of numbers from\n  2 to 10 incrementing by 1 (default):\n  \n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  seq(from = 2, to = 10)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1]  2  3  4  5  6  7  8  9 10\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- the following generates a sequence of numbers from 2 to 10 incrementing by 2:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  seq(from = 2, to = 10, by = 2)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1]  2  4  6  8 10\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- alternatively, instead of manipulating the increment space of the\n  sequence, we could specify the desired length of the sequence:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  seq(from = 2, to = 10, length.out = 3)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1]  2  6 10\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- named arguments need not include the full name of the parameter, so\n  long as it is unambiguous which parameter is being referred to. For\n  example, length.out could be shortened to just l since there are no\n  other parameters of this function that start with 'l':\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  seq(from = 2, to = 10, l = 4)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1]  2.000000  4.666667  7.333333 10.000000\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- parameters can also be specified as unnamed arguments provided they\n  are in the order specified in the function definition. For example\n  to generate a sequence of numbers from 2 to 10 incrementing by 2:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  seq(2, 10, 2)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1]  2  4  6  8 10\n  ```\n  \n  \n  :::\n  :::\n\n\n\n  Note, although permittable, it is more difficult to unambiguously\n  read/interpret the code and could easily be a source of bugs.\n  \n- named and unnamed arguments can be mixed, just remember the above\n  rules about parameter order and unambiguous names:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  seq(2, 10, l = 4)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1]  2.000000  4.666667  7.333333 10.000000\n  ```\n  \n  \n  :::\n  :::\n\n\n\n## Function overloading (polymorphism)\n\nMany routines can be applied to different sorts of data. That is, they\nare somewhat generic. For example, we could calculate the mean\n(arithmetic center) of a set of numbers or we could calculate the mean\nof a set of dates or times. Whilst the calculations in both cases are\nanalogous to one another, they nevertheless differ sufficiently so as\nto warrant separate functions.\n\nWe could name the functions that calculate the mean of a set of\nnumbers and the mean of a set of dates as `mean_numbers` and\n`mean_dates` respectively. Unfortunately, as this is a relatively\ncommon situation, the number of functions to learn rapidly expands.\nAnd from the perspective of writing a function that itself contains\nsuch a generic function, we would have to write multiple instances of\nthe function in order to handle all the types of data we might want to\naccommodate.\n\nTo simplify the process of applying these generic functions, R\nprovides yet another layer that is responsible for determining which\nof a series of overloaded functions is likely to be applicable\naccording to the nature of the parameters and data parsed as arguments\nto the function. To see this in action, type `mean` followed by hitting\nthe `TAB` key. The `TAB` key is used for auto-completion and therefore\nthis procedure lists all the objects that begin with the letters\n'mean'.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean           mean.Date      mean.default   mean.difftime  mean.POSIXct   mean.POSIXlt\n```\n:::\n\n\n\nIn addition to an object called `mean`, there are additional objects\nthat are suffixed as a '.' followed by a data type. In this case, the\nobjects `mean.default`, `mean.Date`, `mean.POSIXct`, `mean.POSIXlt`\nand `mean.difftime` are functions that respectively\ncalculate the mean of a set of numbers, dates, times, times, time and\ndifferences. The `mean` function determines which\nof the other functions is appropriate for the data parsed and then\nredirects to that appropriate function. Typically, this means that it\nis only necessary to remember the one generic function (in this case,\n`mean()`) as the specific functions are abstracted away.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mean of a series of numbers\nmean(c(1, 2, 3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# create a sequence of dates spaced 7 days apart between 29th Feb 2000 and 30th Apr 2000\nsample_dates <- seq(from = as.Date(\"2000-02-29\"), to = as.Date(\"2000-04-30\"), by = \"7 days\")\n# print (view) these dates\nsample_dates\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-02-29\" \"2000-03-07\" \"2000-03-14\" \"2000-03-21\" \"2000-03-28\"\n[6] \"2000-04-04\" \"2000-04-11\" \"2000-04-18\" \"2000-04-25\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# calculate the mean of these dates\nmean(sample_dates)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-03-28\"\n```\n\n\n:::\n:::\n\n\n\nIn the above examples, we called the same function (mean) on both\noccasions. In the first instance, it was equivalent to calling the\n`mean.default()` function and in the second instance the `mean.Date()`\nfunction. Note that the `seq()` function is similarly overloaded.\n\nThe above example also illustrates another important behaviour of\nfunction arguments. Function calls can be nested within the arguments\nof other functions and function arguments are evaluated before the\nfunction runs. In this way, multiple steps to be truncated together\n(although for the sake of the codes' readability and debugging, it is\noften better to break a problem up into smaller steps). \n\nIf a function argument itself contains a function (as was the case\nabove with the `from =` and `to =` arguments, both of which called the\n`as.Date()` function which converts a character string into a date\nobject), the value of the evaluated argument is parsed to the outside\nfunction. That is, evaluations are made from the inside to out. The\nabove example, could have been further truncated to;\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate the mean of a sequence of dates spaced 7 days apart between 29th Feb 2000 and 30th Apr 2000\nmean(seq(from = as.Date(\"2000-02-29\"), to = as.Date(\"2000-04-30\"), by = \"7 days\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-03-28\"\n```\n\n\n:::\n:::\n\n\n\n### The pipe character\n\nAs we can see from the example above, nested functions can be pretty\nawkward to read. As of version 4.1, R has had a pipe operator. The\nconcept of piping dates back to the early UNIX days when separate\nprograms were chained ('piped') together such that the output of one\nprogram became the input of the next and so on. This enabled each\nprogram to remain relatively simple, yet by piping sequences of\nprograms together, rather complex results could be achieved.\n\nSimilarly the R pipe operator (`|>`) enables nested functions to\nalternatively be expressed as a chain of functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate the mean of a sequence of dates spaced 7 days apart between 29th Feb 2000 and 30th Apr 2000\nseq(from = as.Date(\"2000-02-29\"), to = as.Date(\"2000-04-30\"), by = \"7 days\") |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-03-28\"\n```\n\n\n:::\n:::\n\n\n\nTo maximise code readability, it is good form to keep lines of code\nshort (less than 80 characters). One way to do this is to place a line\nbreak after pipe characters. Moreover, a line break after each\nfunction argument allows us to have more topical and granular\ncomments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(                              #take sequence of dates\n  from = as.Date(\"2000-02-29\"),   #from the 29th Feb 2000\n  to = as.Date(\"2000-04-30\"),     #to the 30th April 2000\n  by = \"7 days\") |>               #incrementing by 7 days\n  mean()                          #and calculate the mean\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-03-28\"\n```\n\n\n:::\n:::\n\n\n\n## External functions\n\nAs R is a scripting language (rather than a compiled language), it has\nthe potential to be very slow (since syntax checking, machine\ninstruction interpretation, etc must all take place at runtime rather\nthan at compile time). Consequently, many of the functions are\nactually containers (wrappers) for external code (link libraries)\nprecompiled in either C or Fortran. In this way, the environment can\nbenefit from the flexibility of a scripting language whilst still\nmaintaining most of the speed of a compiled language. Tutorial ? will\nintroduce how to install and load external libraries.\n\n# Getting help\n\nThere are numerous ways of seeking help on R syntax and functions (the\nfollowing all ways of finding information about a function that\ncalculates the mean of a vector).\n\n- providing the name of the function as an argument to the\n  `help()` function\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  help(mean)\n  ```\n  :::\n\n\n\n- typing the name of the function preceded by a `'?'`\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  ?mean\n  ```\n  :::\n\n\n\n- to run the examples within the standard help files, use the\n  `example()` function\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  example(mean)\n  ```\n  :::\n\n\n\n- some packages include demonstrations that showcase their features\n  and use cases. The `demo()` function provides a user-friendly way to\n  access these demonstrations. For example, to respectively get an\n  overview of the basic graphical procedures in R and get a list of\n  available demonstrations:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  demo(graphics)  #run the graphics demo\n  demo()          #list all demos available on your system\n  ```\n  :::\n\n\n\n- if you don't know the exact name of the function, the `apropos()`\n  function is useful as it returns the name of all objects from the\n  current search list that match a specific pattern:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  apropos('mea')\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n   [1] \".colMeans\"          \".rowMeans\"          \"colMeans\"          \n   [4] \"influence.measures\" \"kmeans\"             \"mean\"              \n   [7] \"mean.Date\"          \"mean.default\"       \"mean.difftime\"     \n  [10] \"mean.POSIXct\"       \"mean.POSIXlt\"       \"rowMeans\"          \n  [13] \"weighted.mean\"     \n  ```\n  \n  \n  :::\n  :::\n\n\n\n- if you have no idea what the function is called, the `help.search()`\n  and `help.start()` functions search through the regular manuals and\n  the local HTML manuals (via a web browser) respectively for specific\n  terms:\n  \n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  help.search('mean')   #search the local R manuals\n  help.start()          #search the local HTML R manuals\n  ```\n  :::\n\n\n\n- to get a snapshot of the order and default values of a functions'\n  arguments, use the `args()` function:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  args(mean)         #the arguments that apply to the mean function \n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  function (x, ...) \n  NULL\n  ```\n  \n  \n  :::\n  \n  ```{.r .cell-code}\n  args(list.files)   #the arguments that apply to the list.files function\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  function (path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, \n      recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, \n      no.. = FALSE) \n  NULL\n  ```\n  \n  \n  :::\n  :::\n\n\n\nThe `...` argument indicates that other arguments can also be provided\nthat are then parsed onto other functions that may be called within\nthe main function.\n\n# Data Types\n\n## Vectors\n\nVectors are a collection of one or more entries (values) of the same\ntype (class) and are the basic storage unit in R. Vectors are\none-dimensional arrays (have a single dimension - length) and can be\nthought of as a single column of data. Each entry in a vector has a\nunique index (like a row number) to enable reference to particular\nentries in the vector.\n\n### Consecutive integers\n\nTo get a vector of consecutive integers, we can specify an expression\nof the form `<first integer>:<second integer>` where `<first integer>`\nand `<second integer>` represent the start and end of the sequence of\nintegers respectively:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n5:-5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n```\n\n\n:::\n:::\n\n\n\n### The `c()` function\n\nThe `c()` function concatenates values together into a vector. To\ncreate a vector with the numbers 1, 4, 7, 21:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 4, 7, 21)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  7 21\n```\n\n\n:::\n:::\n\n\n\nAs an example, we could store the temperature recorded at 10 sites:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemperature <- c(36.1, 30.6, 31, 36.3, 39.9, 6.5, 11.2, 12.8, 9.7, 15.9)\ntemperature\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9\n```\n\n\n:::\n:::\n\n\n\nTo create a vector with the words 'Fish', 'Rock', 'Tree', 'Git':\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc('Fish', 'Rock', 'Tree', \"Git\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Fish\" \"Rock\" \"Tree\" \"Git\" \n```\n\n\n:::\n:::\n\n\n\n### Regular or patterned sequences (`rep()`)\n\nWe have already seen the use of the `seq()` function to create\nsequences of entries.\n\nSequences of repeated entries are supported with the `rep()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(4,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 4 4 4 4\n```\n\n\n:::\n\n```{.r .cell-code}\nrep('Fish',5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Fish\" \"Fish\" \"Fish\" \"Fish\" \"Fish\"\n```\n\n\n:::\n:::\n\n\n\n### The `paste()` function\n\nTo create a sequence of quadrat labels we could use the `c()` function\nas illustrated above, e.g.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrats <- c(\"Q1\",\"Q2\",\"Q3\",\"Q4\",\"Q5\",\"Q6\",\"Q7\",\"Q8\",\"Q9\",\"Q10\")\nquadrats\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n```\n\n\n:::\n:::\n\n\n\nA more elegant way of doing this is to use the `paste()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrats <- paste(\"Q\", 1:10, sep = \"\")\nquadrats\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n```\n\n\n:::\n:::\n\n\n\nThis can be useful for naming vector elements. For example, we could\nuse the `names()` function to name the elements of the temperature\nvariable according to the quadrat labels.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(temperature) <- quadrats\ntemperature\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n```\n\n\n:::\n:::\n\n\n\nThe `paste()` function can also be used in conjunction with other\nfunctions to generate lists of labels. For example, we could combine a\nvector in which the letters A, B, C, D and E (generated with the\nLETTERS constant) are each repeated twice consecutively (using the\n`rep()` function) with a vector that contains a 1 and a 2 to produce a\ncharacter vector that labels sites in which the quadrats may have\noccurred.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsite <- paste(rep(LETTERS[1:5], each = 2), 1:2, sep = \"\")\nsite\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n```\n\n\n:::\n:::\n\n\n\nOr, with the use of pipes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsite <- rep(LETTERS[1:5], each = 2) |>\n  paste(1:2, sep = \"\")\nsite\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n```\n\n\n:::\n:::\n\n\n\nRather than specify that the components are not separated by any\ncharacter (which is what we are doing above by indicating that the\nseparator character should be \"\"), there is a version of `paste()`\nthat does this automatically. It is `paste0()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsite <- rep(LETTERS[1:5], each = 2) |>\n  paste0(1:2)\nsite\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n\n### Major vector classes\n\n<table class='table table-primary table-bordered table-sm paramsTable' id = 'vector-select-table'>\n<thead>\n<tr class = 'header'>\n<th align = 'left' width=\"180px\">Vector class</th>\n<th align = 'left' width='250px'>Examples</th>\n</tr>\n</thead>\n<tbody>\n<tr class = 'odd'>\n<td align = 'left'>integer<br>(whole numbers)</td>\n<td align = 'left'>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2:4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nc(1, 3, 9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 9\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>numeric<br>(real numbers)</td>\n<td align = 'left'>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(8.4, 2.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.4 2.1\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>character<br>(letters)</td>\n<td align = 'left'>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc('A', 'ABC', 'def')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\"   \"ABC\" \"def\"\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>logical<br>(TRUE or FALSE)</td>\n<td align = 'left'>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2:4 == 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>date<br>(dates)</td>\n<td align = 'left'>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(as.Date(\"2000-02-29\"), as.Date(\"29/02/2000\",\"%d/%m/%Y\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-02-29\" \"2000-02-29\"\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>POSIXlt<br>(date/time)</td>\n<td align = 'left'>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrptime('2011-03-27 01:30:00', format='%Y-%m-%d %H:%M:%S')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2011-03-27 01:30:00 UTC\"\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n</tbody>\n</table>\n\n\n:::\n\n\n### Factors\n\nFactors are more than a vector of characters. Factors have additional\nproperties that are utilized during statistical analyses and graphical\nprocedures. To illustrate the difference, we will create a vector to\nrepresent a categorical variable indicating the level of shading\napplied to 10 quadrats. Firstly, we will create a character vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshade <- rep(c(\"no\", \"full\"), each = 5)\nshade\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"no\"   \"no\"   \"no\"   \"no\"   \"no\"   \"full\" \"full\" \"full\" \"full\" \"full\"\n```\n\n\n:::\n:::\n\n\n\nNow we convert this into a factor:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshade <- factor(shade)\nshade\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] no   no   no   no   no   full full full full full\nLevels: full no\n```\n\n\n:::\n:::\n\n\n\nNotice the additional property (`Levels`) at the end of the output.\nNotice also that unless specified otherwise, the levels are ordered\nalphabetically. Whilst this does not impact on how the data appear in\na vector, it does effect some statistical analyses, their\ninterpretations as well as some tabular and graphical displays. If the\nalphabetical ordering does not reflect the natural order of the data,\nit is best to reorder the levels whilst defining the factor:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshade <- factor(shade, levels = c(\"no\", \"full\"))\nshade\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n```\n\n\n:::\n:::\n\n\n\nA more convenient way to create a balanced (equal number of\nreplicates) factor is to use the `gl()` function. To create the shading\nfactor from above:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshade <- gl(n = 2, k = 5, length = 10, labels = c(\"no\", \"full\"))\nshade\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n```\n\n\n:::\n:::\n\n\n\n### Matrices\n\nMatrices have two dimensions (length and width). The entries (which\nmust be all of the same length and type - class) are in rows and\ncolumns.\n\nWe could arrange the vector of shading into two columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(temperature, nrow = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,] 36.1  6.5\n[2,] 30.6 11.2\n[3,] 31.0 12.8\n[4,] 36.3  9.7\n[5,] 39.9 15.9\n```\n\n\n:::\n:::\n\n\n\nSimilarly, We could arrange the vector of shading into two columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(shade, nrow = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]  \n[1,] \"no\" \"full\"\n[2,] \"no\" \"full\"\n[3,] \"no\" \"full\"\n[4,] \"no\" \"full\"\n[5,] \"no\" \"full\"\n```\n\n\n:::\n:::\n\n\n\nAs another example, we could store the X,Y coordinates for five\nquadrats within a grid. We start by generating separate vectors to\nrepresent the X and Y coordinates and then we bind them together using\nthe `cbind()` function (which combines objects by columns):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(16.92, 24.03, 7.61, 15.49, 11.77)\ny<- c(8.37, 12.93, 16.65, 12.2, 13.12)\nxy <- cbind(x, y)\nxy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         x     y\n[1,] 16.92  8.37\n[2,] 24.03 12.93\n[3,]  7.61 16.65\n[4,] 15.49 12.20\n[5,] 11.77 13.12\n```\n\n\n:::\n:::\n\n\n\nWe could alternatively combine by rows using the `rbind()` function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   [,1]  [,2]  [,3]  [,4]  [,5]\nx 16.92 24.03  7.61 15.49 11.77\ny  8.37 12.93 16.65 12.20 13.12\n```\n\n\n:::\n:::\n\n\n\nWe could even alter the row names using an inbuilt vector of uppercase\nletters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(xy) <- LETTERS[1:5]\nxy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nC  7.61 16.65\nD 15.49 12.20\nE 11.77 13.12\n```\n\n\n:::\n:::\n\n\n\nImportantly, all entries in a matrix must be of the same type. That\nis, they must all be numeric, or all be characters etc. If we attempt\nto mix a combination of data types in a matrix, then the data will all\nbe converted into a type that can accommodate all the data. For\nexample, if we attempt to bind together the numeric `temperature` data\nand the character `site` data into a matrix, then the result will be a\nmatrix of characters (since while it is possible to covert numbers to\nstrings, in this case the reverse is not possible).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(temperature, site)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    temperature site\nQ1  \"36.1\"      \"A1\"\nQ2  \"30.6\"      \"A2\"\nQ3  \"31\"        \"B1\"\nQ4  \"36.3\"      \"B2\"\nQ5  \"39.9\"      \"C1\"\nQ6  \"6.5\"       \"C2\"\nQ7  \"11.2\"      \"D1\"\nQ8  \"12.8\"      \"D2\"\nQ9  \"9.7\"       \"E1\"\nQ10 \"15.9\"      \"E2\"\n```\n\n\n:::\n:::\n\n\n\nOn the other hand, if we attempt to bind together the numeric\n`temperature` data and the factor `shade` data into a matrix, then the\nresult will be a matrix of numbers (recall that factors are internally\nstored as integers, yet they have a levels property that acts rather\nlike a lookup key).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(temperature, shade)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    temperature shade\nQ1         36.1     1\nQ2         30.6     1\nQ3         31.0     1\nQ4         36.3     1\nQ5         39.9     1\nQ6          6.5     2\nQ7         11.2     2\nQ8         12.8     2\nQ9          9.7     2\nQ10        15.9     2\n```\n\n\n:::\n:::\n\n\n\n\n\n### Lists\n\nLists provide a way to group together multiple objects of different\ntype and length. For example, whilst the contents of any single vector\nor matrix must all be of the one type and length (e.g. all numeric or\nall character), a list can contain any combination of vectors,\nmatrices, scalars and of any type. Furthermore, the objects contained\nin a list do not need to be of the same lengths (c.f data frames). The\noutput of most analyses are returned as lists.\n\nAs an example, we could group together the previously created isolated\nvectors and matrices into a single object that encapsulates the entire\nexperiment:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexperiment <- list(\n  site = site,\n  quadrats = quadrats,\n  coordinates = xy,\n  shade = shade,\n  temperature = temperature\n)\nexperiment\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$site\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n$quadrats\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n\n$coordinates\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nC  7.61 16.65\nD 15.49 12.20\nE 11.77 13.12\n\n$shade\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n\n$temperature\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n```\n\n\n:::\n:::\n\n\n\nLists can be thought of as a set of objects bound into a single\ncontainer. In the example above, the list object experiment contains a\ncopy of the site, quadrats, coordinates, shade and temperature\nobjects.\n\nImportantly, once a list has been created the objects within the list\nare not linked in any way to the original objects from which the list\nis formed. Consequently, any changes made to (for example) the\ntemperature object will not be reflected in the content of the\ntemperature object within the experiment list.\n\nTo access an object within a list, the `$` operator is used as such:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexperiment$temperature\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n```\n\n\n:::\n:::\n\n\n\n### Dataframes - data sets\n\nRarely are single biological variables collected in isolation. Rather,\ndata are usually collected in sets of variables reflecting\ninvestigations of patterns between and/or among the different\nvariables. Consequently, data sets are best organized into matrices of\nvariables (vectors) all of the same lengths yet not necessarily of the\nsame type. Hence, neither lists nor matrices represent natural\nstorages for data sets. This is the role of data frames which are used\nto store a set of vectors of the same length (yet potentially\ndifferent types) in a rectangular matrix.\n\nData frames are generated by combining multiple vectors together such\nthat each vector becomes a separate column in the data frame. For a\ndata frame to faithfully represent a data set, the sequence in which\nobservations appear in the vectors must be the same for each vector,\nand each vector should have the same number of observations. For\nexample, the first, second, third...etc entries in each vector must\nrepresent respectively, the observations collected from the first,\nsecond, third...etc sampling units.\n\nSince the focus of these tutorials is on the exploration, analysis and\nsummary of data sets, and data sets are accommodated in R by data\nframes, the generation, importation, exportation, manipulation and\nmanagement of data frames receives extensive coverage in many other\nsubsequent tutorials.\n\nAs an simple example of a data frame, we could again group together\nthe previously created isolated vectors into a single object that\nencapsulates a data set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\n  site = site,\n  quadrats = quadrats,\n  shade = shade,\n  temperature = temperature\n)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    site quadrats shade temperature\nQ1    A1       Q1    no        36.1\nQ2    A2       Q2    no        30.6\nQ3    B1       Q3    no        31.0\nQ4    B2       Q4    no        36.3\nQ5    C1       Q5    no        39.9\nQ6    C2       Q6  full         6.5\nQ7    D1       Q7  full        11.2\nQ8    D2       Q8  full        12.8\nQ9    E1       Q9  full         9.7\nQ10   E2      Q10  full        15.9\n```\n\n\n:::\n:::\n\n\n\n# Object manipulation\n\n## Object information\n\nAs indicated earlier, everything in R is an object. All objects have a\ntype or class that encapsulates the sort of information stored in the\nobject as well as determining how other functions interact with the\nobject. The class of an object can be reviewed with the `class()`\nfunction:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n:::\n\n\n\nThere is also a family of functions prefixed with is. that evaluate\nwhether or not an object is of a particular class (or type) or not.\nThe following table lists the common object query functions. All\nobject query functions return a logical vector. Enter methods(is) for\na more comprehensive list.\n\n\n<table class='table table-primary table-bordered table-sm paramsTable' id = 'vector-select-table'>\n<thead>\n<tr class = 'header'>\n<th align = 'left' width=\"180px\">Function class</th>\n<th align = 'left' width=\"280px\">Returns `TRUE`</th>\n<th align = 'left' width='350px'>Examples</th>\n</tr>\n</thead>\n<tbody>\n<tr class = 'odd'>\n<td align = 'left'>`is.numeric(x)`</td>\n<td align = 'left'>if all elements of `x` are numeric or integers</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.numeric(c(1, -3.5, temperature))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`is.null(x)`</td>\n<td align = 'left'>if `x` is null (the object has no length)</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.null(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>`is.logical(x)`</td>\n<td align = 'left'>if all elements of `x` are logical</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.logical(c(TRUE, FALSE, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`is.character(x)`</td>\n<td align = 'left'>if all elements of `x` are character strings</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.character(c(\"A\", \"Plant\", quadrats))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>`is.vector(x)`</td>\n<td align = 'left'>if the object `x` is a vector (has only a single dimension).  Returns `FALSE` if object has attributes other than 'names'.\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.vector(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`is.factor(x)`</td>\n<td align = 'left'>if the object `x` is a factor</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.factor(shade)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>`is.matrix(x)`</td>\n<td align = 'left'>if the object `x` is a matrix (two dimensions, yet not a`data.frame`)</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.matrix(xy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`is.list(x)`</td>\n<td align = 'left'>if the object `x` is a list</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.list(experiment)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>`is.data.frame(x)`</td>\n<td align = 'left'>if the object `x` is a data.frame</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.data.frame(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`is.na(x)`</td>\n<td align = 'left'>for each missing (`NA`) element in `x`</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nis.na(c(NA, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>`!`</td>\n<td align = 'left'>('not') operator as a prefix converts the above functions into 'is.not'</td>\n<td align = 'left'>\n\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\n!is.factor(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n</tbody>\n</table>\n\n### Attributes\n\nMany R objects also have a set of attributes, the number and type of\nwhich are specific to each class of object. For example, a matrix\nobject has a specific number of dimensions as well as row and column\nnames. The attributes of an object can be viewed using the\n`attributes()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(xy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$dim\n[1] 5 2\n\n$dimnames\n$dimnames[[1]]\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n\n$dimnames[[2]]\n[1] \"x\" \"y\"\n```\n\n\n:::\n:::\n\n\n\nSimilarly, the `attr()` function can be used to view and set individual\nattributes of an object, by specifying the name of the object and the\nname of the attribute (as a character string) as arguments. For\nexample:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(xy, \"dim\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 2\n```\n\n\n:::\n\n```{.r .cell-code}\nattr(xy, \"description\") <- \"coordinates of quadrats\"\nxy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nC  7.61 16.65\nD 15.49 12.20\nE 11.77 13.12\nattr(,\"description\")\n[1] \"coordinates of quadrats\"\n```\n\n\n:::\n:::\n\n\n\nNote that in the above example, the attribute 'description' is not a\nin-built attribute of a matrix. When a new attribute is set, this\nattribute is displayed along with the object. This provides a useful\nway of attaching a description (or other metadata) to an object,\nthereby reducing the risks of the object becoming unfamiliar.\n\n## Object conversion\n\nObjects can be converted or coerced into other objects using a family\nof functions with a as. prefix. Note that there are some obvious\nrestrictions on these conversions as most objects cannot be completely\naccommodated by all other object types, and therefore some information\n(such as certain attributes) may be lost or modified during the\nconversion. Objects and elements that cannot be successfully coerced\nare returned as NA. The following table lists the common object\ncoercion functions. Use methods(as) for a more comprehensive list.\n\n\n<table class='table table-primary table-bordered table-sm paramsTable' id = 'vector-select-table'>\n<thead>\n<tr class = 'header'>\n<th align = 'left' width=\"180px\">Function</th>\n<th align = 'left' width='450px'>Converts object to</th>\n</tr>\n</thead>\n<tbody>\n<tr class = 'odd'>\n<td align = 'left'>`as.numeric(x)`</td>\n<td align = 'left'>\na numeric vector ('integer' or 'real').  Factors converted to integers.\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`as.null(x)`</td>\n<td align = 'left'>\na NULL\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>`as.logical(x)`</td>\n<td align = 'left'>\na logical vector. A values of >1 converted to TRUE otherwise FALSE.\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`as.character(x)`</td>\n<td align = 'left'>\na character (string) vector.\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>`as.vector(x)`</td>\n<td align = 'left'>\na vector. All attributes (including names) are removed.\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`as.factor(x)`</td>\n<td align = 'left'>\na factor. This is an abbreviated (with respect to its argument set) version of the factor() function.\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>`as.matrix(x)`</td>\n<td align = 'left'>\na matrix. Any non-numeric elements result in all matrix elements being converted to characters.\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`as.list(x)`</td>\n<td align = 'left'>\na list\n</td>\n</tr>\n<tr class = 'odd'>\n<td align = 'left'>`as.data.frame(x)`</td>\n<td align = 'left'>\na data.frame. Matrix columns and list items are converted into separate vectors of the dataframe and character vectors are converted into factors. All previous attributes are removed.\n</td>\n</tr>\n<tr class = 'even'>\n<td align = 'left'>`as.date(x)`</td>\n<td align = 'left'>\na date\n</td>\n</tr>\n</tbody>\n</table>\n\n## Indexing\n\nIndexing is the means by which data are filtered (subsetted) to\ninclude and exclude certain entries.\n\n### Vector indexing\n\nSubsets of vectors are produced by appending an index vector (inclosed\nin square brackets `[]`) to a vector name. There are four common forms\nof vector indexing used to extract a subset of vectors:\n\n- **Vector of positive integers** - a set of integers that indicate\n  which elements of the vector should be included:\n \n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  temperature[2]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q2 \n  30.6 \n  ```\n  \n  \n  :::\n  \n  ```{.r .cell-code}\n  temperature[2:5]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q2   Q3   Q4   Q5 \n  30.6 31.0 36.3 39.9 \n  ```\n  \n  \n  :::\n  \n  ```{.r .cell-code}\n  temperature[c(1, 5, 6, 9)]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q1   Q5   Q6   Q9 \n  36.1 39.9  6.5  9.7 \n  ```\n  \n  \n  :::\n  :::\n\n\n\n- **Vector of negative integers** - a set of integers that indicate\n  which elements of the vector should be excluded:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  temperature[-2]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q1   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n  36.1 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n  ```\n  \n  \n  :::\n  \n  ```{.r .cell-code}\n  temperature[c(1, 5, 6, 9) * -1]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q2   Q3   Q4   Q7   Q8  Q10 \n  30.6 31.0 36.3 11.2 12.8 15.9 \n  ```\n  \n  \n  :::\n  :::\n\n\n\n- **Vector of character strings (referencing names)** - for vectors\n  whose elements have been named, a vector of names can be used to\n  select elements to include:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  temperature[\"Q1\"]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q1 \n  36.1 \n  ```\n  \n  \n  :::\n  \n  ```{.r .cell-code}\n  temperature[c(\"Q1\", \"Q4\")]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q1   Q4 \n  36.1 36.3 \n  ```\n  \n  \n  :::\n  :::\n\n\n\n- **Vector of logical values** - a vector of logical values (TRUE or\n  FALSE) the same length as the vector being subsetted. Entries\n  corresponding to a logical TRUE are included, FALSE are excluded:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  temperature[temperature < 15]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q6   Q7   Q8   Q9 \n   6.5 11.2 12.8  9.7 \n  ```\n  \n  \n  :::\n  \n  ```{.r .cell-code}\n  temperature[shade == \"no\"]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q1   Q2   Q3   Q4   Q5 \n  36.1 30.6 31.0 36.3 39.9 \n  ```\n  \n  \n  :::\n  \n  ```{.r .cell-code}\n  temperature[temperature < 34 & shade == \"no\"]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q2   Q3 \n  30.6 31.0 \n  ```\n  \n  \n  :::\n  \n  ```{.r .cell-code}\n  temperature[temperature < 10 | shade == \"no\"]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q1   Q2   Q3   Q4   Q5   Q6   Q9 \n  36.1 30.6 31.0 36.3 39.9  6.5  9.7 \n  ```\n  \n  \n  :::\n  :::\n\n\n\n### Matrix indexing\n\nSimilar to vectors, matrices can be indexed using positive integers,\nnegative integers, character strings and logical vectors. However,\nwhereas vectors have a single dimension (length), matrices have two\ndimensions (length and width). Hence, indexing needs to reflect this.\nIt is necessary to specify both the row and column number. Matrix\nindexing takes of the form of `[row.indices, col.indices]` where\n`row.indices` and `col.indices` respectively represent sequences of\nrow and column indices. If a row or column index sequence is omitted,\nit is interpreted as the entire row or column respectively.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxy[3, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16.65\n```\n\n\n:::\n\n```{.r .cell-code}\nxy[3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    x     y \n 7.61 16.65 \n```\n\n\n:::\n\n```{.r .cell-code}\nxy[, -2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    A     B     C     D     E \n16.92 24.03  7.61 15.49 11.77 \n```\n\n\n:::\n\n```{.r .cell-code}\nxy[\"A\", 1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    x     y \n16.92  8.37 \n```\n\n\n:::\n\n```{.r .cell-code}\nxy[, \"x\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    A     B     C     D     E \n16.92 24.03  7.61 15.49 11.77 \n```\n\n\n:::\n\n```{.r .cell-code}\nxy[xy[, \"x\"] > 12, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nD 15.49 12.20\n```\n\n\n:::\n:::\n\n\n\nIf you think that last example looks awkward you would not be alone.\nIn a later tutorial, I will introduce an alternative way of\nmanipulating data for data frames.\n\n### List indexing\n\nLists consist of collections of objects that need not be of the same\nsize or type. The objects within a list are indexed by appending an\nindex vector (enclosed in single or double square brackets, `[]` or\n`[[]]`), to the list name. Single square brackets provide access to\nmultiple list items (returned as a list), whereas double square\nbrackets provide access to individual list items (returned according\nto the type of object represented by the list item). A single object\nwithin a list can also be referred to by appending a string character\n(`$`) followed by the name of the object to the list names (e.g.\n`list$object`). The elements of objects within a list are indexed\naccording to the object type. Vector indices to objects within other\nobjects (lists) are placed within their own square brackets outside\nthe list square brackets: Recall the `experiment` list we generated\nearlier.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexperiment\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$site\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n$quadrats\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n\n$coordinates\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nC  7.61 16.65\nD 15.49 12.20\nE 11.77 13.12\n\n$shade\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n\n$temperature\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n```\n\n\n:::\n:::\n\n\n\nThe following examples illustrate the common ways to subset (index)\nlists.\n\n- **A vector of positive numbers (single brackets)** - that indicate\n  which list items should be included:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  experiment[c(1,3)]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  $site\n   [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n  \n  $coordinates\n        x     y\n  A 16.92  8.37\n  B 24.03 12.93\n  C  7.61 16.65\n  D 15.49 12.20\n  E 11.77 13.12\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- **A single positive number (double brackets)** - that indicates\n  which list item should be included:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  experiment[[1]]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n   [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- **A single character string (double brackets)** - that indicates\n  which list item should be included:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  experiment[['temperature']]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n  36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n  ```\n  \n  \n  :::\n  :::\n\n\n\n- **Extract the first element of each list item** - returned as a\n  matrix:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  sapply(experiment, \"[\" ,1)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n            site       quadrats    coordinates          shade temperature.Q1 \n            \"A1\"           \"Q1\"        \"16.92\"            \"1\"         \"36.1\" \n  ```\n  \n  \n  :::\n  \n  ```{.r .cell-code}\n  ##notice that only one element of the coordinate pair is included\n  ##OR when the list items are not vectors\n  do.call(cbind, experiment)[1, ]\n  ```\n  \n  ::: {.cell-output .cell-output-stderr}\n  \n  ```\n  Warning in (function (..., deparse.level = 1) : number of rows of result is not\n  a multiple of vector length (arg 1)\n  ```\n  \n  \n  :::\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n         site    quadrats           x           y       shade temperature \n         \"A1\"        \"Q1\"     \"16.92\"      \"8.37\"         \"1\"      \"36.1\" \n  ```\n  \n  \n  :::\n  :::\n\n\n\n## Pattern matching and replacement\n\nAn important part of filtering is the ability to detect patterns on\nwhich to base selections or exclusions. Numerical and categorical\nfiltering rules are generally fairly straight forward, however complex\nfiltering rules can also be devised from character vectors.\nFurthermore, the ability to search and replace character strings\nwithin a character vector can also be very useful.\n\n### `grep` - index of match\n\nThe `grep()` function searches within a vector for matches to a\npattern and returns the index of all matching entries.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## get the indexes of elements of the site vector that contain an 'A' \ngrep(pattern = \"A\", experiment$site)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\n## use the results of the grep as indexes to select only those 'site'\n## values that contain an 'A'\nexperiment$site[grep(pattern = \"a\", experiment$site)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n\nThe pattern can comprise any valid regular expression and is therefore\nvery flexible:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## get the indexes of values of the 'site' vector within the `data`\n## dataframe that contain either an 'A', 'B' or 'C' followed by a '1'\ngrep(\"[a-c]1\", data$site)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ninteger(0)\n```\n\n\n:::\n\n```{.r .cell-code}\n## select only those rows of the `data` dataframe that correspond to a\n## 'site' value of either an 'A', 'B' or 'C' followed by a '1'\ndata[grep(\"[a-c]1\", data$site), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] site        quadrats    shade       temperature\n<0 rows> (or 0-length row.names)\n```\n\n\n:::\n:::\n\n\n\n### `regexpr` - position and length of match\n\nRather than return the indexes of matching entries, the `regexpr()`\nfunction returns the position of the match within each string as well\nas the length of the pattern within each string (-1 values correspond\nto entries in which the pattern is not found).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naust <- c(\"adelaide\", \"brisbane\", \"canberra\", \"darwin\", \"hobart\", \"melbourne\", \"perth\", \"sydney\")\naust\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"adelaide\"  \"brisbane\"  \"canberra\"  \"darwin\"    \"hobart\"    \"melbourne\"\n[7] \"perth\"     \"sydney\"   \n```\n\n\n:::\n\n```{.r .cell-code}\n## get the position and length of string of characters containing an\n## 'a' and an 'e' separated by any number of characters\nregexpr(pattern=\"a.*e\", aust)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  6  2 -1 -1 -1 -1 -1\nattr(,\"match.length\")\n[1]  8  3  4 -1 -1 -1 -1 -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n### `gsub` - pattern replacement\n\nThe `gsub()` function replaces all instances of an identified pattern\nwithin a character vector with an alternative set of characters. The\nsimilar `sub()` function replaces only the first instance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata$shade\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n```\n\n\n:::\n\n```{.r .cell-code}\ngsub(\"no\", \"Not shaded\", data$shade)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Not shaded\" \"Not shaded\" \"Not shaded\" \"Not shaded\" \"Not shaded\"\n [6] \"full\"       \"full\"       \"full\"       \"full\"       \"full\"      \n```\n\n\n:::\n:::\n\n\n\nIt is also possible to extend the functionality to accomodate\nperl-compatible regular expressions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## convert all the capital values entries into uppercase identify (and\n## store) all words (`\\\\w`) convert stored pattern (`\\\\1`) to uppercase\n## (`\\\\U`)\ngsub(\"(\\\\w)\", \"\\\\U\\\\1\", aust, perl = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ADELAIDE\"  \"BRISBANE\"  \"CANBERRA\"  \"DARWIN\"    \"HOBART\"    \"MELBOURNE\"\n[7] \"PERTH\"     \"SYDNEY\"   \n```\n\n\n:::\n:::\n\n\n\n### `substr` - extracting substrings\n\nThe `substr()` function is used to extract parts of string (set of\ncharacters) entries within character vectors and thus is useful for\nmaking truncated labels (particularly for graphical summaries). For\nexample, if we had a character vector containing the names of the\nAustralian capital cities and required abbreviations (first 3\ncharacters) for graph labels:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## recall the AUST character vector that lists the Australian capital\n## cities\naust\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"adelaide\"  \"brisbane\"  \"canberra\"  \"darwin\"    \"hobart\"    \"melbourne\"\n[7] \"perth\"     \"sydney\"   \n```\n\n\n:::\n\n```{.r .cell-code}\nsubstr(aust, start = 1, stop = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ade\" \"bri\" \"can\" \"dar\" \"hob\" \"mel\" \"per\" \"syd\"\n```\n\n\n:::\n:::\n\n\n\nAlternatively, we could use the `abbreviate()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabbreviate(aust, minlength = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n adelaide  brisbane  canberra    darwin    hobart melbourne     perth    sydney \n    \"adl\"     \"brs\"     \"cnb\"     \"drw\"     \"hbr\"     \"mlb\"     \"prt\"     \"syd\" \n```\n\n\n:::\n:::\n\n\n\n### Value matching\n\nIn addition to the above matching procedures, it is possible to\ncompare vectors via the usual set of binary operators (x<y, x>y, xy,\nxy, x==y and x!=y).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshade == 'no'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ntemperature > 32\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Q1    Q2    Q3    Q4    Q5    Q6    Q7    Q8    Q9   Q10 \n TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE \n```\n\n\n:::\n:::\n\n\n\nNote, that the comparisons are made in an item-wise manner. That is,\nitem one of the right hand vector is compared to item one of the left\nhand vector, and item two of each vector are compared to one another\nand so on. If the two vectors are not of equal length, the shorter\nvector is recycled (that is, it returns to the start of that vector\nand keeps going).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Compare 'Q1' to items 1,3,5,7,9 of quadrats and compare 'Q3' to\n## items 2,4,6,8,10.\nquadrats == c('Q1','Q3')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-warning}\n\nBe very cautious when using the binary operators x==y or x!=y to\ncompare numeric vectors as they do not allow for rounding errors or\nfinite representation of fractions and will almost always return FALSE\neven for values that appear identical. As an alternative, consider\nusing a combination of `all.equal()` and `identical()`:\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(0.6 - 0.4) == (0.4 - 0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal((0.6 - 0.4), (0.4 - 0.2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(all.equal((0.6 - 0.4), (0.4 - 0.2)), TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\nEach of the search and replace functions listed above uses only a\nsingle search item (albeit with pattern matching that can accommodate\nmultiple patterns). The match() function searches for the first\ninstance of items in the lookup vector (vector of values to be matched\nagainst) within the vector to be matched (first vector) returning the\nindex of the first instance. Similarly, the special binary operator\n%in% indicates whether or not (TRUE or FALSE) an item of the matching\nvector is contained anywhere within the first vector. This latter\nmechanism makes a very useful filter.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## match the items within the `shade` vector against a lookup character\n## vector containing only the string of \"no\" returning the index\n## within the lookup vector\nmatch(shade,\"no\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  1  1  1  1 NA NA NA NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\n## match the items within the shade vector against a lookup character\n## vector containing only the string of \"no\" returning the index\n## within the lookup vector\nmatch(shade,\"no\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  1  1  1  1 NA NA NA NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\n## same match as above, yet returning a logical vector corresponding\n## to whether each item in the first vector is matched or not\nshade %in% 'no'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n## match quadrats of 'Q1', 'Q4' and 'Q10'\nmatch(quadrats, c(\"Q1\",\"Q4\",\"Q10\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1 NA NA  2 NA NA NA NA NA  3\n```\n\n\n:::\n\n```{.r .cell-code}\nquadrats %in% c(\"Q1\",\"Q4\",\"Q10\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n## use the resulting logical vector as a filter\ndata[quadrats %in% c(\"Q1\",\"Q4\",\"Q10\"),]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    site quadrats shade temperature\nQ1    A1       Q1    no        36.1\nQ4    B2       Q4    no        36.3\nQ10   E2      Q10  full        15.9\n```\n\n\n:::\n:::\n\n\n\n## Sorting\n\nThe `sort()` function is used to sort vector entries in increasing (or\ndecreasing) order.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Q6   Q9   Q7   Q8  Q10   Q2   Q3   Q1   Q4   Q5 \n 6.5  9.7 11.2 12.8 15.9 30.6 31.0 36.1 36.3 39.9 \n```\n\n\n:::\n\n```{.r .cell-code}\nsort(temperature, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Q5   Q4   Q1   Q3   Q2  Q10   Q8   Q7   Q9   Q6 \n39.9 36.3 36.1 31.0 30.6 15.9 12.8 11.2  9.7  6.5 \n```\n\n\n:::\n:::\n\n\n\nThe `order()` function is used to get the position of each entry in a\nvector if it were sorted in increasing (or decreasing) order.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\norder(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  6  9  7  8 10  2  3  1  4  5\n```\n\n\n:::\n\n```{.r .cell-code}\norder(temperature, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  5  4  1  3  2 10  8  7  9  6\n```\n\n\n:::\n:::\n\n\n\nHence the smallest entry in the `temperature` vector was at position\n(index) 6 and so on.\n\nThe `rank()` function is used to get the ranking of each entry in a\nvector if it were sorted in increasing (or decreasing) order.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrank(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n  8   6   7   9  10   1   3   4   2   5 \n```\n\n\n:::\n:::\n\n\n\nIndicating that the first entry in the `temperature` vector was ranked\neighth in increasing order. Ranks from decreasing order can be\nproduced by then reversing the returned vector using the `rev()`\nfunction.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrev(rank(temperature))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nQ10  Q9  Q8  Q7  Q6  Q5  Q4  Q3  Q2  Q1 \n  5   2   4   3   1  10   9   7   6   8 \n```\n\n\n:::\n\n```{.r .cell-code}\n## or via pipe\nrank(temperature) |> rev()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nQ10  Q9  Q8  Q7  Q6  Q5  Q4  Q3  Q2  Q1 \n  5   2   4   3   1  10   9   7   6   8 \n```\n\n\n:::\n:::\n\n\n\n## Formatting data\n\n### Rounding of numerical data\n\nThe `ceiling()` function rounds vector entries up to the nearest\ninteger\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nceiling(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n 37  31  31  37  40   7  12  13  10  16 \n```\n\n\n:::\n:::\n\n\n\nThe `floor()` function rounds vector entries down to the nearest\ninteger\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfloor(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n 36  30  31  36  39   6  11  12   9  15 \n```\n\n\n:::\n:::\n\n\n\nThe `trunc()` function rounds vector entries to the nearest integer\ntowards '0' (zero)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = -2, to = 2, by = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0\n```\n\n\n:::\n\n```{.r .cell-code}\ntrunc(seq(from = -2, to = 2, by = 0.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2 -1 -1  0  0  0  1  1  2\n```\n\n\n:::\n:::\n\n\n\nThe `round()` function rounds vector entries to the nearest numeric\nwith the specified number of decimal places. Digits of 5 are rounded\noff to the nearest even digit.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n 36  31  31  36  40   6  11  13  10  16 \n```\n\n\n:::\n\n```{.r .cell-code}\nround(seq(from = -2, to = 2, by = 0.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2 -2 -1  0  0  0  1  2  2\n```\n\n\n:::\n\n```{.r .cell-code}\nround(temperature/2.2, digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Q1    Q2    Q3    Q4    Q5    Q6    Q7    Q8    Q9   Q10 \n16.41 13.91 14.09 16.50 18.14  2.95  5.09  5.82  4.41  7.23 \n```\n\n\n:::\n\n```{.r .cell-code}\nround(temperature, digits = -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n 40  30  30  40  40  10  10  10  10  20 \n```\n\n\n:::\n:::\n\n\n\n### Notation and labelling of numeric or character data\n\nOccasionally (mainly for graphical displays), it is necessary to be\nable to adjust the other aspects of the formatting of vector entries.\nFor example, you may wish to have numbers expressed in scientific\nnotation (2.93e-04 rather than 0.000293) or insert commas every 3\ndigits left of the decimal point or even add prefixes or suffixes to\nnumbers or words. These procedures are supported via a number of\nfunctions. The uses of each function are contrasted in the following\ntable followed by common usage examples below.\n\n| Function    | Description                                                                                                            |\n|-------------|------------------------------------------------------------------------------------------------------------------------|\n| `paste()`   | Concatenate vectors after converting into characters                                                                   |\n| `format()`  | Adjust decimal places, justification, padding and width of string and whether to use scientific notation               |\n| `formatC()` | A version of format() that is compliant with 'C' style formatting.                                                     |\n| `sprintf()` | A wrapper for the 'C' style formatting function of the same name = provides even greater flexibility (and complexity). |\n\n\n#### `paste()`\n\nCombine multiple elements together along with other character strings.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"Quadrat\", 1:3, sep = \":\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Quadrat:1\" \"Quadrat:2\" \"Quadrat:3\"\n```\n\n\n:::\n\n```{.r .cell-code}\n##create a joint label for site and quadrat combinations\npaste(site, quadrats, sep = \":\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A1:Q1\"  \"A2:Q2\"  \"B1:Q3\"  \"B2:Q4\"  \"C1:Q5\"  \"C2:Q6\"  \"D1:Q7\"  \"D2:Q8\" \n [9] \"E1:Q9\"  \"E2:Q10\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## create a formula relating temperature to quadrat, site and shade\npaste(names(data)[4], paste(names(data)[-4], collapse = \"+\"), sep = \"~\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"temperature~site+quadrats+shade\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## or more neatly\npaste(names(data)[4],\n  paste(names(data)[-4], collapse = \"+\"),\n  sep = \"~\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"temperature~site+quadrats+shade\"\n```\n\n\n:::\n:::\n\n\n\n#### `format()`\n\nOverloaded generic function for formatting objects (particularly\nnumeric vectors). The most prominent features include:\n\n- Automatically adding leading or trailing spaces to create equal width labels (via `trim =`, `width =` and `justify =`\n)\n\n- Application of scientific notation (via `scientific =`)\n\n- Rounding of numbers (via `digits =` and `nsmall =`)\n\n- Applies to each column in a dataframe separately\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## create equal width strings by adding padding to the start (left\n## side) of numbers\nformat(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Q1     Q2     Q3     Q4     Q5     Q6     Q7     Q8     Q9    Q10 \n\"36.1\" \"30.6\" \"31.0\" \"36.3\" \"39.9\" \" 6.5\" \"11.2\" \"12.8\" \" 9.7\" \"15.9\" \n```\n\n\n:::\n\n```{.r .cell-code}\n## create labels with a minimum of 2 digits to the right hand side of\n## the decimal place\nformat(temperature, nsmall = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Q1      Q2      Q3      Q4      Q5      Q6      Q7      Q8      Q9     Q10 \n\"36.10\" \"30.60\" \"31.00\" \"36.30\" \"39.90\" \" 6.50\" \"11.20\" \"12.80\" \" 9.70\" \"15.90\" \n```\n\n\n:::\n\n```{.r .cell-code}\n## create labels that are rounded numbers\nformat(temperature, digits = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n\"36\" \"31\" \"31\" \"36\" \"40\" \" 6\" \"11\" \"13\" \"10\" \"16\" \n```\n\n\n:::\n\n```{.r .cell-code}\n## create labels that are scientific representations of the numbers\nformat(temperature, scientific = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        Q1         Q2         Q3         Q4         Q5         Q6         Q7 \n\"3.61e+01\" \"3.06e+01\" \"3.10e+01\" \"3.63e+01\" \"3.99e+01\" \"6.50e+00\" \"1.12e+01\" \n        Q8         Q9        Q10 \n\"1.28e+01\" \"9.70e+00\" \"1.59e+01\" \n```\n\n\n:::\n\n```{.r .cell-code}\n## apply formatting rules to a dataframe (notice the left\n## justification of Shade and the number of decimal places of\n## temperature)\nformat(data, justify = \"left\", nsmall = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    site quadrats shade temperature\nQ1    A1      Q1   no         36.10\nQ2    A2      Q2   no         30.60\nQ3    B1      Q3   no         31.00\nQ4    B2      Q4   no         36.30\nQ5    C1      Q5   no         39.90\nQ6    C2      Q6   full        6.50\nQ7    D1      Q7   full       11.20\nQ8    D2      Q8   full       12.80\nQ9    E1      Q9   full        9.70\nQ10   E2      Q10  full       15.90\n```\n\n\n:::\n:::\n\n\n\n#### `formatC()`\n\nSimilar to the `format()` function, yet also allows 'C' style formatting\nspecifications:\n\n- 'd' for integers\n- 'f' for reals in the standard xxx.xxx format\n- 'e', 'E' for reals in the scientific (n.ddde+nn) format\n- 'g', 'G' for reals in the scientific (n.ddde+nn) format when it\n  saves space to do so\n- 's' for strings\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(pi, pi * 10000, length = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     3.141593  7856.337828 15709.534064 23562.730300 31415.926536\n```\n\n\n:::\n\n```{.r .cell-code}\n## format to integers  \nformatC(seq(pi, pi * 10000, length = 5), format = \"d\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\"     \"7856\"  \"15709\" \"23562\" \"31415\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## scientific notation\nformatC(seq(pi, pi * 10000, length = 5), format = \"e\", digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3.14e+00\" \"7.86e+03\" \"1.57e+04\" \"2.36e+04\" \"3.14e+04\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## scientific notation only if it saves space\nformatC(seq(pi, pi * 10000, length = 5), format = \"g\", digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3.1\"     \"7.9e+03\" \"1.6e+04\" \"2.4e+04\" \"3.1e+04\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## floating point format with 1000's indicators\nformatC(seq(pi, pi * 10000, length = 5), format = \"f\", big.mark = \",\", digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3.14\"      \"7,856.34\"  \"15,709.53\" \"23,562.73\" \"31,415.93\"\n```\n\n\n:::\n:::\n\n\n\n#### `sprintf()`\n\nSimilar to the `format()` function, yet also allows 'C' style formatting\nspecifications:\n\n- 'd' for integers\n- 'f' for reals in the standard xxx.xxx format\n- 'e', 'E' for reals in the scientific (n.ddde+nn) format\n- 'g', 'G' for reals in the scientific (n.ddde+nn) format when it saves space to do so\n- 's' for strings\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPI <- seq(pi, pi * 10000, length = 5)\nPI\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     3.141593  7856.337828 15709.534064 23562.730300 31415.926536\n```\n\n\n:::\n\n```{.r .cell-code}\n## format to integers\nsprintf(\"%.0f\", PI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\"     \"7856\"  \"15710\" \"23563\" \"31416\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## format to two decimal places and 6 characters to the left of the\n## decimal point (right justified)\nsprintf(\"%6.2f\", PI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"  3.14\"   \"7856.34\"  \"15709.53\" \"23562.73\" \"31415.93\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## scientific notation\nsprintf(\"%e\", PI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3.141593e+00\" \"7.856338e+03\" \"1.570953e+04\" \"2.356273e+04\" \"3.141593e+04\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## scientific notation only when it saves space\nsprintf(\"%6.2g\", PI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"   3.1\"  \"7.9e+03\" \"1.6e+04\" \"2.4e+04\" \"3.1e+04\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## concatenating strings\nsprintf(\"%s-%s\", site, quadrats)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A1-Q1\"  \"A2-Q2\"  \"B1-Q3\"  \"B2-Q4\"  \"C1-Q5\"  \"C2-Q6\"  \"D1-Q7\"  \"D2-Q8\" \n [9] \"E1-Q9\"  \"E2-Q10\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsprintf(\"%s=%.2g\", 'val', PI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"val=3.1\"     \"val=7.9e+03\" \"val=1.6e+04\" \"val=2.4e+04\" \"val=3.1e+04\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsprintf(\"%s=%6.2g\", 'val', PI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"val=   3.1\"  \"val=7.9e+03\" \"val=1.6e+04\" \"val=2.4e+04\" \"val=3.1e+04\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsprintf('%11s', sprintf(\"%s=%.2g\", 'val', PI))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"    val=3.1\" \"val=7.9e+03\" \"val=1.6e+04\" \"val=2.4e+04\" \"val=3.1e+04\"\n```\n\n\n:::\n:::\n\n\n\n## Applying functions repetitively\n\nAs R is a programming language, it naturally has constructs for\ncontrolling flow via looping and conditional evaluation. R's basic\ncontrol-flow constructs is the topic of another tutorial. Despite the\nenormous flexibility gained via the usual control-flow constructs,\nrecall that as R is a scripting language (rather than a compiled\nlanguage), it is relatively slow. In particular, repetitive tasks\n(such as looping though a dataframe and applying the same function to\ndifferent subsets of the data) are especially inefficient.\n\nThere are a number of functions in R that are designed to allow the\nrepetitive application of a function thereby replacing the need to\nwrite loops.\n\n| Function       | Description                                                                            |\n|----------------|----------------------------------------------------------------------------------------|\n| `rep()`        | Duplicates the result of a function multiple times                                     |\n| `replicated()` | Performs a function multiple times                                                     |\n| `apply()`      | Repetitively apply a function over the margins of a matrix                             |\n| `tapply()`     | Repetitively apply a function to cells made up of unique combinations of factor levels |\n| `lapply()`     | Repetitively apply a function to the elements of a list of vector and return a list.   |\n\n: {.primary .bordered .sm .paramsTable}\n\nThe `replicate()` function repeatedly performs the function specified\nin the second argument the number of times indicated by the first\nargument. The important distinction between the `replicate()` function\nand the `rep()` function described earlier, is that the former\nrepeatedly performs the function whereas the later performs the\nfunction only once and then duplicates the result multiple times.\n\nSince most functions produce the same result each time they are\nperformed, for many uses, both functions produce identical results.\nThe one group of functions that do not produce identical results each\ntime, are those involved in random number generation. Hence, the\n`replicate()` function is usually used in conjunction with random number\ngenerators (such as `runif()`, which will be described in greater detail\nin subsequent tutorial) to produce sets of random numbers. Consider first the\ndifference between `rep()` and `replicate()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(runif(1), times = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9763246 0.9763246 0.9763246 0.9763246 0.9763246\n```\n\n\n:::\n\n```{.r .cell-code}\nreplicate(n = 5, runif(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.01787043 0.25583908 0.32905634 0.01150998 0.83639579\n```\n\n\n:::\n:::\n\n\n\nWhen the function being run within `runif()` itself produces a vector\nof length > 1, the `runif()` function combines each of the vectors\ntogether as separate columns in a matrix:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplicate(n = 5, runif(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]      [,2]       [,3]      [,4]      [,5]\n[1,] 0.59435310 0.1835988 0.37624459 0.9654190 0.2383339\n[2,] 0.41950346 0.9722103 0.26306599 0.4061502 0.6956501\n[3,] 0.96500017 0.3767028 0.43142224 0.1255858 0.5910425\n[4,] 0.99170026 0.1354966 0.02523368 0.7404491 0.3254772\n[5,] 0.07153679 0.1189697 0.65700727 0.3326440 0.1349074\n```\n\n\n:::\n:::\n\n\n\n### Apply functions along matrix margins\n\nThe `apply()` function applies a function to the margins (1=row\nmargins and 2=column margins) of a matrix. For example, we might have\na matrix that represents the abundance of three species of moth from\nthree habitat types:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoth <- cbind(SpA = c(25, 6, 3), SpB = c(12, 12, 3), SpC = c(7, 2, 19))\nrownames(moth) <- paste(\"Habitat\", 1:3, sep = \"\")\nmoth\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         SpA SpB SpC\nHabitat1  25  12   7\nHabitat2   6  12   2\nHabitat3   3   3  19\n```\n\n\n:::\n:::\n\n\n\nThe `apply()` function could be used to calculate the column means\n(mean abundance of each species across habitat types):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(moth, MARGIN = 2, FUN = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      SpA       SpB       SpC \n11.333333  9.000000  9.333333 \n```\n\n\n:::\n:::\n\n\n\n### Pivot tables\n\nThe `tapply()` function applies a function to a vector separately for\neach level of a factorial variable. For example, if we wanted to\ncalculate the mean temperature for each level of the shade variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntapply(temperature, INDEX = shade, FUN = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   no  full \n34.78 11.22 \n```\n\n\n:::\n\n```{.r .cell-code}\n## calculate the mean temperature per shade and quadrat number combination\n## quadrat number is just the last digit of the quadrats vector\n## extracted via substr(site, 2, 2)\ntapply(temperature, list(shade, quadnum = substr(site, 2, 2)), mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      quadnum\n              1        2\n  no   35.66667 33.45000\n  full 10.45000 11.73333\n```\n\n\n:::\n:::\n\n\n\n### Apply a function over a list\n\nThe `lapply()` and `sapply()` functions apply a function separately to\neach of the objects in a list and return a list and vector/matrix\nrespectively. For example, to find out the length of each of the\nobjects within the experiment list:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(experiment, length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$site\n[1] 10\n\n$quadrats\n[1] 10\n\n$coordinates\n[1] 10\n\n$shade\n[1] 10\n\n$temperature\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nsapply(experiment, length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       site    quadrats coordinates       shade temperature \n         10          10          10          10          10 \n```\n\n\n:::\n:::\n\n\n\n# Packages {#sec-packages}\n\nOne of the great strengths of R is the ease to which it can be\nextended via the creation of new functions. This means that the\nfunctionality of the environment is not limited by the development\npriorities and economics of a comercial enterprise. Moreover,\ncollections of related functions can be assembled together into what\nis called a package or library. These _packages_ can be distributed to\nothers to use or modify and thus the community and capacity grows.\n\nOne of the keys to the concept of packages is that they extend the\nfunctionality when it is required. Currently (2023), there are in\nexcess of 5000 packages available on CRAN (Comprehensive R Archive\nNetwork) and an additional 3000 packages available via other sources.\nIf all of that functionality was available simultaneously, the\nenvironment would be impeared with bloat. In any given session, the\namount of extended functionality is likely to be relatively low,\ntherefore it makes sense to only 'load' the functionality into memory\nwhen it is required.\n\nThe R environment comprises the core language itself (with its built\nin data, memory and control structures along with parsers, error\nhandlers and built in operators and constants) along with any number\nof packages. Even on a brand new install of R there are some packages.\nThese tend to provide crucial of common functions and as such many of\nthem are automatically loaded at the start of an R session.\n\nPackages in R can be conceptualised using an analogy of a various\ndictionaries in paper-back book format. Each dictionary (perhaps\nEnglish, Spanish and French) contains the definition of words that you\ncan lookup to understand their meaning. Analogously, when evaluating a\nstatement, the R interpreter 'looks up' the definitions of functions\nand other objects from the collections of available sets of\ndefinitions.\n\nIn order to use your dictionary, you must first have purchased this\ndictionary, and upon doing so you tidily place it on the shelf with\nall your other books. Then each time you anticipate needing this\ndictionary, you take it off the shelf and place it conveniently on\nyour desk. If you anticipate needing multiple dictionaries, then they\nare stacked one on top of the other on your desk (last collected off\nthe shelf will be at the top of the stack).\n\nIn the case of R packages, a package is first installed whereby it is\nstored in your file system. When you anticipate needing the functions\nin a package, you load the package. This action places the package on\nthe top of the search stack.\n\nNote, in both the case of the dictionaries and the R packages,\npurchase (dictionary) and installation (R package) is only necessary\nonce, however, retrieving to your desk (dictionary) and loading (R\npackages) is necessary for each session you intend to use the\nresource. To further extend the analogy, in both cases it is also\nrecommended that your resource (dictionary or R packages) be updated\nfrom time to time so as to ensure they reflect the most modern\nunderstandings.\n\nFinally, it is possible that the same word appears in multiple\ndictionaries (perhaps even with completely different definitions).\nWhen attempting to discover the definition of a word, you might settle\non the first occurrence that you encounter - which would be the\ndefinition from the book closest to the top of the stack since that is\nthe order that you search through your dictionaries). The same is true\nfor R packages. The definition that R uses will be the definition from\nthe package most recently added. If however, you know which\ndictionary/R package to search in (the _namespace_), you can of course\ngo straight to that source and avoid any ambiguity.\n\nTo see what packages are currently loaded in your session, enter the\nfollowing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(.packages())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"stats\"     \"graphics\"  \"grDevices\" \"utils\"     \"datasets\"  \"methods\"  \n[7] \"base\"     \n```\n\n\n:::\n:::\n\n\n\nA more general alternative to using the `.packages()` function, is to\nuse the `seach()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n[4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n[7] \"package:methods\"   \"Autoloads\"         \"package:base\"     \n```\n\n\n:::\n:::\n\n\n\nActually, the `search()` function as just used (without providing a\nstring to search for), returns the locations (search path) and order\nof where commands are searched for. For example, when you enter a\ncommand, the first place that R searches for this command (variable,\nfunction, constant, etc) is `.GlobalEnv`. .GlobalEnv is the current\nworkspace and stores all the user created objects (such as variables,\ndataframe etc). If the object is not found in .GlobalEnv, the search\ncontinues within the next search location (in my case the stats\npackage) and so on. When you load an additional package (such as the\nMASS` package, this package (along with any of other packages that it\ndepends on) will be placed towards the start of the search queue. The\nlogic being that if you have just loaded the package, then chances are\nyou intend to use its functionality and therefore your statements will\nmost likely be evaluated faster (because there is likely to be less to\nsearch through before locating the relevant objects).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\nsearch()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \".GlobalEnv\"        \"package:MASS\"      \"package:stats\"    \n [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n[10] \"package:base\"     \n```\n\n\n:::\n:::\n\n\n\nIndeed, issuing the `library()` function in this way simply adds the\npackage to the search path. The `detach()` function removes a package\nfrom the search path. Removing a package from the search path when you\nknow its functions are not going to be required for the rest of the\nsession speeds up the evaluation of many statements (and therefore\nmost routines) as the engine potentially has fewer packages to\ntraverse whilst seeking objects.\n\n## Listing installed packages\n\nThe `installed.packages()` function tabulates a list of all the\ncurrently installed packages available on your system along with the\npackage path (where is resides on your system) and version number.\nAdditional fields can be requested (including \"Priority\", \"Depends\",\n\"Imports\", \"LinkingTo\", \"Suggests\", \"Enhances\", \"OS_type\", \"License\"\nand \"Built\").\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstalled.packages()\ninstalled.packages(fields=c(\"Package\", \"LibPath\", \"Version\", \"Depends\",\"Built\"))\n```\n:::\n\n\n\n::: {.callout-note}\n\nIn the above, I have intentionally supressed the output so as not to\nflood the output (I have a very large number of packages installed on\nmy machine).\n\n:::\n\nYet more information can be obtained for any single package with the\npackageDescription() and library functions - the latter provides all\nthe information of the former and then includes a descriptive index of\nall the functions and datasets defined within the package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackageDescription('MASS')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPackage: MASS\nPriority: recommended\nVersion: 7.3-60.0.1\nDate: 2024-01-12\nRevision: $Rev: 3621 $\nDepends: R (>= 4.0), grDevices, graphics, stats, utils\nImports: methods\nSuggests: lattice, nlme, nnet, survival\nAuthors@R: c(person(\"Brian\", \"Ripley\", role = c(\"aut\", \"cre\", \"cph\"),\n        email = \"ripley@stats.ox.ac.uk\"), person(\"Bill\", \"Venables\",\n        role = \"ctb\"), person(c(\"Douglas\", \"M.\"), \"Bates\", role =\n        \"ctb\"), person(\"Kurt\", \"Hornik\", role = \"trl\", comment =\n        \"partial port ca 1998\"), person(\"Albrecht\", \"Gebhardt\", role =\n        \"trl\", comment = \"partial port ca 1998\"), person(\"David\",\n        \"Firth\", role = \"ctb\"))\nDescription: Functions and datasets to support Venables and Ripley,\n        \"Modern Applied Statistics with S\" (4th edition, 2002).\nTitle: Support Functions and Datasets for Venables and Ripley's MASS\nLazyData: yes\nByteCompile: yes\nLicense: GPL-2 | GPL-3\nURL: http://www.stats.ox.ac.uk/pub/MASS4/\nContact: <MASS@stats.ox.ac.uk>\nNeedsCompilation: yes\nPackaged: 2024-01-13 12:39:26 UTC; ripley\nAuthor: Brian Ripley [aut, cre, cph], Bill Venables [ctb], Douglas M.\n        Bates [ctb], Kurt Hornik [trl] (partial port ca 1998), Albrecht\n        Gebhardt [trl] (partial port ca 1998), David Firth [ctb]\nMaintainer: Brian Ripley <ripley@stats.ox.ac.uk>\nRepository: CRAN\nDate/Publication: 2024-01-13 13:36:16 UTC\nBuilt: R 4.3.3; x86_64-pc-linux-gnu; 2024-05-25 01:45:06 UTC; unix\n\n-- File: /opt/R/4.3.3/lib/R/library/MASS/Meta/package.rds \n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(help='MASS')\n```\n:::\n\n\n\n## Installing packages\n\nThe R community contains some of the brightest and most generous\nmathematician, statisticians and practitioners who continue to\nactively develop and maintain concepts and routines. Most of these\nroutines end up being packaged as a collection of functions and then\nhosted on one or more publicly available sites so that others can\nbenefit from their efforts.\n\nThe locations of collections of packages are called repositories or\n'repos' for short. There four main repositories are CRAN,\nBioconductor, R-Forge and github. By default, R is only 'tuned in' to\nCRAN. That is any package queries or actions pertain just to the CRAN\nrepositories.\n\nTo get a tabulated list of all the packages available on CRAN (warning\nthere are over 5000 packages, so this will be a large table - I will\nsuppress the output):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\navailable.packages()\n```\n:::\n\n\n\n### Comprehensive R Archive Network - CRAN\n\nCRAN is a repository of R packages mirrored across 90 sites throughout\nthe world. Packages are installed from CRAN using the\n`install.packages()` function. The first (and only mandatory) argument\nto the `install.packages()` function is the name of the package(s) to\ninstall (`pkgs =`). If no other arguments are provided, the\n`install.packages()` function will search CRAN for the specified\npackage(s) and install it along with any of its dependencies that are\nnot yet installed on your system.\n\nNote, unless you have started the session with administrator (root)\nprivileges, the packages will be installed within a path of your home\nfolder. Whilst this is not necessarily a bad thing, it does mean that\nthe package is not globally available to all users on your system (not\nthat it is common to have multiple users of a single system these\ndays). Moreover, it means that R packages reside in multiple locations\nacross your system. The packages that came with your R install will be\nin one location (or a couple or related locations) and the packages\nthat you have installed will be in another location.\n\nTo see the locations currently used on your system, you can issue the\nfollowing statement.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.libPaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/runner/work/_temp/Library\" \"/opt/R/4.3.3/lib/R/site-library\"\n[3] \"/opt/R/4.3.3/lib/R/library\"     \n```\n\n\n:::\n:::\n\n\n\nTo install a specific package (and its dependencies). The package that\nI have chosen to demonstrate this with (remotes) is a package that\nenables R packages to be installed from git repositories (such as\ngithub, and will be featured in a later subsection).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\")\n```\n:::\n\n\n\nYou will be prompted to select a mirror site. In the absence of any\nother criterion, just select the mirror that is closed geographically\nto you. The terminal will then provide feedback about the progress and\nstatus of the install process. By indicating a specific repository,\nyou can avoid being prompted for a mirror. For example, I chose to use\na CRAN mirror at Melbourne University (Australia), and therefore the\nfollowing statement gives me direct access\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\", repos = \"http://cran.csiro.au\")\n```\n:::\n\n\n\nFinally, you could provide a vector of repository names if you were\nunsure which repository was likely to contain the package you were\nafter. This can also be useful if your preferred mirror regularly\nexperiences downtime - the alternative mirror (second in the vector)\nis used only when the first fails.\n\n### Bioconductor\n\nBioconductor is an open source and open development project devoted to\ngenomic data analysis tools, most of which are available as R\npackages. Whilst initially the packages focused primarily on the\nmanipulation and analysis of DNA microarrays, as the scope of the\nprojects has expanded, so too has the functional scope of the packages\nthere hosted.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"http://bioconductor.org/biocLite.R\")\nbiocLite(\"limma\")\n```\n:::\n\n\n\nOr to install multiple packages from Bioconductor\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"http://bioconductor.org/biocLite.R\")\nbiocLite(c(\"GenomicFeatures\", \"AnnotationDbi\"))\n```\n:::\n\n\n\n### R-Forge\n\nUnlike both CRAN and Bioconductor (which are essentially package\nrepositories), R-Forge is an entire R package development platform.\nPackage development is supported through a range of services\nincluding:\n\n- version control (SVN) - allowing multiple collaborators to maintain\n  current and historical versions of files by facilitating\n  simultaneous editing, conflict resolution and rolling back\n- daily package checking and building - so packages are always up to\n  date\n- bug tracking and feature request tools\n- mailing lists and message boards\n- full backup and archival system\n\nAnd all of this within a mature content management system like web\nenvironment. Installing packages from R-Forge is the same as it is for\nCRAN, just that the path of the root repository needs to be specified\nwith the repos= argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"lme4.0\", repos = \"http://R-Forge.R-project.org\")\n```\n:::\n\n\n\n### Github (via `remotes`)\n\nGithub builds upon the philosophy of the development platform promoted\nby the Source Forge family (including R-Forge) by adding the ability\nto fork a project. Forking is when the direction of a project is split\nso that multiple new opportunities can be explored without\njeopardizing the stability and integrity of the parent source. If the\nchange in direction proves valuable, the project (package) can either\nbecome a new package or else feedback into the development of the\noriginal package.\n\nHadley Wickham and Co have yet again come up with a set of\noutrageously useful tools (remotes package). This package is a set of\nfunctions that simplify (albeit slightly dictatorially) the processes\nof installing packages from remote and local repositories (Github,\nGitlab, Bitbucket etc)\n\nIn order to make use of this package to install packages from github,\nthe remotes package must itself be installed (we did this earlier). It is recommended that\nthis install take place from CRAN (as outline above). Thereafter, the\nremotes package can be included in the search path and the\n`install_github` function used to retrieve and install a nominated\npackage or packages from Github.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github(\"ggplot2\")\n```\n:::\n\n\n\nAs described above, Github is a development platform and therefore it\nis also a source of 'bleeding edge' development versions of packages.\nWhilst the development versions are less likely to be as stable or\neven as statistically rigorous as the final release versions, they do\noffer the very latest ideas and routines. They provide the very latest\nsnapshot of where the developers are currently at.\n\nMost of the time users only want the stable release versions of a\npackage. However there are times when having the ability to try out\nnew developments as they happen can be very rewarding. The\n`install_dev()` function allows for the installation of the\ndevelopment version of a package.\n\nThe more complex `devtools` package (also by Hadley Wickham et al)\nprovides a set of functions that simplify (albeit slightly\ndictatorially) the processes of package authoring, building, releasing\nand installing. Within the `devtools` package, the `dev_mode()`\nfunction provides a switch that can be used to toggle your system in\nand out of development mode. When in development mode, installed\npackages are quarantined within a separate path (R-dev) to prevent\nthem overriding or conflicting with the stable versions that are\ncritical for your regular analyses.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## switch to development mode\ndevtools::dev_mode(on = TRUE)\n##install the development version of ggplot2\ndevtools::install_github(\"ggplot2\")\n## use the development version of ggplot2 \nlibrary(ggplot2)\n## switch development mode off\ndevtools::dev_mode(on = FALSE)\n## stable version of ggplot2 is now engaged\n```\n:::\n\n\n\n### Manual download and install\n\nPackages are made available on the various repositories in compressed\nform and differ between Windows, MacOSX and Linux versions. Those web\nrepositories all have functionality for navigating or searching\nthrough the repositories for specific packages. The packages\n(compressed files) can be directly downloaded from these sites.\n\nAdditionally, some packages are not available on the various\nrepositories and firewalls and proxies can sometimes prevent R from\naccessing the repositories directly. In these cases, packages must be\nmanually downloaded and installed.\n\nThere are a number of ways to install a package that resides locally.\nNote, do not uncompress the packages.\n\n1. From the command line (outside of R).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nR CMD INSTALL packagename \n```\n:::\n\n\n\nwhere `packagename` is replaced by the path and name of the compressed\npackage.\n\n- Using the `install.packages()` function by specifying `repos = NULL`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('packagename', repos=NULL)\n```\n:::\n\n\n\nwhere `packagename` is replaced by the path (if not in the current\nworking directory) and name of the compressed package.\n\n- Via the Windows RGui, select the Install package(s) from local zip\n  files... option of the Packages menu and select the compressed\n  package.\n\n## Updating packages\n\nAn integral component of package management is being able to maintain\nan up to date system. Many packages are regularly updated so as to\nadopt new ideas and functionality. Indeed, it is the speed of\nfunctional evolution that sets R apart from most other statistical\nenvironments.\n\nAlong with the `install.packages()` function, there are three other\nfunctions to help manage and maintain the packages on your system.\n\n- `old.packages()` compares the versions of packages you have\n  installed with the versions of those packages available in the\n  current repositories. It tabulates the names, install paths and\n  versions of old packages on your system.\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  old.packages()\n  ```\n  :::\n\n\n\n- Alternative repositories (than CRAN) can be indicated via the `repos\n  =` argument.\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  old.packages(repos = \"http://R-Forge.R-project.org\")\n  ## or even multiple repos\n  old.packages(repos = c(\"http://cran.csiro.au\", \"http://R-Forge.R-project.org\"))\n  ```\n  :::\n\n\n\n- `new.packages()` provides a tabulated list of all the packages on\n  the repository that are either not in your local install, or else\n  are of a newer version. Note, with over 4000 packages available on\n  CRAN, unless the repos= parameter is pointing to somewhere very\n  specific (and with a narrow subset of packages) this function is\n  rarely of much use.\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  new.packages()\n  ```\n  :::\n\n\n  \n- `update.packages()` downloads and installs packages for which newer\n  versions of those packages identified as 'old' by the `old.packages()`\n  function. Just like `old.packages()`, alternative or multiple\n  repositories can be specified.\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  update.packages()\n  ## or from alternative multiple repos\n  update.packages(repos = c(\"http://cran.csiro.au\", \"http://R-Forge.R-project.org\"))\n  ```\n  :::\n\n\n\n## Package management (`pak`)\n\nPackage management can be a relatively complex task. These days\npackages are sourced from a variety and mixture of locations (CRAN,\nGithub etc). Furthermore, most packages have a complex network of\ndependencies (that is, they depend on other packages). The fine folk\nover at Rstudio have developed a package called `pak` that aims to\nprovide a unified and simplified interface to package management.\n\nThis next-generation package installer offers several key advantages\nfor the technical R user:\n\n- Parallel downloads: `pak` leverages multi-core processing to\n  download multiple packages simultaneously, significantly reducing\n  installation time.\n- Intelligent dependency resolution: `pak` automatically resolves\n  package dependencies, installing the necessary versions in the\n  correct order, ensuring a seamless experience.\n- Expanded package sources: `pak` supports installation from diverse\n  repositories like Bioconductor and even GitHub URLs, providing\n  access to a broader range of cutting-edge tools.\n- Fine-grained control: `pak` gives you the power to specify them\n  explicitly, offering greater control over your R environment.\n- Extensible architecture: `pak` exposes an API for building custom\n  extensions and integrating seamlessly with your data science\n  workflows.\n\nBefore we can take advantage of `pak` package management, it must\nfirst be installed from CRAN using the traditional package\ninstallation method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"pak\")\n```\n:::\n\n\n\n### Dependencies\n\nFor any given package, we can see the dependencies.  To illustrate, I will focus on the `Matrix` package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pkg_deps(\"Matrix\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n Loading metadata database\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n Loading metadata database ... done\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A data frame: 2  36\n  ref     type  direct directpkg status package version license needscompilation\n  <chr>   <chr> <lgl>  <lgl>     <chr>  <chr>   <chr>   <chr>   <lgl>           \n1 lattice stan FALSE  FALSE     OK     lattice 0.22-6  GPL (> TRUE            \n2 instal inst FALSE  TRUE      OK     Matrix  1.6-5   GPL (> TRUE            \n#  27 more variables: priority <chr>, md5sum <chr>, sha256 <chr>,\n#   filesize <int>, built <chr>, platform <chr>, rversion <chr>,\n#   repotype <chr>, repodir <chr>, target <chr>, deps <list>, mirror <chr>,\n#   sources <list>, remote <list>, error <list>, metadata <list>,\n#   dep_types <list>, params <list>, sysreqs <chr>, cache_status <chr>,\n#   sysreqs_packages <list>, sysreqs_pre_install <chr>,\n#   sysreqs_post_install <chr>, sysreqs_install <chr>, lib_status <chr>, \n```\n\n\n:::\n:::\n\n\n\nAfter some database checking, the above function returns a _tibble_\n(like a data frame, yet with some special properties that include\ntruncated output) containing a row for each dependency. In this\nexample, the tibble has just two rows (one for the `Matrix` package,\nand the other for its only dependency, the `Lattice` package). To save\nspace, the many columns have been truncated, yet listed below the\ntibble.\n\nAlternatively, we could view the dependencies as a tree.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pkg_deps_tree(\"Matrix\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMatrix 1.6-5 < 1.7-0 [old]\nlattice 0.22-5 -> 0.22-6 [upd][bld][cmp][dl] (598.58 kB)\n\nKey:  [upd] update | [old] outdated | [dl] download | [bld] build | [cmp] compile\n```\n\n\n:::\n:::\n\n\n\nWe can see from the above that the `Matrix` package depends on the\n`Lattice` package.\n\n\n### Installing packages\n\nTo install a package:\n\n- from CRAN or Bioconductor: just provide the package name as an argument\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  pak::pkg_install(\"tidyverse\")\n  ```\n  :::\n\n\n\n- from Github: provide the package name in the form of `user/repo`.\n  You can also nominate a specific branch (`user/repo@branch`) or tag\n  (`user/repo@tag`).\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  pak::pkg_install(\"tidyverse/dplyr\")\n  ```\n  :::\n\n\n\nSimilarly, `pak::pkg_install()` can be used for package updating. If\nthe package has not yet been installed, the package will be installed,\nyet if the package has already been installed, then it will instead be\nupdated (unless it is already the most up to date version).\n\nIf the `upgrade = TRUE` argument is supplied, then all the\ndependencies will also be updated.\n\n### Removing packages\n\nPackage can be removed using the `pak::pkg_remove()` function.\n\n## Namespaces\n\nEarly on in this tutorial, I presented a set of rules and\nrecommendations for object naming. One recommendation that I stressed\nwas to avoid using names for objects that are the names of common\nfunctions (like `mean`) so as to (hopefully) avoid conflicting with\nany of the functions built in to R.\n\nHaving made these recommendations, I will now say that R is not overly\nfragile and is sufficiently cleaver to enable it to resolve many\nnaming conflicts. Object names are context specific (see also object\noverloading above).\n\nWhen the name of an object is supplied that could be used to refer to\nmultiple objects (for example, if you had created an object called\nmean there would be two objects named mean - your object and the\ninbuilt function), R first attempts to determine which object you are\nlikely to have been referring to.\n\nObjects are defined and apply within certain contexts or _namespaces_.\nNamespaces defined the context (environment) in which an object is\navailable. Objects created within functions, remain local to those\nfunctions. Hence if an object is created within a function, it is not\navailable outside that function.\n\nThe namespace provides a context in which R should look for an object\n(such as a function). Functions defined within packages are available\nfor use, when the library is loaded. This is essentially adding the\nlibraries namespace to the list of contexts to that R should search\nwithin when you confront it with an expression.\n\nAlternatively, we can prefix the function name with the package name\n(its namespace) thereby explicitly indicating the context in which the\nfunction is defined and thus, the function will be found.\n\nFor example, lets say we wanted to create sparse diagonal matrix (a\nmatrix with values in the diagonals and blanks in the off diagonals.\nThere is a function called `Diagonal` in the `Matrix` package. We could\nexpose this function (and all others in the package via the library\nfunction or we could just prefix the function name with the package\nname.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## call the Diagonal function (however it wont be found)\nDiagonal(3)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in Diagonal(3): could not find function \"Diagonal\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## call the diagonal function from the Matrix package\nMatrix::Diagonal(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3 x 3 diagonal matrix of class \"ddiMatrix\"\n     [,1] [,2] [,3]\n[1,]    1    .    .\n[2,]    .    1    .\n[3,]    .    .    1\n```\n\n\n:::\n:::\n\n\n\nSimilarly, prefixing the namespace to the function name allows us to\nexplicitly nominate exactly which function we want to use in the event\nthat there are two functions of the same name in different packages.\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}