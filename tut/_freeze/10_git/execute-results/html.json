{
  "hash": "2f0dec80de9367cb3ff7a548b7091e47",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Git and version control\nauthor: \"Murray Logan\"\ndate: \"19 July, 2024\"\nformat: \n  html:\n    toc: true\n    toc-float: true\n    page-layout: full\n    number-sections: true\n    number-depth: 3\n    embed-resources: true\n    code-fold: false\n    code-tools: true\n    code-summary: \"Show the code\"\n    code-line-numbers: true\n    code-block-border-left: \"#ccc\"\n    code-copy: true\n    highlight-style: atom-one\n    theme: [default, ../resources/tut-style.scss]\n    css: ../resources/tut-style.css\ncrossref:\n  fig-title: '**Figure**'\n  fig-labels: arabic\n  tbl-title: '**Table**'\n  tbl-labels: arabic\nengine: knitr\nbibliography: ../resources/references.bib\noutput_dir: \"docs\"\n---\n\n\n\n\n \n\n\n\n::: {.newsbox}\n\n**Other useful tutorials or resources**\n\n- [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)\n- [https://www.atlassian.com/git/tutorials](https://www.atlassian.com/git/tutorials)\n- [https://marklodato.github.io/visual-git-guide/index-en.html](https://marklodato.github.io/visual-git-guide/index-en.html)\n- [https://git-scm.com/docs/gittutorial](https://git-scm.com/docs/gittutorial)\n- [https://marklodato.github.io/visual-git-guide/index-en.html](https://marklodato.github.io/visual-git-guide/index-en.html)\n- [https://try.github.io/levels/1/challenges/1](https://try.github.io/levels/1/challenges/1)\n- [https://onlywei.github.io/explain-git-with-d3/](https://onlywei.github.io/explain-git-with-d3/)\n- [http://git-school.github.io/visualizing-git/](http://git-school.github.io/visualizing-git/)\n- [https://github.com/sensorflo/git-draw](https://github.com/sensorflo/git-draw)\n:::\n\n\nThis tutorial will take a modular approach. The first section will\nprovide an overview of the basic concepts of git. The second section\nwill provide a quick overview of basic usage and the third and final\nsection will cover intermediate level usage. In an attempt to ease\nunderstanding, the tutorial will blend together git commands and\noutput, schematic diagrams and commentary in an attempt to ease\nunderstanding.\n\nThe following table surves as both a key and overview of the most\ncommon actions and git 'verbs'.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n<table class= \"table-sm table-borderless\" style='border-spacing:20px;'>\n<tr>\n<td>\n<a href=\"#Initialize\">Initialize git</a><br>\n![](10_git_files/figure-html/Fig0-1.png)\n</td>\n<td width='40%'>\n`git init`\n</td>\n<td>\nEstablish a git repository (within the current path if no path provided)\n</td>\n</tr>\n<tr>\n<td>\n<a href=\"#Commit\">Staging</a><br> \n    ![](10_git_files/figure-html/Fig1-1.png)\n</td>\n<td>\n`git add <file>`<br>\nwhere `file` is one or more files to stage\n</td>\n<td>\nStaging is indicating which files and their states are to be included in the next commit.\n</td>\n</tr>\n\n<tr>\n<td>\n<a href=\"#Commit\">Committing</a><br>\n    ![](10_git_files/figure-html/Fig2-1.png)\n</td>\n<td>\n`git commit -m \"<Commit message>\"`<br>\nwhere `<Commit message>` is a message to accompany the commit\n</td>\n<td>\nCommiting generates a 'snapshot' of the file system.\n</td>\n</tr>\n<tr>\n  <td>\n    <a href=\"#checkout\">Checkout</a><br>\n    ![](10_git_files/figure-html/Fig3a-1.png)\n  </td>\n  <td>\n    `git checkout \"<commit>\"`<br>\n    where `<commit>` is a reference to a commit to be reviewed\n  </td>\n  <td>\n    Explore the state associated with a specific commit\n  </td>\n</tr>\n<tr>\n  <td>\n    <a href=\"#reset\">Reset</a><br>\n    <!-- <img src=\"10_git_files/figure-html/Fig3b-1.png\" class=\"\" alt=\"\"  style=\"transform: scale(0.2);\"/> -->\n    ![](10_git_files/figure-html/Fig3b-1.png)\n  </td>\n  <td>\n    `git reset --hard \"<commit>\"`<br>\n    where `<commit>` is a reference to a commit\n  </td>\n  <td>\n    Return to a previous state, effectively erasing subsequent commits..\n  </td>\n</tr>\n<tr>\n  <td>\n    <a href=\"#revert\">Revert</a><br>\n    ![](10_git_files/figure-html/Fig3c-1.png)\n  </td>\n  <td>\n    `git revert \"<commit>\"`<br>\n    where `<commit>` is a reference to a commit that should be nullified (inverted)\n  </td>\n  <td>\n    Generate a new commit that reverses the changes introduced by a commit thereby effectively rolling back to a previous state (the one prior to the nominated commit) whilst still maintaining full commit history.\n  </td>\n</tr>\n\n<tr>\n  <td>\n    <a href=\"#Branching\">Branching</a><br>\n    ![](10_git_files/figure-html/Fig4-1.png)\n  </td>\n  <td>\n    `git branch <name>`<br>\n    `git checkout <name>`<br>\n    where `<name>` is a reference to a branch name (e.g. 'Feature')\n  </td>\n  <td>\n    Take edits in the project in a new direction to allow for modifications that will\n    not affect the main (master) branch.\n  </td>\n</tr>\n\n<tr>\n  <td>\n    <a href=\"#Merging\">Merging</a><br>\n    ![](10_git_files/figure-html/Fig5-1.png)\n  </td>\n   <td>\n     `git checkout master`<br>\n     `git branch <name>`<br>\n     where `<name>` is a reference to a branch name (e.g. 'Feature') that\n     is to be merged back into `master`.\n  </td>\n  <td>\n    Incorporate changes in a branch into another branch (typically `master`).\n  </td>\n</tr>\n\n<tr>\n  <td>\n    <a href=\"#rebase\">Rebasing</a><br>\n    ![](10_git_files/figure-html/Fig6a-1.png)\n  </td>\n   <td>\n     `git rebase -i HEAD~<number>`<br>\n     where `<number>` is the number of previous commits to\n     squash together with head.\n  </td>\n  <td>\n    Combine multiple commits together into a single larger commit.\n  </td>\n</tr>\n\n<tr>\n  <td>\n    <a href=\"#Pulling\">Pulling</a><br>\n    ![](10_git_files/figure-html/Fig5b-1.png)\n  </td>\n   <td>\n     `git pull -u <remote> <branch>`<br>\n     where `<remote>` is the name of the remote (typically `origin`)\n     and `<branch>` is the branch to sync with remote (typically `master`).\n  </td>\n  <td>\n    Pull changes from a branch of a remote repository.\n  </td>\n</tr>\n\n<tr>\n  <td>\n    <a href=\"#Pushing\">Pushing</a><br>\n    ![](10_git_files/figure-html/Fig5a-1.png)\n  </td>\n   <td>\n     `git push -u <remote> <branch>`<br>\n     where `<remote>` is the name of the remote (typically `origin`)\n     and `<branch>` is the branch to sync with remote (typically `master`).\n  </td>\n  <td>\n    Push changes up to a branch of a remote repository.\n  </td>\n</tr>\n</table>\n\n\n# Context\n\n\nGit is a distributed versioning system. This means that the complete\ncontents and history of a repository (in simplistic terms a repository\nis a collection of files and associated metadata) can be completely\nduplicated across multiple locations.\n\nNo doubt you have previously been working on a file (could be a\ndocument, spreadsheet, script or any other type of file) and got to a\npoint where you have thought that you are starting to make edits that\nsubstantially change the file and therefore have considered saving the\nnew file with a new name that indicates that it is a new version.\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig10-1.png){width=672}\n:::\n:::\n\n\n\nIn the above diagram, new content is indicated in red and\nmodifications in blue.\n\nWhist this approach is ok, it is fairly limited and unsophisticated\napproach to versioning (keeping multiple versions of a file). Firstly,\nif you edit this file over many sessions and each time save with a\ndifferent name, it becomes very difficult to either keep tract of what\nchanges are associated with each version of the file, or the order in\nwhich the changes were made. This is massively compounded if a project\ncomprises multiple files or has multiple authors.\n\nInstead, imagine a system in which you could take a snapshot of state\nof your files and also provide a description outlining what changes\nyou have made. Now imagine that the system was able to store and keep\ntrack of a succession of such versions in such a way that allows you\nto roll back to any previous versions of the files and exchange the\nentire history of changes with others collaborators - that is the\npurpose of git.\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig11-1.png){width=672}\n:::\n:::\n\n\n\nIn the above diagram (which I must point out is **not actually how\ngit works**), you can see that we are keeping track of multiple\ndocuments and potentially multiple changes within each document. What\nconstitutes a version (as in how many changes and to what files) is\ncompletely arbitrary. Each individual edit can define a separate\nversion.\n\nOne of the issues with the above system is that there is a lot of\nredundancy. With each new version an addition copy of the project's\nentire filesystem (all its files) must be stored. In the above case,\nVersion 2 and 3 both contain identical copies of\n`fileA.doc`. Is there a way of reducing the required size\nof the snapshots by only keeping copies of those that have actually\nchanged? **this is what git achieves**. Git versions (or snapshots\nknown as _commits_) store files that have changed since the\nprevious and files that have not changed are only represented by links\nto instances of these files within previous snapshots.\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig12-1.png){width=672}\n:::\n:::\n\n\n\nNow consider the following:\n\n- You might have noticed that a new version can comprise multiple\n  changes across multiple files. However, what if we have made\n  numerous changes to numerous files over the course of an editing\n  session (perhaps simultaneously addressing multiple different\n  editing suggestions at a time), yet we did not want to lump all of\n  these changes together into a single save point (snapshot). For\n  example, the multiple changes might constitute addressing three\n  independent issues, so although all edits were made simultaneously,\n  we wish to record and describe the changes in three separate\n  snapshots.\n\n - What if this project had multiple contributors some of whom are\n   working on new components of the project and some whom are working\n   simultaneously on the same set of files? How can the system ensure\n   that all contributors are in sync with each other and that new\n   components are only introduced to the project proper once they are\n   stable and agreed upon?\n\n- What if there are files present within our project that we do not\n  wish to keep track of. These files could be log files, compilation\n  intermediates etc.\n\n- Given that projects can comprise many files (some of which can be\n  large), is it possible to store compressed files so as to reduce the\n  storage and bandwidth burden?\n\t\t \n# Overview of git\n\nThe above discussion provides context for understanding how git works.\nWithin git, files can exist in one of four states:\n\n- **untracked** - these are files within the directory tree that are\n  not to be included in the repository (not part of any snapshot)\n- **modified** - these are files that have changed since the last\n  snapshot\n- **staged** - these are files that are nominated to be part of the\n  next snapshot\n- **committed** - these are files that are represented in a stored\n  snapshot (called a _commit_). One a snapshot is committed, it is a\n  permanent part of the repositories history\n\nSince untracked files are not part of a repository, we will ignore\nthese for now.\n\nConceptually, there are three main sections of a repository:\n\n- **Working directory** - (or **Workspace**) is the obvious tree (set\n  of files and folders) that is present on disc and comprises the\n  actual files that you directly create, edit etc.\n- **Staging area** - (or **index**) is a hidden file that contains\n  metadata about the files to be included in the next snapshot\n  (commit)\n- **Repository** - the snapshots (commits). The commits are themselves\n  just additional metadata pointing to a particular snapshot.\n\nA superficial representation of some aspects of the git version\ncontrol system follows. Here, the physical file tree in the\n_workspace_ can be added to the _staging area_ before this snapshot\ncan be committed to the _local repository_.\n\nAfter we add the two files (`file 1` and `file 2`), both files will be\nconsidered in an _untracked_ state. Adding the files to the _staging\narea_ changes their state to _staged_. Finally when we commit, the\nfiles are in a _committed_ state.\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig13-1.png){width=672}\n:::\n:::\n\n\n \n\nNow if we add another file (`file 3`) to our\n_workspace_, add this file to the _staging area_ and then\ncommit the change, the resulting committed snapshot in the _local\nrepository_ will resemble the _workspace_. Note, although the\n_staging area_ contains all three files, only `file 3`\npoints to any new internal content - since `file 1` and\n`file 2` have unmodified, their instances in the _staging\narea_ point to the same instances as previous. Similarly, the\nsecond commit in the _Local repository_ will point to one new\nrepresentation (associated with `file 3`) and two previous\nrepresentations (associated with `file 1` and `file\n2`).\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig14-1.png){width=672}\n:::\n:::\n\n\n\nInitially, it might seem that there is an awful lot of duplication\ngoing on. For example, if we make a minor alteration to a file, why\nnot just commit the change (delta) instead of an entirely new copy?\nWell, periodically, git will perform **garbage collection** on the\nrepository. This process **repacks** the objects together into a\nsingle object that comprises only the original blobs and their\nsubsequent deltas - thereby gaining efficiency. The process of garbage\ncollection can also be forced at any time via:\n\n\n\n::: {.cell .bash highlight-style='zenburn'}\n\n```{.bash .cell-code}\ngit gc\n```\n:::\n\n\n\nDuring the evolution of most projects, situations arise in which we\nwish to start work on new components or features that might represent\na substantial deviation from the main line of evolution. Often, we\nwould very much like to be able to quarantine the main thread of the\nproject from these new developments. For example, we may wish to be\nable to continue tweaking the main project files (in order to address\nminor issues and bugs), while at the same time, performing major edits\nthat take the project in a different direction.\n\nThis is called _branching_. The main evolutionary thread of the\nproject is referred to as the **main** _branch_. Deviations\nfrom the _main branch_ are generally called **branches** and\ncan be given any name (other than 'main' or 'HEAD'). For example, we\ncould start a new _branch_ called 'Feature' where we can evolve\nthe project in one direction whilst still being able to actively\ndevelop the _main branch_ at the same time. 'Feature' and\n'main' _branches_ are depicted in the left hand sequence of\ncircles of the schematic below.\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig-overview-1.png){width=672}\n:::\n:::\n\n\n\nThe circles represent **commits** (stored snapshots). We can see that\nthe first commit is the common ancestor of the 'Feature' and 'main'\n_branch_. **HEAD** is a special reference that points to the _tip_ of\nthe currently active _commit_. It indicates where the next _commit_\nwill be built onto. In diagram above, `HEAD` is pointing to the last\n_commit_ in `main`. Hence the next _commit_ will build on this\n_commit_. To develop the `Feature` _branch_ further, we first have to\nmove `HEAD` to the tip of the `Feature` _branch_.\n\nWe can later `merge` the `Feature` _branch_ into the `main` _branch_\nin order to make the new changes mainstream.\n\nTo support collaboration, there can also be a _remote repository_\n(referred to as **origin** and depicted by the squares in the figure\nabove). Unlike a _local repository_, a _remote repository_ does not\ncontain a _workspace_ as files are not directly edited in the _remote\nrepository_. Instead, the _remote repository_ acts as a permanently\navailable conduit between multiple contributors.\n\nIn the diagram above, we can see that the _remote repository_\n(`origin`) has an additional _branch_ (in this called `dev`). The\ncollaborator whose _local repository_ is depicted above has either not\nyet obtained (**pulled**) this _branch_ or has elected not to (as\nperhaps it is not a direction that they are involved in).\n\nWe also see that the `main` _branch_ on the _remote repository_ has a\nnewer (additional) _commit_ than the _local repository_.\n\nPrior to working on _branch_ a collaborator should first get any\nupdates to the _remote repository_. This is a two step process.\nFirstly, the collaborator **fetches** any changes and then secondly\n**merges** those changes into their version of the _branch_.\nCollectively, these two actions are called a **pull**.\n\nTo make local changes available to others, the collaborator can\n**push** _commits_ up to the _remote repository_. The _pushed_ changes\nare applied directly to the nominated _branch_ so it is the users\nresponsibility to ensure as much as possible, their local repository\nalready included the most recent _remote repository_ changes (by\nalways _pulling_ before _pushing_).\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig-git-1.png){width=672}\n:::\n:::\n\n\n\n# Installation\n\n::: panel-tabset \n\n## Windows\n\nGit Bash (Command Line Version):\n\n1. Download the Git for Windows installer from [Git for Windows](https://gitforwindows.org/)\n   - Click the Download button\n   - Select the latest version from the list of `Assets`\n2. Run the installer and follow the installation prompts.\n3. Choose the default options unless you have specific preferences.\n4. Select the default text editor (usually Vim) or choose another\n   editor like Nano or Notepad++.\n5. Choose to use Git from the Windows Command Prompt (recommended).\n6. Complete the installation.\n\n## MacOSx\n\nUsing Homebrew:\n\n1. Open Terminal.\n2. Install Homebrew if not installed:\n\n:::: {.indented}\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n:::\n\n\n:::\n\n3. Install Git using Homebrew:\n\n:::: {.indented}\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nbrew install git\n```\n:::\n\n\n::::\n\n## Linux\n\n1. Open Terminal.\n\n:::: {.indented}\nUbuntu/Debian:\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nsudo apt update\nsudo apt install git\n```\n:::\n\n\n::::\n\n:::: {.indented}\nFedora:\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nsudo dnf install git\n```\n:::\n\n\n::::\n\n:::: {.indented}\nArch Linux:\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nsudo pacman -S git\n```\n:::\n\n\n::::\n\n:::: {.indented}\nLinux (Red Hat/CentOS):\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nsudo yum install git\n```\n:::\n\n\n::::\n:::\n\n\nTo verify that the software is installed and accessible, open a\nterminal and issue the following:\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit --version\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ngit version 2.45.2\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## Unsure how to open a terminal?\n\n**Windows:**\n\nOn Windows, you can access a terminal via one of the following: \n\n- via the command Prompt:\n  - Press `Win + R` to open the Run dialog.\n  - Type `cmd` and press `Enter`.\n\n- via PowerShell:\n  - Press `Win + X` and select \"Windows PowerShell.\"\n\n- Git Bash (Optional):\n  - if Git is installed (which we are hoping it is!), open \"Git Bash\" for a Unix-like terminal experience.\n\n**MacOS:**\n\n- via Terminal:\n  - Press `Cmd + Space` to open Spotlight.\n  - Type `terminal` and press `Enter`.\n\n**Linux:**\n\nOh please. You cannot seriously tell me that you are using Linux and\ndon't know how to access a terminal.\n:::\n\nIn the command above, pay particular attention to the number of\nhyphens in the above command - there are two in a row and no spaces\nbetween the `--` and the word `version`.\n\nIf you get output similar to above (an indication of what version of\ngit you have on your system), then it is likely to be properly\ninstalled. If instead you get an error message, then it is likely that\ngit is not properly installed and you should try again.\n\n# Getting started\n\n\nBefore using git, it is a good idea to define some global (applied to\nall your gits) settings. These include your name and email address and\nwhilst not essential, they are applied to all actions you perform so\nthe it is easier for others to track the route of changes etc.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your_email@whatever.com\"\n```\n:::\n\n\n\n::: {.callout-note}\nIn the above, you should replace \"Your Name\" with your actual name.\nThis need not be a username (or even a real name) it is not cross\nreferenced anywhere. It is simply to use in collaboration so that your\ncollaborators know who is responsible for your commits.\n\nSimilarly, you should replace \"your_email@whatever.com\" with an email\nthat you are likely to monitor. This need not be the same email\naddress you have used to register a Github account etc, it is just so\nthat collaborators have a way of contacting you.\n:::\n\n\nThe remaining sections go through the major git versioning concepts.\nAs previously indicated, git is a command driven program (technically\na family of programs). Nevertheless, many other applications (such as\nRStudio) are able to interface directly with git for some of the more\ncommonly used features. Hence, in addition to providing the command\nline syntax for performing each task, where possible, this tutorial\nwill also provide instructions (with screen captures) for RStudio and\nemacs.\n\n# Setting up (initializing) a new repository\n\nFor the purpose of this tutorial, I will create a temporary folder the\n`tmp` _folder_ of my `home` _directory_ into which to create and\nmanipulate repositories. To follow along with this tutorial, you are\nencouraged to do similarly.\n\n\n## Initialize local repository\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/Fig1a-1.png)\n\n::: {.panel-tabset}\n\n## Terminal\n\nWe will start by creating a new directory (folder) which we will call\n`Repo1` in which to place our repository. All usual directory naming\nrules apply since it is just a regular directory.\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nmkdir ~/tmp/Repo1\n```\n:::\n\n\n\nTo create (or initialize) a new local repository, issue the `git\ninit` _command_ in the root of the working directory you\nwish to contain the git repository. This can be either an empty\ndirectory or contain an existing directory/file structure. The\n`git init` _command_ will add a folder called\n`.git` to the directory. <b>This is a one time\noperation</b>.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ncd ~/tmp/Repo1\ngit init \n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitialized empty Git repository in /home/runner/tmp/Repo1/.git/\n```\n\n\n:::\n:::\n\n\n\nThe `.git` _folder_ contains all the necessary\n_metadata_ to manage the repository.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nls -al\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntotal 12\ndrwxr-xr-x 3 runner docker 4096 Jul 19 03:19 .\ndrwxr-xr-x 3 runner docker 4096 Jul 19 03:19 ..\ndrwxr-xr-x 7 runner docker 4096 Jul 19 03:19 .git\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ntree -a --charset unicode\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n`-- .git\n    |-- HEAD\n    |-- branches\n    |-- config\n    |-- description\n    |-- hooks\n    |   |-- applypatch-msg.sample\n    |   |-- commit-msg.sample\n    |   |-- fsmonitor-watchman.sample\n    |   |-- post-update.sample\n    |   |-- pre-applypatch.sample\n    |   |-- pre-commit.sample\n    |   |-- pre-merge-commit.sample\n    |   |-- pre-push.sample\n    |   |-- pre-rebase.sample\n    |   |-- pre-receive.sample\n    |   |-- prepare-commit-msg.sample\n    |   |-- push-to-checkout.sample\n    |   |-- sendemail-validate.sample\n    |   `-- update.sample\n    |-- info\n    |   `-- exclude\n    |-- objects\n    |   |-- info\n    |   `-- pack\n    `-- refs\n        |-- heads\n        `-- tags\n\n10 directories, 18 files\n```\n\n\n:::\n:::\n\n\n\nconfig\n: this file stores settings such as the location of a remote\n  repository that this repository is linked to.\n\ndescription\n: lists the name (and version) of a repository\n\nHEAD\n: lists a reference to the current checked out commit.\n\nhooks\n: a directory containing scripts that are executed at various stages\n  (e.g. `pre-push.sample` is an example of a script executed prior to\n  pushing)\n\ninfo\n: contains a file `exclude` that lists exclusions (files not to be\n  tracked). This is like `.gitignore`, except is not versioned.\n\nobjects\n: this directory contains SHA indexed files being tracked\n\nrefs\n: a master copy of all the repository refs\n\nlogs\n: contains a history of each branch\n\n## RStudio\n\nThe repository that we are going to create in this demonstration could\nbe considered to be a new standalone analysis. In Rstudio, this would\nbe considered a **project**. So, we will initialise the git repository\nwhile we create a new Rstudio project.  To do so:\n\n1. click on the `Project` selector in the top right of the Rstudio\n   window (as highlighted by the red ellipse in the image below.\n\n   ![](../resources/rstudio_init1a.png){width=100%}\n\n2. select `New Project` from the dropdown menu\n3. select `New Directory` form the Create Project panel\n4. select `New Project` from the Project Type panel\n5. Provide a name for the new directory to be created and use the\n   `Browse` button to locate a suitable position for this new\n   directory. **Ensure that the `Create a git repository` checkbox is\n   checked**\n\n   ![](../resources/rstudio_init2.png){width=50%}\n6. Click the `Create Project` button\n\nIf successful, you should notice a couple of changes - these are\nhighlighted in the following figure:\n\n![](../resources/rstudio_init3a.png){width=60%}\n\n- a new `Git` tab will appear in the top right panel\n- the contents of this newly created project/repository will appear in\n  the `Files` tab of the bottom right panel\n  \nIf the files and directories that begin with a `.` do not appear,\nclick on the `More file commands` cog and make sure the `Show Hidden\nFiles` option is ticked.\n\nThe newly created files/folders are:\n\n- `.git` - this directory houses the repository information and should\n  not generally be edited directly\n- `.gitignore` - this file defines files/folders to be excluded from\n  the repository. We will discuss this file more later\n- `.Rhistory` - this file will accrue a history of the commands you\n  have evaluated in R within this project\n- `.Rproj.user` - this folder stores some project-specific temporary\n  files\n- `Repo1.Rproj` - contains the project specific settings\n\n**Note that on the left side of the Rstudio window there are two\npanels - one called \"Console\", the other called \"Terminal\". The\nconsole window is for issuing R commands and the terminal window is\nfor issuing system (bash, shell) commands. Throughout this tutorial,\nas an alternative to using the point and click Rstudio methods, you\ncould instead issue the `Terminal` instructions into the \"Terminal\"\npanel. Indeed, there are some git commands that are not supported\ndirectly by Rstudio and can only be entered into the terminal**\n\n## Emacs (magit)\n\n:::\n\n\nNote, at this stage, no files are being tracked, that is, they are not\npart of the repository.\n\nTo assist in gaining a greater understanding of the workings of git,\nwe will use a series of schematics diagrams representing the contents\nof four important sections of the repository. Typically, these figures\nwill be contained within callout panels that expand/collapse upon\nclicking.  However, for this first time, they will be standalone.\n\nIn the first figure below, the left hand panel represents the contents\nof the root directory (excluding the `.git` folder) - this is the\n_workspace_ and is currently empty.\n\nThe three white panels represent three important parts of the inner\nstructure of the `.git` folder. A newly initialized repository is\nrelatively devoid of any specific metadata since there are no staged\nor committed files. In the root of the `.git` folder, there is a file\ncalled `HEAD`.\n\nThe figure is currently very sparse. However, as the repository grows,\nso the figure will become more complex.\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig-advanced1-1.png){width=672}\n:::\n:::\n\n\n\nThe second figure provides the same information, yet via a network\ndiagram. Again, this will not be overly meaningful until the\nrepository contains some content.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit1.png)\n\n## Initializing other types of repositories\n\nThe above demonstrated how to initialise a new local repository from\nscratch.  However, there are times when we instead want to:\n\n- create a git repository from an existing directory or project\n- collaborate with someone on an existing repository\n- create a remote repository\n\nThese situations are briefly demonstrated in the following sections.\n\n### Initializing a shared (remote) repository\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/Fig1b-1.png)\n\nThe main repository for sharing should not contain the working\ndirectory as such - only the `.git` tree and the\n`.gitignore` file. Typically the point of a remote\nrepository is to act as a perminantly available repository from which\nmultiple uses can exchange files. Consequently, those accessing this\nrepository should only be able to interact with the .git\n_metadata_ - they do not directly modify any files.\n\nSince a remote repository is devode of the working files and\ndirectories, it is referred to as _bare_. \n\n::: {.panel-tabset}\n\n#### Terminal\nTo create a _bare_ remote repository, issue the `git init --bare`\n_command_ after logging in to the remote location.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit init --bare\n```\n:::\n\n\n\n#### Rstudio\n\nUse the instructions for the `Terminal`\n\n:::\n\n\n### Cloning an existing repository\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/Fig1c-1.png)\n\nTo get your own local copy of an existing repository, issue the `git\nclone <repo url>` _command_ in the root of the working directory you\nwish to contain the git repository. The `repo url` points to the\nlocation of the existing repository to be cloned. This is also a **one\ntime operation** and should be issued in an otherwise empty directory.\n\nThe `repo url` can be located on any accessible filesytem (local or\nremote). The cloning process also stores a link back to the original\nlocation of the repository (called **origin**). This provides a\nconvenient way for the system to keep track of where the local\nrepository should exchange files.\n\nMany git repositories are hosted on sites such as github, gitlab or\nbitbucket. Within an online git repository, these sites provide url\nlinks for cloning.\n\n::: {.panel-tabset}\n\n#### Terminal\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit clone \"url.git\"\n```\n:::\n\n\n\nwhere `\"url.git\"` is the url of the hosted repository.\n\n#### Rstudio\n\n1. click on the `Project` selector in the top right of the Rstudio\n   window (as highlighted by the red ellipse in the image below.\n2. select `New Project` from the dropdown menu\n3. select `Version Control` form the Create Project panel\n4. select `Git` from the Create Project from Version Control panel\n5. paste in the address of the repository that you want to clone,\n   optionally a name for this repository (if you do not like the\n   original name) and use the `Browse` button to locate a suitable\n   position for this new directory.\n6. Click the `Create Project` button\n:::\n\n### Initializing a repository in an existing directory\n\n::: {.panel-tabset}\n\n#### Terminal\n\nThis is the same as for a new directory.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit init\n```\n:::\n\n\n#### Rstudio\n\n1. click on the `Project` selector in the top right of the Rstudio\n   window (as highlighted by the red ellipse in the image below.\n2. select `New Project` from the dropdown menu\n3. select `Existing Directory` form the Create Project panel\n4. use the `Browse` button to locate the existing directory\n6. Click the `Create Project` button\n:::\n\n\n# Tracking files\n\nThe basic workflow for tracking files is a two step process in which\none or more files are first added to the **staging area** before\nthey are committed to the **local repository**. The staging area\nacts as a little like a snapshot of what the repository will look like\nonce the changes have been committed. The staging area also acts like\na buffer between the files in the workspace (actual local copy of\nfiles) and the local repository (committed changes).\n\nThe reason that this is a two step process is that it allows the user\nto make edits to numerous files, yet block the commits in smaller\nchunks to help isolate changes in case there is a need to roll back to\nprevious versions.\n\n## Staging files\n\nWhen a file is first added to the staging area, a full copy of that\nfile is added to the staging area (not just the file diffs as in other\nversioning systems).\n\n::: {.panel-tabset}\n\n### Terminal\n\nTo demonstrate lets create a file (a simple text file containing the\nstring saying 'File 1') and add it to the staging area.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\necho 'File 1' > file1\n```\n:::\n\n\n\nNow lets add this file to the staging area\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit add file1\n```\n:::\n\n\n\nTo see the status of the repository (that is, what files are being\ntracked), we issue the `git status` _command_\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\tnew file:   file1\n```\n\n\n:::\n:::\n\n\n\nThis indicates that there is a single file (`file1`) in the\nstaging area\n\n\n### Rstudio\n\nTo demonstrate lets create a file (a simple text file containing the\nstring saying 'File 1') and add it to the staging area.\n\n1. Click the green \"New File\" button followed by the \"Text File\"\n    option (or click the equivalent option from the \"File\" menu)\n    ![](../resources/rstudio_status1.png){width=50%}\n\n2. Type `File 1` in the panel with the flashing cursor. This panel\n   represents the contents of the yet to be named file that we are\n   creating.\n\n    ![](../resources/rstudio_status2.png){width=50%}\n\n3. Click the \"Save\" or \"Save all\" buttons (or select the equivalent\n   items from the \"File\" menu) and name the file \"file1\"\n\n    Switch to the `Git` tab and you should notice a number of items\n    (including the file we just created) in the panel. These are files\n    that git is aware of, but not yet tracking. This panel acts as a\n    status window. The yellow \"?\" symbol indicates that git considers\n    these files \"untracked\"\n\n    ![](../resources/rstudio_status3.png){width=50%}\n\n4. To stage a file, click on the corresponding checkbox - the status\n   symbol should change to a green \"A\" (for added)\n   \n   ![](../resources/rstudio_status4.png){width=50%}\n   \n:::\n\nOur simple overview schematic represents the staging of file 1.\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig-advanced2a-1.png){width=672}\n:::\n:::\n\n\n\nA schematic of the internal working of git shows in\n`.git/objects` a **blob** has been created. This is a\ncompressed version of `file1`. Its filename is a 40 digit\n**SHA-1 checksum** has representing the contents of the\n`file1`. To re-iterate, the blob name is a SHA-1 hash of\nthe file contents (actually, the first two digits form a folder and\nthe remaining 38 form the filename).\n\nWe can look at the contents of this _blob_ using the `git\ncat-file` _command_. This command outputs the contents of a\ncompressed _object_ (_blob_, _tree_, _commit_)\nfrom either the objects name (or unique fraction thereof) or its\n_tag_ (we will discuss tags later). \n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit cat-file blob 50fcd\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFile 1\n```\n\n\n:::\n:::\n\n\n\nThe add (staging) process also created a `index` file. This file\nsimply points to the _blob_ that is part of the snapshot. The git\ninternals schematic illustrates the internal changes in response to\nstaging a file.\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig-advanced2.png)\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the git\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit2.png)\n\n:::\n\n\n## Commit to local repository\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/Fig2a-1.png)\n\n\n::: {.panel-tabset}\n\n### Terminal\n\nTo commit a set of changes from the staging area to the local\nrepository, we issue the `git commit` _command_. We usually add the\n`-m` _switch_ to explicitly supply a message to be associated with the\ncommit. This message should ideally describe what the changes the\ncommit introduces to the repository.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit commit -m 'Initial repo and added file1'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[main (root-commit) 6088354] Initial repo and added file1\n 1 file changed, 1 insertion(+)\n create mode 100644 file1\n```\n\n\n:::\n:::\n\n\n\nWe now see that the status has changed. It indicates that the tree in\nthe workspace is in sync with the repository.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOn branch main\nnothing to commit, working tree clean\n```\n\n\n:::\n:::\n\n\n\n### Rstudio\n\nTo commit a set of changes from the staging area to the local\nrepository:\n\n1. click on the \"Commit\" button to open the \"Review Changes\" window\n\n   ![](../resources/rstudio_commit1.png){width=80%}\n\n   This box will list the files to be committed (in this case\n   \"file1\"), the changes in this file since the previous commit (as\n   this is the first time this file has been committed, the changes\n   are the file contents)\n   \n2. you should also provide a commit message (in the figure above, I\n   entered \"Initial commit\". This message should ideally describe what\n   the changes the commit introduces to the repository.\n3. click the \"Commit\" button and you will be presented with a popup\n   message.\n\n   ![](../resources/rstudio_commit2.png)\n   \n   This message provides feedback to confirm that your commit was\n   successful.  \n4. close the popup window and the \"Review Changes\" window\n\n`file1` should now have disappeared from the git status panel.\n:::\n\nOur simple overview schematic represents the staging of file 1.\n\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig-advanced3a-1.png){width=672}\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Additional details about the commit\n\nThe following modifications have occurred (in reverse order to how\nthey actually occur):\n\n- The **main** _branch_ reference was created. There is currently only\n  a single branch (more on branches later). The branch reference point\n  to (indicates) which commit is the current commit within a branch.\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  cat .git/refs/heads/main\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  6088354b376cb7c5567fa969c4dbb37eee98b250\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- A **commit** was created. This points to a **tree** (which itself\n  points to the blob representing `file1`) as well as other important\n  metadata (such as who made the commit and when). Since the time\n  stamp will be unique each time a snapshot is commited, so too the\n  name of the commit (as a SHA-1 checksum hash) will differ. **To\n  reiterate, the names of blobs and trees are determined by contents\n  alone, commit names are also incorporate commit timestamp and\n  details of the committer - and are thus virtually unique**.\n\n\n\n  ::: {.cell}\n  \n  :::\n\n  ::: {.cell .bash replace='true'}\n  \n  ```{.bash1 .cell-code}\n  git cat-file commit 60883\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  tree 07a941b332d756f9a8acc9fdaf58aab5c7a43f64\n  author pcinereus <i.obesulus@gmail.com> 1721359207 +0000\n  committer pcinereus <i.obesulus@gmail.com> 1721359207 +0000\n  \n  Initial repo and added file1\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- A **tree** object was created. This represents the directory tree of\n  the snapshot (commit) and thus points to the **blob**s.\n\n\n\n  ::: {.cell .bash replace='true'}\n  \n  ```{.bash1 .cell-code}\n  git ls-tree 60883\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  100644 blob 50fcd26d6ce3000f9d5f12904e80eccdc5685dd1\tfile1\n  ```\n  \n  \n  :::\n  :::\n\n\n  \n  Or most commonly (if interested in the latest commit):\n  \n\n\n  ::: {.cell .bash replace='false'}\n  \n  ```{.bash1 .cell-code}\n  git ls-tree HEAD\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  100644 blob 50fcd26d6ce3000f9d5f12904e80eccdc5685dd1\tfile1\n  ```\n  \n  \n  :::\n  :::\n\n\n::: \n\nThe schematic now looks like\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n  \n![](../resources/Fig-advanced3.png)\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the git\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit3.png)\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## More information about committing changes to the repository\nCommitting staged changes creates an object under the `.git` tree.\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -a --charset unicode\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- .git\n|   |-- COMMIT_EDITMSG\n|   |-- HEAD\n|   |-- branches\n|   |-- config\n|   |-- description\n|   |-- hooks\n|   |   |-- applypatch-msg.sample\n|   |   |-- commit-msg.sample\n|   |   |-- fsmonitor-watchman.sample\n|   |   |-- post-update.sample\n|   |   |-- pre-applypatch.sample\n|   |   |-- pre-commit.sample\n|   |   |-- pre-merge-commit.sample\n|   |   |-- pre-push.sample\n|   |   |-- pre-rebase.sample\n|   |   |-- pre-receive.sample\n|   |   |-- prepare-commit-msg.sample\n|   |   |-- push-to-checkout.sample\n|   |   |-- sendemail-validate.sample\n|   |   `-- update.sample\n|   |-- index\n|   |-- info\n|   |   `-- exclude\n|   |-- logs\n|   |   |-- HEAD\n|   |   `-- refs\n|   |       `-- heads\n|   |           `-- main\n|   |-- objects\n|   |   |-- 07\n|   |   |   `-- a941b332d756f9a8acc9fdaf58aab5c7a43f64\n|   |   |-- 50\n|   |   |   `-- fcd26d6ce3000f9d5f12904e80eccdc5685dd1\n|   |   |-- 60\n|   |   |   `-- 88354b376cb7c5567fa969c4dbb37eee98b250\n|   |   |-- info\n|   |   `-- pack\n|   `-- refs\n|       |-- heads\n|       |   `-- main\n|       `-- tags\n`-- file1\n\n16 directories, 27 files\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit cat-file -p HEAD\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntree 07a941b332d756f9a8acc9fdaf58aab5c7a43f64\nauthor pcinereus <i.obesulus@gmail.com> 1721359207 +0000\ncommitter pcinereus <i.obesulus@gmail.com> 1721359207 +0000\n\nInitial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit cat-file -p HEAD^{tree}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n100644 blob 50fcd26d6ce3000f9d5f12904e80eccdc5685dd1\tfile1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6088354 Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n## More changes\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/Fig2b-1.png)\n\nWhenever a file is added or modified, if the changes are to be\ntracked, the file needs to be added to the staging area. Lets\ndemonstrate by modifying `file1` and adding an additional\nfile (`file2`), this time to a subdirectory (`dir1`).\n\n::: {.panel-tabset}\n\n### Terminal\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\necho '---------------' >> file1\nmkdir dir1\necho '* Notes' > dir1/file2\ngit add file1 dir1/file2\n```\n:::\n\n\n\nNow if we re-examine the status:\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOn branch main\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tnew file:   dir1/file2\n\tmodified:   file1\n```\n\n\n:::\n:::\n\n\n\n### Rstudio\n\n1. modify `file1` by adding a number of hyphens under the `File 1`\n   like in the figure below\n   \n   ![](../resources/rstudio_commit3.png)\n\n2. save the file. As you do so, you should notice that the file\n   reappears in the status panel (this time with a blue \"M\" to signify\n   that the file has been modified)\n3. to create the subdirectory, click on the \"Add a new folder\" icon\n   and then enter a name for the subdirectory in the popup box (as per\n   figure below)\n   \n   ![](../resources/rstudio_commit4.png)\n   \n4. navigate to this new directory (`dir1`)\n5. click the \"Create a new blank file in current directory\" button and\n   select \"Text file\"\n6. enter a new filename (`file2`) into the popup box\n7. enter some text into this file (like in the figure below)\n\n   ![](../resources/rstudio_commit5.png)\n   \n8. save the file and notice that the `dir1` directory is now also in\n   the git status panel (yet its status is \"untracked\")\n9. stage both `file1` and `dir1` (click on the corresponding checkboxes)\n\n   ![](../resources/rstudio_commit6.png)\n:::\n\nAnd now our schematic looks like:\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n  \n![](../resources/Fig-advanced4.png)\n\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the git\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit4.png)\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## More information about staging changes to the repository\n\nSo when **staging**, the following has been performed:\n\n- the `index` file has been updated\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  git ls-files --stage\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  100644 4fcc8f85f738deb6cbb17db1ed3da241ad6cdf39 0\tdir1/file2\n  100644 28ed2456cbfa8a18a280c8af5b422e91e88ff64d 0\tfile1\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- two new _blobs_ have been generated. One representing the modified\n  `file1` and the other representing the newly created `file2` in the\n  `dir1` folder. The _blob_ that represented the original `file1`\n  contents is still present and indeed is still the one currently\n  committed. _Blobs_ are not erased or modified.\n\n:::\n\n\nNow we will commit this snapshot.\n\n::: {.panel-tabset}\n\n### Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit commit -m 'Modified file1 and added file2 (in dir1)'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[main 7a83e8d] Modified file1 and added file2 (in dir1)\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file2\n```\n\n\n:::\n:::\n\n\n\n### Rstudio\n\n1. click the \"Commit\" button\n2. you might like to explore the changes associated with each file\n3. enter a commit message (as in the figure below)\n\n   ![](../resources/rstudio_commit7.png)\n   \n4. click the \"Commit\" button\n5. after checking that the \"Git Commit\" popup does not contain any\n   errors, close the popup\n6. to explore the repository history, click towards the \"History\"\n   button on the top left corner of the \"Review Changes\" window\n\n   ![](../resources/rstudio_commit8.png)\n   \n   This provides a graphical list of commits (in reverse chronological\n   order)\n\n7. once you have finished exploring the history, you can close the\n   \"Review Changes\" window\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about changes to the repository\n\nThe following modifications occur:\n\n- the _master_ branch now points to the new _commit_.\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  cat .git/refs/heads/main\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  7a83e8d82106a4899408c425a9bf888efd28667b\n  ```\n  \n  \n  :::\n  :::\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  git reflog\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  7a83e8d HEAD@{0}: commit: Modified file1 and added file2 (in dir1)\n  6088354 HEAD@{1}: commit (initial): Initial repo and added file1\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- a new _commit_ was created. This points to a new root _tree_ object\n  and also points to the previous _commit_ (its _parent_).\n\n\n\n  ::: {.cell}\n  \n  :::\n\n  ::: {.cell .bash replace='true'}\n  \n  ```{.bash1 .cell-code}\n  git cat-file commit 7a83e\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  tree 2b61e2b3db9d1708269cf9d1aeaae2b0a2af1a23\n  parent 6088354b376cb7c5567fa969c4dbb37eee98b250\n  author pcinereus <i.obesulus@gmail.com> 1721359213 +0000\n  committer pcinereus <i.obesulus@gmail.com> 1721359213 +0000\n  \n  Modified file1 and added file2 (in dir1)\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- new root _tree_ was created. This points to a _blob_ representing\n  the modified `file1` as well as a newly created sub-directory _tree_\n  representing the `dir1` folder.\n\n\n\n  ::: {.cell .bash replace='true'}\n  \n  ```{.bash1 .cell-code}\n  git ls-tree 2b61e\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  040000 tree f2fa54609fe5e918f365e0d5ffaf9a3aea88d541\tdir1\n  100644 blob 28ed2456cbfa8a18a280c8af5b422e91e88ff64d\tfile1\n  ```\n  \n  \n  :::\n  :::\n\n  ::: {.cell .bash replace='true'}\n  \n  ```{.bash1 .cell-code}\n  git cat-file -p HEAD^{tree}\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  040000 tree f2fa54609fe5e918f365e0d5ffaf9a3aea88d541\tdir1\n  100644 blob 28ed2456cbfa8a18a280c8af5b422e91e88ff64d\tfile1\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- a new sub-directory root _tree_ was created. This points to a\n  _blob_ representing the modified `file1` as well as\n  a newly created subtree _tree_ representing the\n  `file2` file within the `dir1` folder.\n\n\n\n  ::: {.cell .bash replace='true'}\n  \n  ```{.bash1 .cell-code}\n  git ls-tree 7a83e\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  040000 tree f2fa54609fe5e918f365e0d5ffaf9a3aea88d541\tdir1\n  100644 blob 28ed2456cbfa8a18a280c8af5b422e91e88ff64d\tfile1\n  ```\n  \n  \n  :::\n  :::\n\n\n  \n  OR,\n  \n\n\n  ::: {.cell .bash replace='true'}\n  \n  ```{.bash1 .cell-code}\n  git ls-tree HEAD\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  040000 tree f2fa54609fe5e918f365e0d5ffaf9a3aea88d541\tdir1\n  100644 blob 28ed2456cbfa8a18a280c8af5b422e91e88ff64d\tfile1\n  ```\n  \n  \n  :::\n  :::\n\n\n\n:::\n\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n  \n![](../resources/Fig-advanced5.png)\n\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the git\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit5.png){width=100%}\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## More information about committing changes to the repository\nCommitting staged changes creates an object under the `.git` tree.\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -a --charset unicode\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- .git\n|   |-- COMMIT_EDITMSG\n|   |-- HEAD\n|   |-- branches\n|   |-- config\n|   |-- description\n|   |-- hooks\n|   |   |-- applypatch-msg.sample\n|   |   |-- commit-msg.sample\n|   |   |-- fsmonitor-watchman.sample\n|   |   |-- post-update.sample\n|   |   |-- pre-applypatch.sample\n|   |   |-- pre-commit.sample\n|   |   |-- pre-merge-commit.sample\n|   |   |-- pre-push.sample\n|   |   |-- pre-rebase.sample\n|   |   |-- pre-receive.sample\n|   |   |-- prepare-commit-msg.sample\n|   |   |-- push-to-checkout.sample\n|   |   |-- sendemail-validate.sample\n|   |   `-- update.sample\n|   |-- index\n|   |-- info\n|   |   `-- exclude\n|   |-- logs\n|   |   |-- HEAD\n|   |   `-- refs\n|   |       `-- heads\n|   |           `-- main\n|   |-- objects\n|   |   |-- 07\n|   |   |   `-- a941b332d756f9a8acc9fdaf58aab5c7a43f64\n|   |   |-- 28\n|   |   |   `-- ed2456cbfa8a18a280c8af5b422e91e88ff64d\n|   |   |-- 2b\n|   |   |   `-- 61e2b3db9d1708269cf9d1aeaae2b0a2af1a23\n|   |   |-- 4f\n|   |   |   `-- cc8f85f738deb6cbb17db1ed3da241ad6cdf39\n|   |   |-- 50\n|   |   |   `-- fcd26d6ce3000f9d5f12904e80eccdc5685dd1\n|   |   |-- 60\n|   |   |   `-- 88354b376cb7c5567fa969c4dbb37eee98b250\n|   |   |-- 7a\n|   |   |   `-- 83e8d82106a4899408c425a9bf888efd28667b\n|   |   |-- f2\n|   |   |   `-- fa54609fe5e918f365e0d5ffaf9a3aea88d541\n|   |   |-- info\n|   |   `-- pack\n|   `-- refs\n|       |-- heads\n|       |   `-- main\n|       `-- tags\n|-- dir1\n|   `-- file2\n`-- file1\n\n22 directories, 33 files\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit cat-file -p HEAD\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntree 2b61e2b3db9d1708269cf9d1aeaae2b0a2af1a23\nparent 6088354b376cb7c5567fa969c4dbb37eee98b250\nauthor pcinereus <i.obesulus@gmail.com> 1721359213 +0000\ncommitter pcinereus <i.obesulus@gmail.com> 1721359213 +0000\n\nModified file1 and added file2 (in dir1)\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit cat-file -p HEAD^{tree}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n040000 tree f2fa54609fe5e918f365e0d5ffaf9a3aea88d541\tdir1\n100644 blob 28ed2456cbfa8a18a280c8af5b422e91e88ff64d\tfile1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n7a83e8d Modified file1 and added file2 (in dir1)\n6088354 Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n\n:::\n\nNow you might be wondering... What if I have modified many files and I\nwant to stage them all. Do I really have to add each file\nindividually? Is there not some way to add multiple files at a time?\nThe answer of course is yes. To stage all files (including those in\nsubdirectories) we issue the `git add .` _command_ (notice the dot).\n\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit add .\n```\n:::\n\n\n\n## `.gitignore`\n\nWhilst it is convenient to not have to list every file that you want\nto be staged (added), what about files that we don't want to get\nstaged and committed. It is also possible to define a file (called\n`.gitignore`) that is a list of files (or file patterns) that are to\nbe excluded when we request all files be added. This functionality is\nprovided via the `.gitignore` _file_ that must be in the root of the\nrepository working directory.\n\nFor example, we may have temporary files or automatic backup files or\nfiles generated as intermediates in a compile process etc that get\ngenerated. These files are commonly generated in the process of\nworking with files in a project, yet we do not necessarily wish for\nthem to be tracked. Often these files have very predictable filename\npattern (such as ending with a # or ~ symbol or having a specific file\nextension such as .aux. \n\nAs an example, when working with a project in Rstudio, files (such as\n`.Rhistory`) and directories (such as `.Rproj.user`) are automatically\nadded to the file system and thus appear as untracked files in git\nstatus.\n\nHence, we can create a`.gitignore` to exclude these files/directories.\nIndeed, if you are using Rstudio, you might have noticed that a\n`.gitignore` file was automatically created when you created the\nproject.\n\n\nLets start by modifying the `file2` and creating a new file\n`f.tmp` (that we want to ignore).\n\n::: {.panel-tabset}\n\n### Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\necho '---' >> dir1/file2\necho 'temp' > dir1/f.tmp\n```\n:::\n\n\n\n### Rstudio\n\n1. navigate to the `dir1` directory and open `file2` for editing (or\n   just make sure you are on the `file2` tab.\n2. edit the file such that it just contains three hyphens (`---`)\n   before saving the file\n3. in the same `dir1` directory add another new text file (`f.tmp`)\n   and edit this file to contain the word `temp` (then save the file)\n\nThe Git status panel should display both of these as untracked files.\n\n![](../resources/rstudio_gitignore1.png)\n:::\n\n\nTo ignore the `f.tmp` file, we could either explicitly add\nthis file as a row in a `.gitignore` file, or else we could\nsupply a wildcard version that will ignore all files ending in\n`.tmp`.\n\n::: {.panel-tabset}\n\n### Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\necho '*.tmp' > .gitignore\ncat .gitignore\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n*.tmp\n```\n\n\n:::\n:::\n\n\n### Rstudio\n1. navigate back to the root of the project\n2. click on the `gitignore` file to open it up for editing\n3. navigate to the end of this file and add a newline containing the\n   text `*.tmp`\n   \n   ![](../resources/rstudio_gitignore2.png)\n\nYou will notice that this `.gitignore` file already had items in it\nbefore you started editing it. These were added by Rstudio when you\nfirst created the new project.\n\nThe first item is `.Rproj.user` and its presence in this file is why\nit does not appear in the git status panel.\n\nOnce we save the `.gitignore` file, notice how the `f.tmp` file is\nsimilarly removed from the git status panel - since via `.gitignore`\nwe have indicated that we want to ignore this file (not track it as\npart of our version control system).\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## More information about exclusions (`.gitignore`)\n\n| Entry          | Meaning                                                                                                                |\n|----------------|------------------------------------------------------------------------------------------------------------------------|\n| `file1`        | DO NOT stage (add) file1                                                                                               |\n| `*.tmp`        | DO NOT stage (add) any file ending in .tmp                                                                             |\n| `/dir1/*`      | DO NOT stage (add) the folder called dir1 (or any of its contents) unless this is specifically negated (see next line) |\n| `!/dir1/file2` | DO stage (add) the file called file2 in the dir1 folder                                                                                                                       |\n\n: {.primary .bordered .sm .paramsTable}\n\n:::\n\n\nNow when we go to add all files to the staging area, those that fall\nunder the exclude rules will be _ignored_\n\n::: {.panel-tabset}\n\n### Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit add .\n```\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOn branch main\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tnew file:   .gitignore\n\tmodified:   dir1/file2\n```\n\n\n:::\n:::\n\n\n\nYou will notice that `.gitignore` was added as a _new file_ and\n`dir1/file2` was marked as _modified_ yet `dir1/f.tmp` was totally\nignored.\n\n### Rstudio\n\nYou will notice that `.gitignore` was added as a _new file_ and\n`dir1/file2` was marked as _modified_ yet `dir1/f.tmp` was totally\nignored.\n\n1. check the boxes next to each of the files listed in the status\n   panel\n\n   ![](../resources/rstudio_gitignore3.png)\n\n:::\n\n\nLets now commit these changes.\n\n::: {.panel-tabset}\n\n### Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit commit -m 'Modified file2, added .gitignore'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[main ddf0589] Modified file2, added .gitignore\n 2 files changed, 2 insertions(+)\n create mode 100644 .gitignore\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOn branch main\nnothing to commit, working tree clean\n```\n\n\n:::\n:::\n\n\n\n### Rstudio\n\n1. click on the \"Commit\" button\n2. add a commit message (such as `Modified file2, added .gitignore`)\n3. click the \"Commit\" button\n4. close the popup\n5. close the \"Review Changes\" window\n:::\n\n\nFor those still interested in the schematic...\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n  \n![](../resources/Fig-advanced6.png)\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the git\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit6.png){width=100%}\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## More information about committing changes to the repository\nCommitting staged changes creates an object under the `.git` tree.\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -a --charset unicode\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- .git\n|   |-- COMMIT_EDITMSG\n|   |-- HEAD\n|   |-- branches\n|   |-- config\n|   |-- description\n|   |-- hooks\n|   |   |-- applypatch-msg.sample\n|   |   |-- commit-msg.sample\n|   |   |-- fsmonitor-watchman.sample\n|   |   |-- post-update.sample\n|   |   |-- pre-applypatch.sample\n|   |   |-- pre-commit.sample\n|   |   |-- pre-merge-commit.sample\n|   |   |-- pre-push.sample\n|   |   |-- pre-rebase.sample\n|   |   |-- pre-receive.sample\n|   |   |-- prepare-commit-msg.sample\n|   |   |-- push-to-checkout.sample\n|   |   |-- sendemail-validate.sample\n|   |   `-- update.sample\n|   |-- index\n|   |-- info\n|   |   `-- exclude\n|   |-- logs\n|   |   |-- HEAD\n|   |   `-- refs\n|   |       `-- heads\n|   |           `-- main\n|   |-- objects\n|   |   |-- 07\n|   |   |   `-- a941b332d756f9a8acc9fdaf58aab5c7a43f64\n|   |   |-- 14\n|   |   |   `-- 3a8bb5a2cc05a91f83a87af18c8eb5885a375c\n|   |   |-- 19\n|   |   |   `-- 44fd61e7c53bcc19e6f3eb94cc800508944a25\n|   |   |-- 28\n|   |   |   `-- ed2456cbfa8a18a280c8af5b422e91e88ff64d\n|   |   |-- 2b\n|   |   |   `-- 61e2b3db9d1708269cf9d1aeaae2b0a2af1a23\n|   |   |-- 3c\n|   |   |   `-- 7af0d3ccea71c9af82fa0ce68532272edcf1b8\n|   |   |-- 4f\n|   |   |   `-- cc8f85f738deb6cbb17db1ed3da241ad6cdf39\n|   |   |-- 50\n|   |   |   `-- fcd26d6ce3000f9d5f12904e80eccdc5685dd1\n|   |   |-- 60\n|   |   |   `-- 88354b376cb7c5567fa969c4dbb37eee98b250\n|   |   |-- 7a\n|   |   |   `-- 83e8d82106a4899408c425a9bf888efd28667b\n|   |   |-- c4\n|   |   |   `-- 26a67af50d13828ec73b3c560b2648e2f3dc08\n|   |   |-- dd\n|   |   |   `-- f0589f9832743e46bf32da94ee3bab19797522\n|   |   |-- f2\n|   |   |   `-- fa54609fe5e918f365e0d5ffaf9a3aea88d541\n|   |   |-- info\n|   |   `-- pack\n|   `-- refs\n|       |-- heads\n|       |   `-- main\n|       `-- tags\n|-- .gitignore\n|-- dir1\n|   |-- f.tmp\n|   `-- file2\n`-- file1\n\n27 directories, 40 files\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit cat-file -p HEAD\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntree 3c7af0d3ccea71c9af82fa0ce68532272edcf1b8\nparent 7a83e8d82106a4899408c425a9bf888efd28667b\nauthor pcinereus <i.obesulus@gmail.com> 1721359215 +0000\ncommitter pcinereus <i.obesulus@gmail.com> 1721359215 +0000\n\nModified file2, added .gitignore\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit cat-file -p HEAD^{tree}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n100644 blob 1944fd61e7c53bcc19e6f3eb94cc800508944a25\t.gitignore\n040000 tree c426a67af50d13828ec73b3c560b2648e2f3dc08\tdir1\n100644 blob 28ed2456cbfa8a18a280c8af5b422e91e88ff64d\tfile1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nddf0589 Modified file2, added .gitignore\n7a83e8d Modified file1 and added file2 (in dir1)\n6088354 Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n\n:::\n\n# Inspecting a repository\n\nFor this section, will will be working on the repository built up in\nthe previous section. If you did not follow along with the previous\nsection, I suggest that you expand the following callout and run the\nprovided code in a terminal.\n\nIf you already have the repository, you can ignore the commands to\ncreate the repository.\n\n\n::: {.callout-note collapse=\"true\"}\n## Commands to create the the repository\n\nIssue the following commands in your terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nrm -rf ~/tmp/Repo1\nmkdir ~/tmp/Repo1\ncd ~/tmp/Repo1\ngit init \necho 'File 1' > file1\ngit add file1\ngit commit -m 'Initial repo and added file1'\necho '---------------' >> file1\nmkdir dir1\necho '* Notes' > dir1/file2\ngit add file1 dir1/file2\ngit commit -m 'Modified file1 and added file2 (in dir1)'\necho '---' >> dir1/file2\necho 'temp' > dir1/f.tmp\necho '*.tmp' > .gitignore\ngit add .\ngit commit -m 'Modified file2, added .gitignore'\n```\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 9 files\n```\n\n\n:::\n:::\n\n\n:::\n\n## Status of workspace and staging area\n\nRecall that within the .git environment, files can be in one of four\nstates:\n\n- untracked\n- modified\n- staged\n- committed\n\nTo inspect the status of files in your workspace, you can issue the\n`git status` <i>command</i> (as we have done on numerous occasions\nabove). This command displays the current state of the workspace and\nstaging area.\n\n::: {.panel-tabset}\n\n### Terminal\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOn branch main\nnothing to commit, working tree clean\n```\n\n\n:::\n:::\n\n\nThe output of `git status` partitions all the files into (staged:\n`Changes to be committed`, unstaged: `Changes not staged for commit`\nand `Untracked`) as well as hints on how to either promote or demote\nthe status of these files.\n\n\n### Rstudio\n\nExamine the git status panel - ideally it should be empty thereby\nsignalling that all your important files are tracked andcommitted.\n\n:::\n\n### log of commits\n\n\n::: {.panel-tabset}\n\n#### Terminal\n\nThe `git log` _command_ allows us to review the history of committed\nsnapshots\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncommit ddf0589f9832743e46bf32da94ee3bab19797522\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:15 2024 +0000\n\n    Modified file2, added .gitignore\n\ncommit 7a83e8d82106a4899408c425a9bf888efd28667b\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:13 2024 +0000\n\n    Modified file1 and added file2 (in dir1)\n\ncommit 6088354b376cb7c5567fa969c4dbb37eee98b250\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:07 2024 +0000\n\n    Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n\nWe can see that in my case some fool called 'Murray Logan' has made a\ntotal of three commits. We can also see the date/time that the commits\nwere made as well as the supplied commit comment.\n\nOver time repositories accumulate a large number of commits, to only\nreview the last 2 commits, we could issue the `git log -n\n2` _command_. \n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log -n 2 \n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncommit ddf0589f9832743e46bf32da94ee3bab19797522\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:15 2024 +0000\n\n    Modified file2, added .gitignore\n\ncommit 7a83e8d82106a4899408c425a9bf888efd28667b\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:13 2024 +0000\n\n    Modified file1 and added file2 (in dir1)\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Additional useful (`git log`) options\n\n<table>\n<thead>\n<th>Option</th><th>Example</th>\n</thead>\n<tbody>\n<tr>\n<td>`--oneline`<br>Condensed view</td>\n<td>\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nddf0589 Modified file2, added .gitignore\n7a83e8d Modified file1 and added file2 (in dir1)\n6088354 Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr>\n<td>`--stat`<br>Indicates number of changes</td>\n<td>\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log --stat\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncommit ddf0589f9832743e46bf32da94ee3bab19797522\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:15 2024 +0000\n\n    Modified file2, added .gitignore\n\n .gitignore | 1 +\n dir1/file2 | 1 +\n 2 files changed, 2 insertions(+)\n\ncommit 7a83e8d82106a4899408c425a9bf888efd28667b\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:13 2024 +0000\n\n    Modified file1 and added file2 (in dir1)\n\n dir1/file2 | 1 +\n file1      | 1 +\n 2 files changed, 2 insertions(+)\n\ncommit 6088354b376cb7c5567fa969c4dbb37eee98b250\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:07 2024 +0000\n\n    Initial repo and added file1\n\n file1 | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n<tr>\n<td>`-p`<br>Displays the full diff of each commit</td>\n<td>\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log -p\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncommit ddf0589f9832743e46bf32da94ee3bab19797522\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:15 2024 +0000\n\n    Modified file2, added .gitignore\n\ndiff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..1944fd6\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1 @@\n+*.tmp\ndiff --git a/dir1/file2 b/dir1/file2\nindex 4fcc8f8..143a8bb 100644\n--- a/dir1/file2\n+++ b/dir1/file2\n@@ -1 +1,2 @@\n * Notes\n+---\n\ncommit 7a83e8d82106a4899408c425a9bf888efd28667b\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:13 2024 +0000\n\n    Modified file1 and added file2 (in dir1)\n\ndiff --git a/dir1/file2 b/dir1/file2\nnew file mode 100644\nindex 0000000..4fcc8f8\n--- /dev/null\n+++ b/dir1/file2\n@@ -0,0 +1 @@\n+* Notes\ndiff --git a/file1 b/file1\nindex 50fcd26..28ed245 100644\n--- a/file1\n+++ b/file1\n@@ -1 +1,2 @@\n File 1\n+---------------\n\ncommit 6088354b376cb7c5567fa969c4dbb37eee98b250\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:07 2024 +0000\n\n    Initial repo and added file1\n\ndiff --git a/file1 b/file1\nnew file mode 100644\nindex 0000000..50fcd26\n--- /dev/null\n+++ b/file1\n@@ -0,0 +1 @@\n+File 1\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n\n<tr>\n<td>`--author=\"<name>\"`<br>Filter by author</td>\n<td>\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log --author=\"Murray\"\n```\n:::\n\n\n</td>\n</tr>\n\n<tr>\n<td>`--grep=\"<pattern>\"`<br>Filter by regex pattern of commit message</td>\n<td>\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log --grep=\"Modified\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncommit ddf0589f9832743e46bf32da94ee3bab19797522\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:15 2024 +0000\n\n    Modified file2, added .gitignore\n\ncommit 7a83e8d82106a4899408c425a9bf888efd28667b\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:13 2024 +0000\n\n    Modified file1 and added file2 (in dir1)\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n\n<tr>\n<td>`<file>`<br>Filter by filename</td>\n<td>\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log file1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncommit 7a83e8d82106a4899408c425a9bf888efd28667b\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:13 2024 +0000\n\n    Modified file1 and added file2 (in dir1)\n\ncommit 6088354b376cb7c5567fa969c4dbb37eee98b250\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:07 2024 +0000\n\n    Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n\n<tr>\n<td>`--decorate --graph`</td>\n<td>\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log --graph --decorate --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* ddf0589 (HEAD -> main) Modified file2, added .gitignore\n* 7a83e8d Modified file1 and added file2 (in dir1)\n* 6088354 Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n\n<tr>\n<td>`--all`<br>All branches</td>\n<td>\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncommit ddf0589f9832743e46bf32da94ee3bab19797522\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:15 2024 +0000\n\n    Modified file2, added .gitignore\n\ncommit 7a83e8d82106a4899408c425a9bf888efd28667b\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:13 2024 +0000\n\n    Modified file1 and added file2 (in dir1)\n\ncommit 6088354b376cb7c5567fa969c4dbb37eee98b250\nAuthor: pcinereus <i.obesulus@gmail.com>\nDate:   Fri Jul 19 03:20:07 2024 +0000\n\n    Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n</td>\n</tr>\n</tbody>\n</table>\n:::\n\n\n#### Rstudio\n\nTo explore the history of a repository, click on the clock icon (\"View\nhistory of previous commits\" button). This will open up the \"Review\nChanges\" window in the \"History\" tab.\n\n![](../resources/rstudio_gitstatus1.png)\n\nAlong with the reverse chronological list of commits, for each commit\n(and file thereof), you can explore the changes (diffs) that occurred.\n\nText that appears over a green background represents text that have\nbeen added as part of the current commit. Text that appears over a red\nbackground represents text that have been removed.\n\nIf we scroll down and explore the changes in `dir1/file2` for the most\nrecent commit, we see that the text `* Notes` was removed and then `*\nNotes` and `---` were added. At first this might seem a bit odd - why\nwas `* Notes` deleted and then added back? \n\n![](../resources/rstudio_gitstatus2.png)\n\nGit works on entire lines of text. So the first line was replaced\nbecause in the newer version, the first line had a carriage return\n(newline character). Although we cant see this character, it is\nthere - we see it more via its effect (sending the text after it to\nthe next line). Hence, in fact, two lines of text were actually\nchanged in the most recent commit.\n\n:::\n\n### `reflog`\n\n::: {.panel-tabset}\n\n#### Terminal\n\nAnother way to explore the commit history is to look at the\n**reflog**. This is a log of the _branch_ references. This approach is\nmore useful when we have multiple _branches_ and so will be visited in\nthe <a href=\"#Branching\">section on branching</a>. It displays all\nrepository activity, not just the commits.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nddf0589 HEAD@{0}: commit: Modified file2, added .gitignore\n7a83e8d HEAD@{1}: commit: Modified file1 and added file2 (in dir1)\n6088354 HEAD@{2}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n\n#### Rstudio\n\nSome of this sort of information can be gleaned from the git\n\"History\". Just make sure you select (\"all branches\") from the \"Switch\nbranch\" menu.\n\n![](../resources/rstudio_gitstatus3.png)\n\n:::\n\n### `diff`\n\nWhilst some of these actions described in this section are available\nfrom the \"History\" tab of the \"Review Changes\" window in Rstudio, most\nare only available as terminal commands.\n\n\n\n::: {.cell class='tikz'}\n::: {.cell-output-display}\n![](10_git_files/figure-html/Fig-advancedDiff1-1.png){width=672}\n:::\n:::\n\n\n\nTwo of the three commits in our repository involved modifications to a\nfile (`dir1/file2`). To further help illustrate commands to compare\nfiles indifferent states, we will additionally make a further change\nto `dir1/file2`. The `git diff` allows us to explore differences\nbetween:\n\n- the workspace and the staging area (index)\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  # lets modify dir1/file2\n  echo 'Notes' >> dir1/file2\n  git diff\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  diff --git a/dir1/file2 b/dir1/file2\n  index 143a8bb..f12af0a 100644\n  --- a/dir1/file2\n  +++ b/dir1/file2\n  @@ -1,2 +1,3 @@\n   * Notes\n   ---\n  +Notes\n  ```\n  \n  \n  :::\n  :::\n\n\n\n  The output indicates that we are comparing the blob representing\n  `dir1/file2` in the <i>index</i> (staging area) with the newly\n  modified `dir1/file2`. The next couple of rows indicate that the\n  <i>indexed</i> version will be represented by a '-' sign and the new\n  version will be represented by a '+' sign. The next row (which is\n  surrounded in a pair of `@` signs, indicates that there are two\n  lines that have changed. Finally the next two rows show that a\n  charrage return has been added to the end of the first line and the\n  new version has added the word 'Notes' to the next line.\n  \n- the staging area and the last commit\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  git add .\n  git diff --cached\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  diff --git a/dir1/file2 b/dir1/file2\n  index 143a8bb..f12af0a 100644\n  --- a/dir1/file2\n  +++ b/dir1/file2\n  @@ -1,2 +1,3 @@\n   * Notes\n   ---\n  +Notes\n  ```\n  \n  \n  :::\n  :::\n\n\n\n  Once we stage the modifications, we see that the same differences\n  are recorded.\n\n- the index and a tree (in this case, the current tree)\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  git diff --cached HEAD^{tree}\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  diff --git a/dir1/file2 b/dir1/file2\n  index 143a8bb..f12af0a 100644\n  --- a/dir1/file2\n  +++ b/dir1/file2\n  @@ -1,2 +1,3 @@\n   * Notes\n   ---\n  +Notes\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- the workspace and the current commit\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  git diff HEAD\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  diff --git a/dir1/file2 b/dir1/file2\n  index 143a8bb..f12af0a 100644\n  --- a/dir1/file2\n  +++ b/dir1/file2\n  @@ -1,2 +1,3 @@\n   * Notes\n   ---\n  +Notes\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- two commits (e.g. previous and current commits)\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  git diff HEAD^ HEAD\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  diff --git a/.gitignore b/.gitignore\n  new file mode 100644\n  index 0000000..1944fd6\n  --- /dev/null\n  +++ b/.gitignore\n  @@ -0,0 +1 @@\n  +*.tmp\n  diff --git a/dir1/file2 b/dir1/file2\n  index 4fcc8f8..143a8bb 100644\n  --- a/dir1/file2\n  +++ b/dir1/file2\n  @@ -1 +1,2 @@\n   * Notes\n  +---\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- two trees (first example, the current and previous commit trees)\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  git diff HEAD^{tree} HEAD^^{tree}\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  diff --git a/.gitignore b/.gitignore\n  deleted file mode 100644\n  index 1944fd6..0000000\n  --- a/.gitignore\n  +++ /dev/null\n  @@ -1 +0,0 @@\n  -*.tmp\n  diff --git a/dir1/file2 b/dir1/file2\n  index 143a8bb..4fcc8f8 100644\n  --- a/dir1/file2\n  +++ b/dir1/file2\n  @@ -1,2 +1 @@\n   * Notes\n  ----\n  ```\n  \n  \n  :::\n  :::\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  git diff 07a94 2b61e\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  diff --git a/dir1/file2 b/dir1/file2\n  new file mode 100644\n  index 0000000..4fcc8f8\n  --- /dev/null\n  +++ b/dir1/file2\n  @@ -0,0 +1 @@\n  +* Notes\n  diff --git a/file1 b/file1\n  index 50fcd26..28ed245 100644\n  --- a/file1\n  +++ b/file1\n  @@ -1 +1,2 @@\n   File 1\n  +---------------\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- two blobs (indeed any two objects)\n\n\n\n  ::: {.cell .bash}\n  \n  ```{.bash .cell-code}\n  git diff 50fcd 28ed2\n  ```\n  \n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  diff --git a/50fcd b/28ed2\n  index 50fcd26..28ed245 100644\n  --- a/50fcd\n  +++ b/28ed2\n  @@ -1 +1,2 @@\n   File 1\n  +---------------\n  ```\n  \n  \n  :::\n  :::\n\n\n\n### `ls-files`\n\nSimilar to the previous section, the following is only really\navailable via the terminal.\n\nWe can list the files that comprise the repository by:\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit ls-files \n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.gitignore\ndir1/file2\nfile1\n```\n\n\n:::\n:::\n\n\n\nThe change to `dir1/file2` above was just to illustrate the `git\ndiff`. In doing so we now have a modified version of this file that\nhas not been committed Before we move on, I am going to remove these\nchanges so that the `dir1/file2` is not in a modified state and\nreflects the state of the current commit. To do so, I will use perform\na **hard reset** (`git reset --hard`). More will be discussed about\nthe `git reset` command later in this tutorial - for now all that is\nimportant is to know that it restores the workspace to a previous\nstate.\n\nIn addition to the `git reset --hard`, I will also clean and prune the repository.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit reset --hard \ngit clean -qfdx\ngit reflog expire --expire-unreachable=now --all\ngit gc --prune=now\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHEAD is now at ddf0589 Modified file2, added .gitignore\n```\n\n\n:::\n:::\n\n\n\n## Tags\n\nAlthough it is possible to track the history of a repository via its\ncommit sha1 names, most find it more convenient to apply **tags** to\ncertain milestone commits. For example, a particular commit might\nrepresent a specific point in the history of a project - such as a\nrelease version. Git tags allow us to apply more human readable flags.\n\n::: {.panel-tabset}\n\n#### Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit tag V.1\n```\n:::\n\n\n\nIn the above, `V.1` is the tag we are applying to the most recent\ncommit. For this example, `V.1` simply denotes something like \"version\n1\". The tag must not contain any spaces (just replace space characters\nwith underscores or periods).\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log --graph --decorate --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* ddf0589 (HEAD -> main, tag: V.1) Modified file2, added .gitignore\n* 7a83e8d Modified file1 and added file2 (in dir1)\n* 6088354 Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nddf0589 HEAD@{0}: reset: moving to HEAD\nddf0589 HEAD@{1}: commit: Modified file2, added .gitignore\n7a83e8d HEAD@{2}: commit: Modified file1 and added file2 (in dir1)\n6088354 HEAD@{3}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n\n#### Rstudio\n\nThe functionality to add tags to commits is not directly supported in\nRstudio. in order to apply a tag, you will need to switch the terminal\nand enter a command like:\n\n![](../resources/rstudio_gittag1.png)\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit tag V.1\n```\n:::\n\n\nIn the above, `V.1` is the tag we are applying to the most recent\ncommit. For this example, `V.1` simply denotes something like \"version\n1\". The tag must not contain any spaces (just replace space characters\nwith underscores or periods).\n\nNow if we return to the \"History\" tab of the \"Review Changes\" window,\nwe can see the tag represented by a yellow tag in the commit diagram.\n\n![](../resources/rstudio_gittag2.png)\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit7.png){width=100%}\n\n:::\n\n\n# Branching\n\nAgain we will start with our repository. For this section, will be\nworking on the repository built up in the previous section.\n\n\n::: {.callout-note collapse=\"true\"}\n## Commands to create the repository (from above)\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nrm -rf ~/tmp/Repo1\nmkdir ~/tmp/Repo1\ncd ~/tmp/Repo1\ngit init \necho 'File 1' > file1\ngit add file1\ngit commit -m 'Initial repo and added file1'\necho '---------------' >> file1\nmkdir dir1\necho '* Notes' > dir1/file2\ngit add file1 dir1/file2\ngit commit -m 'Modified file1 and added file2 (in dir1)'\necho '---' >> dir1/file2\necho 'temp' > dir1/f.tmp\necho '*.tmp' > .gitignore\ngit add .\ngit commit -m 'Modified file2, added .gitignore'\ngit tag V.1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitialized empty Git repository in /home/runner/tmp/Repo1/.git/\n[main (root-commit) d7fde1a] Initial repo and added file1\n 1 file changed, 1 insertion(+)\n create mode 100644 file1\n[main 6553d45] Modified file1 and added file2 (in dir1)\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file2\n[main b29a0fb] Modified file2, added .gitignore\n 2 files changed, 2 insertions(+)\n create mode 100644 .gitignore\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Graphical representations of the repository\nThe following are a couple of different visuals of the repository.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 9 files\n```\n\n\n:::\n:::\n\n\n\n![](../resources/Fig-advanced6.png)\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit6a.png){width=100%}\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig7.png)\n\nLets assume that the current commit represents a largely stable\nproject. We are about to embark on a substantial modification in the\nform of a new feature that will involve editing `file1` and adding a\nnew file to `dir1`. At the same time, we wish to leave open the\npossibility of committing additional minor changes to the current\ncommit in order to address any bugs or issues that might arise.\n\nIn essence what we want to do is start a new _branch_ for the new\nfeature. This is performed in two steps:\n\n1. use the `git branch <name>` _command_ to generate a new branch\n   _reference_. In the following example, I will call the new branch\n   **Feature**, but it can be anything.\n\n:::: {.indented}\n\n::: {.panel-tabset}\n\n## Terminal\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit branch Feature\n```\n:::\n\n\n\n## Rstudio\n\nTo create a new branch, click on the \"New branch\" icon (see figure\nbelow) and enter a name (e.g. `Feature`) for the branch in the popup\nbox.\n\n![](../resources/rstudio_gitbranch1.png)\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n    \n![](../resources/Fig7a.png)\n\n::: {.callout-note}\nNote, at this stage we have only created a reference to a new branch,\nuntil we commit to this branch, its contents will be the same as the\nmain branch.\n:::\n\n::: {.callout-note collapse=\"true\"}\n## More information following the creation of the branch\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* b29a0fb (HEAD -> main, tag: V.1, Feature) Modified file2, added .gitignore\n* 6553d45 Modified file1 and added file2 (in dir1)\n* d7fde1a Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 9 files\nb29a0fb HEAD@{0}: commit: Modified file2, added .gitignore\n6553d45 HEAD@{1}: commit: Modified file1 and added file2 (in dir1)\nd7fde1a HEAD@{2}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit7a.png){width=100%}\n\n:::\n\n\n::::\n\n2. use the `git checkout <name>` _command_ to move the `HEAD` to\n   the tip of this new branch (`Feature`).\n\n:::: {.indented}\n\n::: {.panel-tabset}\n\n## Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit checkout Feature\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSwitched to branch 'Feature'\n```\n\n\n:::\n:::\n\n\n\n## Rstudio\n\nTo checkout a branch in Rstudio, click on the \"Switch branch\" button\nand select the branch name (in this case `Feature`) from the dialog box.\n\n![](../resources/rstudio_gitbranch3.png)\n\nIf we now examine the \"History\" tab of the \"Review Changes\" window, we\nwill see that the most recent commit has both `main` and `Feature`\nbranch markers. However, the main connection is with the `Feature`\nbranch indicating that the `HEAD` is currently on the `Feature`\nbranch.\n\n![](../resources/rstudio_gitbranch2.png)\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig7b.png)\n\nThe only noticable change is that we are now considered to be on the\n\"Feature\" branch (notice that HEAD is pointing to Feature). Any new\ncommits will be applied to this new branch.\n\n::: {.callout-note collapse=\"true\"}\n## More information following the creation of the branch\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* b29a0fb (HEAD -> Feature, tag: V.1, main) Modified file2, added .gitignore\n* 6553d45 Modified file1 and added file2 (in dir1)\n* d7fde1a Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 9 files\nb29a0fb HEAD@{0}: checkout: moving from main to Feature\nb29a0fb HEAD@{1}: commit: Modified file2, added .gitignore\n6553d45 HEAD@{2}: commit: Modified file1 and added file2 (in dir1)\nd7fde1a HEAD@{3}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit7b.png){width=100%}\n\n:::\n\n::::\n\n\nNow if we make and commit a change (such as an edit to `file1` and an\naddition of `file3` within `dir1`), we will be operating on a separate\n_branch_.\n\n::: {.panel-tabset}\n\n## Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\necho 'b' >> file1\necho 'File 3' > dir1/file3\ngit add .\ngit commit -m 'New feature'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[Feature 9d25246] New feature\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file3\n```\n\n\n:::\n:::\n\n\n\n## Rstudio\n\n1. modify `file1` by adding a carriage return followed by some\n   additional text (e.g. a `b`) like in the figure below\n \n   ![](../resources/rstudio_gitbranch4.png)\n   \n   \n2. navigate to this new directory (`dir1`)\n3. click the \"Create a new blank file in current directory\" button and\n   select \"Text file\"\n4. enter a new filename (`file3`) into the popup box\n5. enter some text into this file (such as `File 3`)\n\n   ![](../resources/rstudio_gitbranch5.png)\n6. stage (add) the two modified files using their respective\n   checkboxes\n7. click the \"Commit\" button, provide a commit message (sch as \"New\n   feature\")\n8. close the popup\n9. goto the \"History\" tab\n\n   ![](../resources/rstudio_gitbranch6.png)\n\nNotice that we have advanced one commit on this new branch.\n:::\n \n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig7c.png)\n\n::: {.callout-note collapse=\"true\"}\n## More information following the creation of the branch\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 9d25246 (HEAD -> Feature) New feature\n* b29a0fb (tag: V.1, main) Modified file2, added .gitignore\n* 6553d45 Modified file1 and added file2 (in dir1)\n* d7fde1a Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file3\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 10 files\n9d25246 HEAD@{0}: commit: New feature\nb29a0fb HEAD@{1}: checkout: moving from main to Feature\nb29a0fb HEAD@{2}: commit: Modified file2, added .gitignore\n6553d45 HEAD@{3}: commit: Modified file1 and added file2 (in dir1)\nd7fde1a HEAD@{4}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit7c.png){width=100%}\n\n:::\n\nSo we can now continue to develop the `Feature` _branch_. But what if\nwe now decided that we wanted to make a change to the `main`\n_branch_ (perhaps addressing a bug or issue).\n\n1. switch over to the `main` branch\n\n:::: {.indented}\n\n::: {.panel-tabset}\n\n## Terminal\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit checkout main\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSwitched to branch 'main'\n```\n\n\n:::\n:::\n\n\n\n## Rstudio\n\nUse the \"Switch branch\" selector to checkout the `main` branch\n\n:::\n\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig7d.png)\n\n::: {.callout-note collapse=\"true\"}\n## More information following the creation of the branch\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 9d25246 (Feature) New feature\n* b29a0fb (HEAD -> main, tag: V.1) Modified file2, added .gitignore\n* 6553d45 Modified file1 and added file2 (in dir1)\n* d7fde1a Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 9 files\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nb29a0fb HEAD@{0}: checkout: moving from Feature to main\n9d25246 HEAD@{1}: commit: New feature\nb29a0fb HEAD@{2}: checkout: moving from main to Feature\nb29a0fb HEAD@{3}: commit: Modified file2, added .gitignore\n6553d45 HEAD@{4}: commit: Modified file1 and added file2 (in dir1)\nd7fde1a HEAD@{5}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit7d.png){width=100%}\n\n:::\n::::\n\n\n2. make the necessary changes to the files and commit them on the\n  `main` _branch_\n\n:::: {.indented}\n\n::: {.panel-tabset}\n\n## Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\necho ' another bug fix' >> dir1/file2\ngit add .\ngit commit -m 'Bug fix in file1'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[main 2cf2462] Bug fix in file1\n 1 file changed, 1 insertion(+)\n```\n\n\n:::\n:::\n\n\n\n## Rstudio\n\n\n1. make the following edits to `dir1/file2`\n\n   ![](../resources/rstudio_gitbranch7b.png)\n\n2. stage and commit the changes\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig7e.png)\n\n::: {.callout-note collapse=\"true\"}\n## More information following the creation of the branch\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 2cf2462 (HEAD -> main) Bug fix in file1\n| * 9d25246 (Feature) New feature\n|/  \n* b29a0fb (tag: V.1) Modified file2, added .gitignore\n* 6553d45 Modified file1 and added file2 (in dir1)\n* d7fde1a Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 9 files\n2cf2462 HEAD@{0}: commit: Bug fix in file1\nb29a0fb HEAD@{1}: checkout: moving from Feature to main\n9d25246 HEAD@{2}: commit: New feature\nb29a0fb HEAD@{3}: checkout: moving from main to Feature\nb29a0fb HEAD@{4}: commit: Modified file2, added .gitignore\n6553d45 HEAD@{5}: commit: Modified file1 and added file2 (in dir1)\nd7fde1a HEAD@{6}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit7e.png){width=100%}\n\n:::\n::::\n\n \n \n\nWe could simultaneously make additional modifications to the `Feature`\n_branch_ just by simply checking out the `Feature` _branch_ and\ncommiting those modifications. To illustrate, we will make another\nchange to the `dir1/file3` file.\n\n\n::: {.callout-info collapse=\"false\"}\nFor this demonstration we are deliberately avoiding making edits to\neither `file1` or `dir1/file2`. This is because if we did, there is a\nchance that we might introduce conflicting edits of the same lines of\nfiles across the two branches (`main` and `Feature`).\n\nIn a later section, we WILL deliberately introduce a conflict so that\nwe can see how to resolve conflicts.\n:::\n\n::: {.panel-tabset}\n\n## Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit checkout Feature\necho ' a modification' >> dir1/file3\ngit add .\ngit commit -m 'Feature complete'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSwitched to branch 'Feature'\n[Feature 18e5b78] Feature complete\n 1 file changed, 1 insertion(+)\n```\n\n\n:::\n:::\n\n\n\n## Rstudio\n\n1. checkout the `Feature` branch using the \"Switch branch\" selector\n2. modify `dir1/file3` by adding a carriage return followed by some\n   additional text (e.g. ` a modification`) like in the figure below\n\n   ![](../resources/rstudio_gitbranch7c.png)\n3. stage (add) this file\n4. commit the change with the message of `Feature complete`\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig7f.png)\n\n::: {.callout-note collapse=\"true\"}\n## More information following the creation of the branch\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 18e5b78 (HEAD -> Feature) Feature complete\n* 9d25246 New feature\n| * 2cf2462 (main) Bug fix in file1\n|/  \n* b29a0fb (tag: V.1) Modified file2, added .gitignore\n* 6553d45 Modified file1 and added file2 (in dir1)\n* d7fde1a Initial repo and added file1\n18e5b78 HEAD@{0}: commit: Feature complete\n9d25246 HEAD@{1}: checkout: moving from main to Feature\n2cf2462 HEAD@{2}: commit: Bug fix in file1\nb29a0fb HEAD@{3}: checkout: moving from Feature to main\n9d25246 HEAD@{4}: commit: New feature\nb29a0fb HEAD@{5}: checkout: moving from main to Feature\nb29a0fb HEAD@{6}: commit: Modified file2, added .gitignore\n6553d45 HEAD@{7}: commit: Modified file1 and added file2 (in dir1)\nd7fde1a HEAD@{8}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file3\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 10 files\n```\n\n\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit7f.png){width=100%}\n\n:::\n\n\n## Merge branches\n\nFinally, (if we are satisfied that `Feature` is stable and complete),\nwe might like to introduce these changes into the `main` _branch_ so\nthat they become a part of the main project base. This operation is\ncalled a **merge** and is completed with the `git merge <branch>`\n_command_ where `<branch>` is the name of the _branch_ you want to\nmerge the current branch (that pointed to by `HEAD`) with. Typically\nwe want to _merge_ the _non-main branch_ with the `main` _branch_.\nTherefore we must be _checkout_ the `main` _branch_ before _merging_.\n\n::: {.panel-tabset}\n\nIf we add the _switch_ `--no-edit`, then rather than supply a commit\nmessage (or be dropped into an editor to make a commit message), the\ndefault merge message will be applied to the commit.\n\n## Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit checkout main\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSwitched to branch 'main'\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit merge Feature --no-edit\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMerge made by the 'ort' strategy.\n dir1/file3 | 2 ++\n file1      | 1 +\n 2 files changed, 3 insertions(+)\n create mode 100644 dir1/file3\n```\n\n\n:::\n:::\n\n\n\n## Rstudio\n\n1. checkout the `main` branch using the \"Switch branch\" selector\n2. merging is not directly supported in Rstudio, so go to the terminal\n   and enter the `git merge` command as shown below\n   \n   ![](../resources/rstudio_gitmerge1.png)\n   \n3. if you now review the \"History\" tab of the \"Review Changes\" window,\n   you will see the confluence of the two branches reflected in the\n   commit graphic\n   \n   ![](../resources/rstudio_gitmerge2.png)\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig7g.png)\n\n::: {.callout-note collapse=\"true\"}\n## More information following the creation of the branch\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n*   8bca0ef (HEAD -> main) Merge branch 'Feature'\n|\\  \n| * 18e5b78 (Feature) Feature complete\n| * 9d25246 New feature\n* | 2cf2462 Bug fix in file1\n|/  \n* b29a0fb (tag: V.1) Modified file2, added .gitignore\n* 6553d45 Modified file1 and added file2 (in dir1)\n* d7fde1a Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file3\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 11 files\n8bca0ef HEAD@{0}: merge Feature: Merge made by the 'ort' strategy.\n2cf2462 HEAD@{1}: checkout: moving from Feature to main\n18e5b78 HEAD@{2}: commit: Feature complete\n9d25246 HEAD@{3}: checkout: moving from main to Feature\n2cf2462 HEAD@{4}: commit: Bug fix in file1\nb29a0fb HEAD@{5}: checkout: moving from Feature to main\n9d25246 HEAD@{6}: commit: New feature\nb29a0fb HEAD@{7}: checkout: moving from main to Feature\nb29a0fb HEAD@{8}: commit: Modified file2, added .gitignore\n6553d45 HEAD@{9}: commit: Modified file1 and added file2 (in dir1)\nd7fde1a HEAD@{10}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit7g.png){width=100%}\n\n:::\n\n\n::: {.callout-warning collapse=\"false\"}\n\nIf, when issuing a `git merge` command, you get a conflict message,\nplease refer to the section on resolving conflicts below.\n\n:::\n\n\n## Delete a branch\n\nOnce the purpose of the branch has been fulfilled (for example to\ndevelop a new feature) and the branch has been merged back into the\nmain branch, you might consider deleting the branch so as to simplify\nthe commit history.\n\nImportantly, this action should only ever be performed after the\nbranch has been successfully merged into the main branch (in fact `git\nwill not allow you to delete an un-merged branch unless you really\nfight for it).\n\n**Note also, this can only be performed on a local repository.**\n\nThis procedure is only available via the terminal.\n\n<!-- The following chunk is used to get the hash of the Feature branch head so that later on in the doc, I can restore the branch.  Since the next chunk will delete it. -->\n\n\n::: {.cell}\n\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit branch -d Feature\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDeleted branch Feature (was 18e5b78).\n```\n\n\n:::\n:::\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig7h.png)\n\n::: {.callout-note collapse=\"true\"}\n## More information following the creation of the branch\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n*   8bca0ef (HEAD -> main) Merge branch 'Feature'\n|\\  \n| * 18e5b78 Feature complete\n| * 9d25246 New feature\n* | 2cf2462 Bug fix in file1\n|/  \n* b29a0fb (tag: V.1) Modified file2, added .gitignore\n* 6553d45 Modified file1 and added file2 (in dir1)\n* d7fde1a Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file3\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 11 files\n8bca0ef HEAD@{0}: merge Feature: Merge made by the 'ort' strategy.\n2cf2462 HEAD@{1}: checkout: moving from Feature to main\n18e5b78 HEAD@{2}: commit: Feature complete\n9d25246 HEAD@{3}: checkout: moving from main to Feature\n2cf2462 HEAD@{4}: commit: Bug fix in file1\nb29a0fb HEAD@{5}: checkout: moving from Feature to main\n9d25246 HEAD@{6}: commit: New feature\nb29a0fb HEAD@{7}: checkout: moving from main to Feature\nb29a0fb HEAD@{8}: commit: Modified file2, added .gitignore\n6553d45 HEAD@{9}: commit: Modified file1 and added file2 (in dir1)\nd7fde1a HEAD@{10}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit7h.png){width=100%}\n\n:::\n\nIn order to facilitate the rest of the tutorial, I am going to\n**reset** the repository to a commit that precedes the merge. The\nprocess of resetting will be covered later on in this tutorial.\n\n<!-- The hash variable needed for the code below comes from above bash8h -->\n\n\n\n::: {.cell .bash replace='true'}\n\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reset --hard HEAD~1\ngit clean -qfdx\ngit reflog expire --expire-unreachable=now --all\ngit gc --prune=now\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHEAD is now at 2cf2462 Bug fix in file1\n```\n\n\n:::\n:::\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig7i.png)\n\n::: {.callout-note collapse=\"true\"}\n## More information following the creation of the branch\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\ngit log --graph --decorate --oneline --all\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   `-- file2\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- packed-refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 10 files\n* 18e5b78 (Feature) Feature complete\n* 9d25246 New feature\n| * 2cf2462 (HEAD -> main) Bug fix in file1\n|/  \n* b29a0fb (tag: V.1) Modified file2, added .gitignore\n* 6553d45 Modified file1 and added file2 (in dir1)\n* d7fde1a Initial repo and added file1\n2cf2462 HEAD@{0}: checkout: moving from Feature to main\n18e5b78 HEAD@{1}: commit: Feature complete\n9d25246 HEAD@{2}: checkout: moving from main to Feature\n2cf2462 HEAD@{3}: commit: Bug fix in file1\nb29a0fb HEAD@{4}: checkout: moving from Feature to main\n9d25246 HEAD@{5}: commit: New feature\nb29a0fb HEAD@{6}: checkout: moving from main to Feature\nb29a0fb HEAD@{7}: commit: Modified file2, added .gitignore\n6553d45 HEAD@{8}: commit: Modified file1 and added file2 (in dir1)\nd7fde1a HEAD@{9}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n## Rebasing\n\nBranches are great for working on new features without disturbing a\nstable codebase. However, the main branch may have changed or\nprogressed since the branch started. As a result, it may be building\nupon old code that may either no longer work or no longer be\nappropriate.\n\nWhilst you could attempt to manually apply the newer main code changes\ninto your branch, this is likely to be tedious and error prone.\n**Rebasing** is the process of changing the root (base) of the branch\nfrom one commit to another. In this way, the base of the branch can be\nmoved to the current HEAD of the main branch, thereby absorbing all\nthe updates from the main branch into the feature branch.\n\nThis section builds on the repository created up to this point in the\ntutorial. To remind you, the repository currently looks like:\n\n::: {.callout-note collapse=\"true\"}\n## Commands to create the repository\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nrm -rf ~/tmp/Repo1\nmkdir ~/tmp/Repo1\ncd ~/tmp/Repo1\ngit init \necho 'File 1' > file1\ngit add file1\ngit commit -m 'Initial repo and added file1'\necho '---------------' >> file1\nmkdir dir1\necho '* Notes' > dir1/file2\ngit add file1 dir1/file2\ngit commit -m 'Modified file1 and added file2 (in dir1)'\necho '---' >> dir1/file2\necho 'temp' > dir1/f.tmp\necho '*.tmp' > .gitignore\ngit add .\ngit commit -m 'Modified file2, added .gitignore'\ngit tag V.1\ngit branch Feature\ngit checkout Feature\necho 'b' >> file1\necho 'File 3' > dir1/file3\ngit add .\ngit commit -m 'New feature'\ngit checkout main\necho ' another bug fix' >> dir1/file2\ngit add .\ngit commit -m 'Bug fix in file1'\ngit checkout Feature\necho ' a modification' >> dir1/file3\ngit add .\ngit commit -m 'Feature complete'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitialized empty Git repository in /home/runner/tmp/Repo1/.git/\n[main (root-commit) 3001cb3] Initial repo and added file1\n 1 file changed, 1 insertion(+)\n create mode 100644 file1\n[main 0ce1bf5] Modified file1 and added file2 (in dir1)\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file2\n[main e32745f] Modified file2, added .gitignore\n 2 files changed, 2 insertions(+)\n create mode 100644 .gitignore\nSwitched to branch 'Feature'\n[Feature f4830b7] New feature\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file3\nSwitched to branch 'main'\n[main 7d7ba30] Bug fix in file1\n 1 file changed, 1 insertion(+)\nSwitched to branch 'Feature'\n[Feature e014add] Feature complete\n 1 file changed, 1 insertion(+)\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n![](../resources/Fig7i.png)\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file3\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 10 files\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* e014add (HEAD -> Feature) Feature complete\n* f4830b7 New feature\n| * 7d7ba30 (main) Bug fix in file1\n|/  \n* e32745f (tag: V.1) Modified file2, added .gitignore\n* 0ce1bf5 Modified file1 and added file2 (in dir1)\n* 3001cb3 Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ne014add HEAD@{0}: commit: Feature complete\nf4830b7 HEAD@{1}: checkout: moving from main to Feature\n7d7ba30 HEAD@{2}: commit: Bug fix in file1\ne32745f HEAD@{3}: checkout: moving from Feature to main\nf4830b7 HEAD@{4}: commit: New feature\ne32745f HEAD@{5}: checkout: moving from main to Feature\ne32745f HEAD@{6}: commit: Modified file2, added .gitignore\n0ce1bf5 HEAD@{7}: commit: Modified file1 and added file2 (in dir1)\n3001cb3 HEAD@{8}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n\n::: {.panel-tabset}\n## Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit checkout Feature\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAlready on 'Feature'\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit rebase main\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRebasing (1/2)\nRebasing (2/2)\n\n                                                                                \nSuccessfully rebased and updated refs/heads/Feature.\n```\n\n\n:::\n:::\n\n\n\n## Rstudio\n\nRebasing is not directly supported by Rstudio. \n\n1. checkout the `Feature` branch using the \"Switch branch\" selector\n2. in the terminal, type `git rebase main` to rebase the `Feature`\n   branch on the end of the `main` branch.\n\n3. if you now review the \"History\" tab of the \"Review Changes\" window,\n   you will now see that the history is linear and the `Feature`\n   branch stems from the end of the `main` branch. That is, we have\n   moved the base of the `Feature` branch.\n   \n   ![](../resources/rstudio_gitrebase1.png)\n:::\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file3\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    |-- COMMIT_EDITMSG\n    `-- AUTO_MERGE\n\n8 directories, 12 files\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 70d8404 (HEAD -> Feature) Feature complete\n* 257ab1b New feature\n* 7d7ba30 (main) Bug fix in file1\n* e32745f (tag: V.1) Modified file2, added .gitignore\n* 0ce1bf5 Modified file1 and added file2 (in dir1)\n* 3001cb3 Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n70d8404 HEAD@{0}: rebase (finish): returning to refs/heads/Feature\n70d8404 HEAD@{1}: rebase (pick): Feature complete\n257ab1b HEAD@{2}: rebase (pick): New feature\n7d7ba30 HEAD@{3}: rebase (start): checkout main\ne014add HEAD@{4}: checkout: moving from Feature to Feature\ne014add HEAD@{5}: commit: Feature complete\nf4830b7 HEAD@{6}: checkout: moving from main to Feature\n7d7ba30 HEAD@{7}: commit: Bug fix in file1\ne32745f HEAD@{8}: checkout: moving from Feature to main\nf4830b7 HEAD@{9}: commit: New feature\ne32745f HEAD@{10}: checkout: moving from main to Feature\ne32745f HEAD@{11}: commit: Modified file2, added .gitignore\n0ce1bf5 HEAD@{12}: commit: Modified file1 and added file2 (in dir1)\n3001cb3 HEAD@{13}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig8a.png)\n\n\nIf the rebased commits were previously on a remote repository\n(hopefully you checked to make sure noone was relying on any of the\ncommits that have been squashed), then it will be necessary to force a\npush on this repository.\n \n\n# Undoing (rolling back) changes\n\nOne of the real strengths of a versioning system is the ability to\nroll back to a previous state when changes have been found to\nintroduce undesirable or unintended consequences. There are also\nmultiple different stages from which to roll back. For example, do we\nwant to revert from committed states or just unstage a file or files.\n\nTo illustrate the various ways to roll back within a repository, we\nwill start with a small repository comprising of a single branch and\njust three commits. This repository will mimic a repository created\nearlier in this tutorial (before we started branching).\n\n::: {.callout-note collapse=\"true\"}\n## Commands to create the repository\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nrm -rf ~/tmp/Repo1\nmkdir ~/tmp/Repo1\ncd ~/tmp/Repo1\ngit init \necho 'File 1' > file1\ngit add file1\ngit commit -m 'Initial repo and added file1'\necho '---------------' >> file1\nmkdir dir1\necho '* Notes' > dir1/file2\ngit add file1 dir1/file2\ngit commit -m 'Modified file1 and added file2 (in dir1)'\necho '---' >> dir1/file2\necho 'temp' > dir1/f.tmp\necho '*.tmp' > .gitignore\ngit add .\ngit commit -m 'Modified file2, added .gitignore'\ngit tag V.1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitialized empty Git repository in /home/runner/tmp/Repo1/.git/\n[main (root-commit) 437633e] Initial repo and added file1\n 1 file changed, 1 insertion(+)\n create mode 100644 file1\n[main 3d007af] Modified file1 and added file2 (in dir1)\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file2\n[main 001d2bb] Modified file2, added .gitignore\n 2 files changed, 2 insertions(+)\n create mode 100644 .gitignore\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ncat .git/refs/heads/main\n```\n:::\n\n\n    \n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 9 files\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 001d2bb (HEAD -> main, tag: V.1) Modified file2, added .gitignore\n* 3d007af Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n::: {.cell-output .cell-output-stdout}\n\n```\n001d2bb HEAD@{0}: commit: Modified file2, added .gitignore\n3d007af HEAD@{1}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{2}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig-advanced7.png)\n    \nThe above diagram shows that both `HEAD` and `main` point at the\nsame stage (all three files). **Again, remember that the SHA-1 has\nvalues will be different in your repo so in the following, you will\nneed to use the SHA value that corresponds to the item in your list**.\n\nWith additional commits and activity, the above schematic will rapidly\nbecome very busy and complex. As a result, we will now switch to a\nsimpler schematic that focuses only on the commits and references\nthereof (`HEAD`, `main` and _branches_).\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig9a.png)\n\nRecall that a git repository comprises multiple levels in which\nchanges are recorded:\n\n- there is the **Workspace** (which is essentially the actual files\n  and folders that you directly edit).\n- there is the **Staging area** (or index which is a record of which\n  files are next to be committed).\n- there is the **Local repository** (the actual commits).\n- and finally, three is the **remote repository** (a remote store of\n  commits).\n\nAs such, there are multiple levels from which changes could be undone.\nFurthermore, we might want to undo changes at the commit or individual\nfile level. For example, we might decide that we have made a local\ncommit that introduced an issue and we now wish to return back to the\nstate prior to this commit. Alternatively, we might have just\naccidentally staged a file (yet not committed it) and now we want to\nunstage it.\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n<table class='table table-primary table-bordered table-sm paramsTable' id = 'rollback-table'>\n<thead>\n<tr class = 'header'>\n<th>Action</th><th width='30%'>Command</th><th>Notes</th></tr>\n</thead>\n<tbody>\n<tr><td colspan='3'><i>Commit level</i></td></tr>\n<tr>\n<td>Undo to a particular local commit<br>\n![](10_git_files/figure-html/Figs9a-1.png)\n</td>\n<td>`git reset --soft <commit>`</td>\n<td>HEAD is moved to the nominated <commit>. IT DOES NOT alter index or the workspace</td>\n</tr>\n\n<tr>\n<td>Roll back to the the previous commit<br>\n![](10_git_files/figure-html/Figs9b-1.png)\n</td>\n<td>`git reset --hard <commit>`</td>\n<td>Resets the Index and Workspace</td>\n</tr>\n\n<tr>\n<td>Roll back over the last two commits<br>\n![](10_git_files/figure-html/Figs9c-1.png)\n</td>\n<td>`git reset --hard HEAD~2`</td>\n<td>Roll back over the last two commits</td>\n</tr>\n\n<tr>\n<td>Inspect an old commit<br>\n![](10_git_files/figure-html/Figs9d-1.png)\n</td>\n<td>`git checkout <commit>`</td>\n<td>moves the HEAD and modifies the workspace to reflect its state at <commit></td>\n</tr>\n\n<tr>\n<td>Roll back the changes introduced by commit so that a new commit resembles a previous state<br>\n![](10_git_files/figure-html/Figs9e-1.png)\n</td>\n<td>`git revert HEAD`</td>\n<td>Creates a new commit that reverses the changes introduced by the last commit.\nRevert creates a new revision history that adds onto existing history and is therefore safe to use on a branch that has been pushed to a remote.</td>\n</tr>\n</tbody>\n</table>\n\nNow lets say we wanted to roll back to the state before we added `.gitignore` and modified `dir1/file2`.\nThat is, we want to roll-back to commit `3d007af`.\nWe have three main choices:\n\n- **reset** - this allows us to remove all commits back to a nominated\n  commit. _Resetting_ is a irreversible process as it totally removes\n  commits from the history. A _reset_ should only ever be used if you\n  are sure you want to permanently remove the changes introduced via\n  one or more commits. **A reset should never be performed on a branch\n  that exists in a remote repository**\n\t\t\t  \n- **revert** - this allows us to skip the most recent commit. That\n  is, a _revert_ rolls back to a previous commit and then apply\n  that state to a new commit. Unlike a _reset_, all commits\n  remain safely in the git history and can target a single commit.\n\n- **branch** - this allows us to safely take the project (or part of\n  the project) in an experimental direction that might involve\n  dramatic deviations in files without interrupting the main thread of\n  the project. At some point, if the new direction proves useful, the\n  changes can be merged back into the main branch. We will expore\n  _branching_ in <a href=\"#Branching\">the section on branching</a>.\n\t\t\t\t\nNormally we would not perform all three. Rather, we would select the\nmost appropriate one depending on the context and goal. Nevertheless,\nthis is a tutorial and therefore we will perform all three. In order\nto ensure that we start from the same point for each demonstration,\nprior to each demonstration, we will aggressively reset the repository\nback to the state it was at commit `3d007af`.\n\n## Reset\n\nReset is not directly supported by Rstudio - use the terminal for this section.\n\n### Soft reset\n\nWhen we perform a **soft reset**, we move the head to the nominated\ncommit, but the workspace is unchanged.\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reset --soft 3d007af\n```\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 10 files\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 001d2bb (tag: V.1) Modified file2, added .gitignore\n* 3d007af (HEAD -> main) Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n::: {.cell-output .cell-output-stdout}\n\n```\n3d007af HEAD@{0}: reset: moving to 3d007af\n001d2bb HEAD@{1}: commit: Modified file2, added .gitignore\n3d007af HEAD@{2}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{3}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig-advanced8.png)\n    \n\n::: {.callout-note collapse=\"true\"}\n\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit8a.png){width=100%}\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file2\n|   `-- f.tmp\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 10 files\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 001d2bb (tag: V.1) Modified file2, added .gitignore\n* 3d007af (HEAD -> main) Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n::: {.cell-output .cell-output-stdout}\n\n```\n3d007af HEAD@{0}: reset: moving to 3d007af\n001d2bb HEAD@{1}: commit: Modified file2, added .gitignore\n3d007af HEAD@{2}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{3}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n\n### Hard reset\n\nWhen we perform a **hard reset**, we not only move the head to the\nnominated commit, but the workspace is altered to reflect the\nworkspace that existed when that commit was originally performed.\n\nAs I am about to demonstrate this on a repo that I have just performed\na soft reset on, I am first going to start by re-establishing the\noriginal repository. If you have not just run a soft reset, then\nignore the following.\n\n\n::: {.callout-note collapse=\"true\"}\n## Re-establish repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reset --hard V.1\ngit clean -qfdx\ngit reflog expire --expire-unreachable=now --all\ngit gc --prune=now\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHEAD is now at 001d2bb Modified file2, added .gitignore\n```\n\n\n:::\n:::\n\n\n\n:::\n\nNow we are in a position to perform the hard reset.\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reset --hard 3d007af\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHEAD is now at 3d007af Modified file1 and added file2 (in dir1)\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   `-- file2\n`-- .git\n    |-- refs\n    |-- packed-refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 9 files\n```\n\n\n:::\n:::\n\n\nNotice that `.gitignore` is not not present.\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 001d2bb (tag: V.1) Modified file2, added .gitignore\n* 3d007af (HEAD -> main) Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3d007af HEAD@{0}: reset: moving to 3d007af\n001d2bb HEAD@{1}: reset: moving to V.1\n3d007af HEAD@{2}: reset: moving to 3d007af\n001d2bb HEAD@{3}: commit: Modified file2, added .gitignore\n3d007af HEAD@{4}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{5}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n\nNote, however, if we looked at the log, it would be as if the previous\ncommit had not occurred. For this reason, care must be exercised when\nusing reset on remote repositories since others may be relying on a\nspecific point in the repo history that you may have just erased.\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig9b.png)\n\n::: {.callout-note collapse=\"true\"}\n\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit9a.png){width=100%}\n\n:::\n\nIf we now make a change (such as a change to file1 and adding file3)\nand commit, it would be as if any commits after 3d007af\nhad never occurred.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\necho 'End' > file1\necho 'File3' >> dir1/file3\ngit add file1 dir1/file3\ngit commit -m 'Modified file1 and added file3'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[main 3edd72f] Modified file1 and added file3\n 2 files changed, 2 insertions(+), 2 deletions(-)\n create mode 100644 dir1/file3\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 3edd72f (HEAD -> main) Modified file1 and added file3\n| * 001d2bb (tag: V.1) Modified file2, added .gitignore\n|/  \n* 3d007af Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3edd72f HEAD@{0}: commit: Modified file1 and added file3\n3d007af HEAD@{1}: reset: moving to 3d007af\n001d2bb HEAD@{2}: reset: moving to V.1\n3d007af HEAD@{3}: reset: moving to 3d007af\n001d2bb HEAD@{4}: commit: Modified file2, added .gitignore\n3d007af HEAD@{5}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{6}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   |-- file3\n|   `-- file2\n`-- .git\n    |-- refs\n    |-- packed-refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 10 files\n```\n\n\n:::\n:::\n\n\nNotice the addition of `file3` in `dir1`\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit ls-files\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndir1/file2\ndir1/file3\nfile1\n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n\n\n\n\n![](../resources/Fig9c.png)\n\n::: {.callout-note collapse=\"true\"}\n\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit9c.png){width=100%}\n\n:::\n\n\n## Revert\n\nAs with `git reset`, `git revert` is not directly supported by\nRstudio, hence the methods used in this section should be performed in\nthe terminal. There is one exception to this, Rstudio is able to\nrevert an modified file back to its state in the last commit.\n\n::: {.callout-note collapse=\"true\"}\n## Re-establish repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reset --hard V.1\ngit clean -qfdx\ngit reflog expire --expire-unreachable=now --all\ngit gc --prune=now\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHEAD is now at 001d2bb Modified file2, added .gitignore\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\nRevert generates a new commit that removes the changes that were\nintroduced by one or more of the most recent commits. Note, it does\nnot revert to a particular commit, but rather undoes a commit. So, to\nroll back to `3d007af` (the second\nlast commit), we just have to revert the last commit\n(`HEAD`).\n\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit revert HEAD\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[main 9982369] Revert \"Modified file2, added .gitignore\"\n Date: Fri Jul 19 03:20:48 2024 +0000\n 2 files changed, 2 deletions(-)\n delete mode 100644 .gitignore\n```\n\n\n:::\n:::\n\n\n\nHowever, if we explore the `reflog`, we can see the entire history\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n9982369 HEAD@{0}: revert: Revert \"Modified file2, added .gitignore\"\n3d007af HEAD@{1}: reset: moving to 3d007af\n001d2bb HEAD@{2}: reset: moving to V.1\n3d007af HEAD@{3}: reset: moving to 3d007af\n001d2bb HEAD@{4}: commit: Modified file2, added .gitignore\n3d007af HEAD@{5}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{6}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 9982369 (HEAD -> main) Revert \"Modified file2, added .gitignore\"\n* 001d2bb (tag: V.1) Modified file2, added .gitignore\n* 3d007af Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   `-- file2\n`-- .git\n    |-- refs\n    |-- packed-refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    |-- COMMIT_EDITMSG\n    `-- AUTO_MERGE\n\n8 directories, 10 files\n```\n\n\n:::\n:::\n\n\n\nNotice the absence of `.gitignore`. Notice also that `dir1/f.tmp` is\nalso present. Although this file was added at the same time as\n`.gitignore`, it was never committed and therefore is not altered with\nrepo manipulations.\n\nIf we list the files that are part of the repo:\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit ls-files\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndir1/file2\nfile1\n```\n\n\n:::\n:::\n\n\n\nwe will see that we are back to the state where only `file1` and\n`dir1/file2` are present.\n:::\n\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig9d.png)\n\n::: {.callout-note collapse=\"true\"}\n\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit9d.png){width=100%}\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Re-establish repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reset --hard V.1\ngit clean -qfdx\ngit reflog expire --expire-unreachable=now --all\ngit gc --prune=now\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHEAD is now at 001d2bb Modified file2, added .gitignore\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\nIf we had actually wanted to roll back to commit `437633e`, \nthen we could do so by sequentially issuing `git revert`:\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit revert --no-commit HEAD\ngit revert --no-commit HEAD~1\ngit commit -m 'Rolled back'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[main 1e6469b] Rolled back\n 3 files changed, 4 deletions(-)\n delete mode 100644 .gitignore\n delete mode 100644 dir1/file2\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1e6469b HEAD@{0}: commit: Rolled back\n3d007af HEAD@{1}: reset: moving to 3d007af\n001d2bb HEAD@{2}: reset: moving to V.1\n3d007af HEAD@{3}: reset: moving to 3d007af\n001d2bb HEAD@{4}: commit: Modified file2, added .gitignore\n3d007af HEAD@{5}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{6}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 1e6469b (HEAD -> main) Rolled back\n* 001d2bb (tag: V.1) Modified file2, added .gitignore\n* 3d007af Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n`-- .git\n    |-- refs\n    |-- packed-refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n7 directories, 8 files\n```\n\n\n:::\n:::\n\n\n\nNotice that `file2` is now also absent. If we list the files that are\npart of the repo:\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit ls-files\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfile1\n```\n\n\n:::\n:::\n\n\nwe will see that we are back to the state where only `file` is present\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig9e.png)\n\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit9e.png){width=100%}\n\n:::\n\n## Checkout and branching\n\nOnce again, the methods outlined in this section are not directly\nsupported by Rstudio. Please use the terminal instead.\n\n::: {.callout-note collapse=\"true\"}\n## Re-establish repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reset --hard V.1\ngit clean -qfdx\ngit reflog expire --expire-unreachable=now --all\ngit gc --prune=now\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHEAD is now at 001d2bb Modified file2, added .gitignore\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\nIf we wanted to review the state of files corresponding to commit \n`3d007af`, we could checkout the code from that commit. This\nprovides a way to travel back in time through your commits and explore\nthe (tracked) files exactly as they were.\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit checkout 3d007\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNote: switching to '3d007'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c <new-branch-name>\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at 3d007af Modified file1 and added file2 (in dir1)\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3d007af HEAD@{0}: checkout: moving from main to 3d007\n3d007af HEAD@{1}: reset: moving to 3d007af\n001d2bb HEAD@{2}: reset: moving to V.1\n3d007af HEAD@{3}: reset: moving to 3d007af\n001d2bb HEAD@{4}: commit: Modified file2, added .gitignore\n3d007af HEAD@{5}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{6}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 001d2bb (tag: V.1, main) Modified file2, added .gitignore\n* 3d007af (HEAD) Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   `-- file2\n`-- .git\n    |-- refs\n    |-- packed-refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    |-- ORIG_HEAD\n    |-- HEAD\n    `-- COMMIT_EDITMSG\n\n8 directories, 9 files\n```\n\n\n:::\n:::\n\n\n\nNotice that `file2` is now also absent. If we list the files that are\npart of the repo:\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit ls-files\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndir1/file2\nfile1\n```\n\n\n:::\n:::\n\n\nwe will see that we are back to the state where only `file` is present\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig9f.png)\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit9f.png){width=100%}\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Rstudio git history representation\n\nIf we go to the \"History\" tab of the \"Review Changes\" window, you will\nnotice that the commit history has been truncated to reflect that we\nhave gone back in commit history.\n\n![](../resources/rstudio_gitrollback2.png)\n\nNevertheless, if we select \"All branches\" from the dropdown menu, we\ncan see the full commit history.\n\n![](../resources/rstudio_gitrollback3.png)\n:::\n\n\nThe output advises us that we are in a **detached HEAD state**.\nThis occurs when a `commit` is checked out rather than a\n`branch`. Normally, when changes are committed, the new\ncommit is added to the `HEAD` of the current branch.\nHowever, in a detached HEAD state, any commits that are made are not\nassociated with any branch and will effectively be lost next time you\ncheckout.\n\nSo if for example, we then added another file (`file3`)..\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\necho 'END' > file3\ngit add file3\ngit commit -m 'END added to file3'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[detached HEAD 2a6c1f3] END added to file3\n 1 file changed, 1 insertion(+)\n create mode 100644 file3\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2a6c1f3 HEAD@{0}: commit: END added to file3\n3d007af HEAD@{1}: checkout: moving from main to 3d007\n3d007af HEAD@{2}: reset: moving to 3d007af\n001d2bb HEAD@{3}: reset: moving to V.1\n3d007af HEAD@{4}: reset: moving to 3d007af\n001d2bb HEAD@{5}: commit: Modified file2, added .gitignore\n3d007af HEAD@{6}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{7}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 2a6c1f3 (HEAD) END added to file3\n| * 001d2bb (tag: V.1, main) Modified file2, added .gitignore\n|/  \n* 3d007af Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n\nNow if we checked out `main`, the commit we made whilst in _detached\nhead mode_ would be lost.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit checkout main\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWarning: you are leaving 1 commit behind, not connected to\nany of your branches:\n\n  2a6c1f3 END added to file3\n\nIf you want to keep it by creating a new branch, this may be a good time\nto do so with:\n\n git branch <new-branch-name> 2a6c1f3\n\nSwitched to branch 'main'\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n001d2bb HEAD@{0}: checkout: moving from 2a6c1f3369996e058351925b20fe7bd4cddfdec4 to main\n2a6c1f3 HEAD@{1}: commit: END added to file3\n3d007af HEAD@{2}: checkout: moving from main to 3d007\n3d007af HEAD@{3}: reset: moving to 3d007af\n001d2bb HEAD@{4}: reset: moving to V.1\n3d007af HEAD@{5}: reset: moving to 3d007af\n001d2bb HEAD@{6}: commit: Modified file2, added .gitignore\n3d007af HEAD@{7}: commit: Modified file1 and added file2 (in dir1)\n437633e HEAD@{8}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* 001d2bb (HEAD -> main, tag: V.1) Modified file2, added .gitignore\n* 3d007af Modified file1 and added file2 (in dir1)\n* 437633e Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\nIf, having reviewed the state of a commit (by checking it out), we\ndecided that we wanted to roll back to this state and develop further\n(make additional commits), we are effectively deciding to start a new\nbranch that splits off at that commit. See the section on <a\nhref=\"#Branching\">Branching</a> for more details on how to do that.\n\n# Synching with remote repository\n\nWhen a project has multiple contributors, it is typical for there to\nbe a remote repository against which each contributor can exchange\ntheir contributions. The remote repository comprises only the `.git`\nfolder (and its contents), it never has a workspace. Files are rarely\nedited directly on the remote repository. Instead, it acts as a\nconstantly available 'main' conduit between all contributors.\n\nA remote repository can be anywhere that you have permission to at\nleast read from. Obviously, if you also want to contribute your local\ncommits to the remote repository, you also need write access to that\nlocation. If you intend to collaborate, then the remote repository\nalso needs to be in a location that all users can access at any time.\n\nFor this demonstration, we will start by re-generating a repository\nthat we made earlier on in this tutorial. This repository comprises a\n`main` branch along with an un-merged `Feature` branch.\n\n\n::: {.callout-note collapse=\"true\"}\n## Commands to create the repository\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nrm -rf ~/tmp/Repo1\nmkdir ~/tmp/Repo1\ncd ~/tmp/Repo1\ngit init \necho 'File 1' > file1\ngit add file1\ngit commit -m 'Initial repo and added file1'\necho '---------------' >> file1\nmkdir dir1\necho '* Notes' > dir1/file2\ngit add file1 dir1/file2\ngit commit -m 'Modified file1 and added file2 (in dir1)'\necho '---' >> dir1/file2\necho 'temp' > dir1/f.tmp\necho '*.tmp' > .gitignore\ngit add .\ngit commit -m 'Modified file2, added .gitignore'\ngit branch Feature\ngit checkout Feature\necho 'b' >> file1\necho 'File 3' > dir1/file3\ngit add .\ngit commit -m 'New feature'\ngit checkout main\necho ' another bug fix' >> dir1/file2\ngit add .\ngit commit -m 'Bug fix in file1'\ngit checkout Feature\necho ' a modification' >> dir1/file3\ngit add .\ngit commit -m 'Feature complete'\ngit checkout main\n\ngit reflog\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitialized empty Git repository in /home/runner/tmp/Repo1/.git/\n[main (root-commit) f02fa26] Initial repo and added file1\n 1 file changed, 1 insertion(+)\n create mode 100644 file1\n[main b7665f9] Modified file1 and added file2 (in dir1)\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file2\n[main 56a89f1] Modified file2, added .gitignore\n 2 files changed, 2 insertions(+)\n create mode 100644 .gitignore\nSwitched to branch 'Feature'\n[Feature c9eb43e] New feature\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file3\nSwitched to branch 'main'\n[main 18d7062] Bug fix in file1\n 1 file changed, 1 insertion(+)\nSwitched to branch 'Feature'\n[Feature be1d0b0] Feature complete\n 1 file changed, 1 insertion(+)\nSwitched to branch 'main'\n18d7062 HEAD@{0}: checkout: moving from Feature to main\nbe1d0b0 HEAD@{1}: commit: Feature complete\nc9eb43e HEAD@{2}: checkout: moving from main to Feature\n18d7062 HEAD@{3}: commit: Bug fix in file1\n56a89f1 HEAD@{4}: checkout: moving from Feature to main\nc9eb43e HEAD@{5}: commit: New feature\n56a89f1 HEAD@{6}: checkout: moving from main to Feature\n56a89f1 HEAD@{7}: commit: Modified file2, added .gitignore\nb7665f9 HEAD@{8}: commit: Modified file1 and added file2 (in dir1)\nf02fa26 HEAD@{9}: commit (initial): Initial repo and added file1\n* be1d0b0 (Feature) Feature complete\n* c9eb43e New feature\n| * 18d7062 (HEAD -> main) Bug fix in file1\n|/  \n* 56a89f1 Modified file2, added .gitignore\n* b7665f9 Modified file1 and added file2 (in dir1)\n* f02fa26 Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig10a.png)\n\n\n## Simulate a remote repository locally\n\nFor the purpose of this tutorial, we will create a remote repository\nthat is on the same computer as the above repository that we have been\nworking on. Whilst not the typical situation, it does mean that an\nexternal location and account is not necessary to follow along with\nthe tutorial. As previously mentioned, the actual location of the\nremote repository is almost irrelevant to how you interact with it.\nTherefore, whether the remote repository is on the same computer or\nelsewhere in the world makes little difference (other than permissions\nand connections).\n\nThis step is not supported directly by Rstudio - please use the terminal.\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ncd ~/tmp/RemoteRepo1\ngit init --bare\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitialized empty Git repository in /home/runner/tmp/RemoteRepo1/\n```\n\n\n:::\n:::\n\n\n\nNow that we have a remote repository - albeit empty at this stage - we\nreturn to our local repository and declare (add) the location of the\nremote repository using the `git remote add <name> <url>` _command_.\nIn this command, an optional name can be supplied to refer to the\nremote repository (`<name>`). The compulsory `<url>` _argument_ is the\naddress (location) of the remote repository.\n\nThis step is not supported directly by Rstudio - please use the\nterminal.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit remote add origin ~/tmp/RemoteRepo1\n```\n:::\n\n\n\nTo see what this has achieved, we can have a quick look at the\n`.git/config`\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ncat .git/config\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[core]\n\trepositoryformatversion = 0\n\tfilemode = true\n\tbare = false\n\tlogallrefupdates = true\n[remote \"origin\"]\n\turl = /home/runner/tmp/RemoteRepo1\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n```\n\n\n:::\n:::\n\n\n\nYou should notice that there is now a 'remote' section with the name\nof 'origin' and the 'url' points to the location we nominated.\n\n### Pushing\n\nCurrently the remote repository is empty. We will now push our local\ncommit history to the remote repository. This is achieved via the `git\npush -u <name> <ref>` <i>command</i>. Here, `<name>` is the name of\nthe remote repository ('origin') and `<ref>` is a reference the head\nof the commit chain we want to sync.\n\n\n::: {.panel-tabset}\n#### Terminal\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit push -u origin main\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTo /home/runner/tmp/RemoteRepo1\n * [new branch]      main -> main\nbranch 'main' set up to track 'origin/main'.\n```\n\n\n:::\n:::\n\n\n\n#### Rstudio\n\nRstudio does not have a direct means by which we can define the remote\nrepository. Thus, we must start by entering the following into the\nterminal.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit push -u origin main\n```\n:::\n\n\n\nThereafter, you might notice that some up and down (push and pull\nrespectively) buttons become active within the \"git\" panel.\n\n![](../resources/rstudio_gitpull1.png)\n\nNow, after each subsequent commit, you can \"push\" your code to the\nremote repository simply by pushing the up (push) arrow.\n\n:::\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit reflog\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n18d7062 HEAD@{0}: checkout: moving from Feature to main\nbe1d0b0 HEAD@{1}: commit: Feature complete\nc9eb43e HEAD@{2}: checkout: moving from main to Feature\n18d7062 HEAD@{3}: commit: Bug fix in file1\n56a89f1 HEAD@{4}: checkout: moving from Feature to main\nc9eb43e HEAD@{5}: commit: New feature\n56a89f1 HEAD@{6}: checkout: moving from main to Feature\n56a89f1 HEAD@{7}: commit: Modified file2, added .gitignore\nb7665f9 HEAD@{8}: commit: Modified file1 and added file2 (in dir1)\nf02fa26 HEAD@{9}: commit (initial): Initial repo and added file1\n* be1d0b0 (Feature) Feature complete\n* c9eb43e New feature\n| * 18d7062 (HEAD -> main, origin/main) Bug fix in file1\n|/  \n* 56a89f1 Modified file2, added .gitignore\n* b7665f9 Modified file1 and added file2 (in dir1)\n* f02fa26 Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig10b.png)\n\n::: {.callout-note collapse=\"true\"}\n## Another visual representation of the repository\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![](10_git_files/figure-html/drawGit10b.png){width=100%}\n\n:::\n\n**Note that when we pushed the commits to the remote repository, \nwe only pushed the `main` branch.  Consequently, the remote \nrepository only has a single branch.**\n\n## Cloning\n\nTo collaborate with others on a repository, we start by **cloning**\nthe repository you wish to collaborate on. So at the moment, we have\nthe original repository (`~/tmp/Repo1`) created by user 1. We also\nhave a remote repository (`~/tmp/RemoteRepo1`).  \n\nTo demonstrate cloning (and collaborating), we will also assume the\npersonal of user 2 and we will clone the remote repository to yet\nanother local path (`~/tmp/MyRepo1`). Of course, this would not\nnormally be on the same machine as the original repository, we are\njust doing it this way to simulate multiple users on the same machine.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.panel-tabset}\n#### Terminal\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit clone ~/tmp/RemoteRepo1 ~/tmp/MyRepo1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCloning into '/home/runner/tmp/MyRepo1'...\ndone.\n```\n\n\n:::\n:::\n\n\n\n#### Rstudio\n\n1. click on the `Project` selector in the top right of the Rstudio\n   window (as highlighted by the red ellipse in the image below.\n\n   ![](../resources/rstudio_init1a.png){width=100%}\n\n2. select `New Project` from the dropdown menu\n3. select `Version Control` form the Create Project panel\n4. select `Git` from the Create Project from Version Control panel\n5. provide a path to a remote repository.  Normally this URL would be \n   for a location on a server such as Github, Gitlab, Bitbucket etc.  \n   However, for this demostration we will point to the remote repository\n   that we set up in the previous section (`~/tmp/RemoteRepo1`)\n6. provide a directory name in which to store this new cloned repository.\n   Normally this field is populated based on the name give in the URL.\n   However, in this case, it would suggest a name of `RemoteRepo1` \n   which already exists (for the repository we are trying to clone), \n   and we don't wish to overwrite that one.  I will instead offer\n   an alternative name (`MyRepo1`).\n7. we also need to supply a path to where this cloned repository \n   will be stored.\n\n   ![](../resources/rstudio_gitclone1.png)\n8. click the \"Create Project\" button.   \n:::\n\nThe contents (and state) of `~/tmp/MyRepo1` should match that of\n`~/tmp/Repo1` (other than any files excluded due to a `.gitignore` or\nfiles not yet committed).\n\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ntree -ra -L 2 --charset ascii\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n|-- file1\n|-- dir1\n|   `-- file2\n|-- .gitignore\n`-- .git\n    |-- refs\n    |-- packed-refs\n    |-- objects\n    |-- logs\n    |-- info\n    |-- index\n    |-- hooks\n    |-- description\n    |-- config\n    |-- branches\n    `-- HEAD\n\n8 directories, 8 files\n```\n\n\n:::\n:::\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig10c.png)\n\n**Note that when cloning repository, all branches in the \nremote repository are cloned.  However, since the remote\nrepository only had one branch (`main`), so too the clone\nonly has one branch.**\n\n\n\nNow as the collaborator (user 2), lets make a modification and push\nthis change up to the remote repository.\n\n::: {.callout-important collapse=\"false\"}\n## Important info about pushing to a remote repository \n\nBefore pushing any changes, it is absolutely vital that you adhere to\nthe following steps:\n\n1. commit your changes - so that you have something new to push and\n   they are safe before the next step.\n2. pull (and if necessary reconcile - see the next section below) the\n   latest from the remote repository. **This is critical** as it\n   ensures that the changes you are pushing are against the latest\n   stage of the repository. Without this step, you might be pushing\n   changes that are based on a stage that is not longer current.\n3. push your changes\n:::\n\n\n::: {.panel-tabset}\n#### Terminal\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit pull\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAlready up to date.\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\necho 'Something else' > file4\ngit add file4\ngit commit -m 'Added file4'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[main be032bf] Added file4\n 1 file changed, 1 insertion(+)\n create mode 100644 file4\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit push -u origin main\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTo /home/runner/tmp/RemoteRepo1\n   18d7062..be032bf  main -> main\nbranch 'main' set up to track 'origin/main'.\n```\n\n\n:::\n:::\n\n\n\n#### Rstudio\n\n1. start by pulling the latest from the remote repository just incase \n   there has been an change\n2. click on the \"Create new blank file in the current directory\" button \n   and select \"Text file\" - name it `file4` \n3. edit this file by adding the contents `Something else`\n4. save the file\n5. stage (add) the file\n6. commit the change with a message of \"Added file4\"\n7. push this commit either by clicking on the green up (push) arrow in\n   the \"Review Changes\" window or the same arrow in the git tab of the \n   main Rstudio window.\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig10d.png)\n\nNotice how the second (cloned. `MyRepo1`) repository and the \nremote repository (`RemoteRepo1`) are one commit ahead of the \noriginal local repository (`Repo1`).  For `Repo1` to be in sync\nwith `MyRepo1`, the original user will have to pull the \nremote repository changes manually.\n\n\n## Pulling\n\nRetrieving a commit chain (_pulling_) from a remote repository is\nsuperficially the opposite of _pushing_. Actually, technically it is two\nactions: \n\n- a _fetch_ that retrieves the remote information and uses it to\n  create a _branch_ off your local repository (the name of this branch\n  is made from the name of the remote and the branch that was\n  fetched - e.g. `origin/master`).\n\n- a _merge_ that merges this branch into the main repository. \n\nThese actions can be performed individually, however, they are more\ntypically performed together via the `git pull` _command_. \n\nTo illustrate, lets return to being user 1 and we will pull the\nchanges contributed by user 2 in the section above.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit pull\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFrom /home/runner/tmp/RemoteRepo1\n   18d7062..be032bf  main       -> origin/main\nUpdating 18d7062..be032bf\nFast-forward\n file4 | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 file4\n```\n\n\n:::\n:::\n\n\n\nThe associated message informs us that upon pulling, a file (`file4`)\nhas been added. Any conflicts arising from the _merging_ stage of the\npull can be resolved in the usual manner of opening the conflicted\nfile(s) making manual edits and then committing the changes.\n\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbe032bf HEAD@{0}: pull: Fast-forward\n18d7062 HEAD@{1}: checkout: moving from Feature to main\nbe1d0b0 HEAD@{2}: commit: Feature complete\nc9eb43e HEAD@{3}: checkout: moving from main to Feature\n18d7062 HEAD@{4}: commit: Bug fix in file1\n56a89f1 HEAD@{5}: checkout: moving from Feature to main\nc9eb43e HEAD@{6}: commit: New feature\n56a89f1 HEAD@{7}: checkout: moving from main to Feature\n56a89f1 HEAD@{8}: commit: Modified file2, added .gitignore\nb7665f9 HEAD@{9}: commit: Modified file1 and added file2 (in dir1)\nf02fa26 HEAD@{10}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* be032bf (HEAD -> main, origin/main) Added file4\n* 18d7062 Bug fix in file1\n| * be1d0b0 (Feature) Feature complete\n| * c9eb43e New feature\n|/  \n* 56a89f1 Modified file2, added .gitignore\n* b7665f9 Modified file1 and added file2 (in dir1)\n* f02fa26 Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbe032bf HEAD@{0}: commit: Added file4\n18d7062 HEAD@{1}: clone: from /home/runner/tmp/RemoteRepo1\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* be032bf (HEAD -> main, origin/main, origin/HEAD) Added file4\n* 18d7062 Bug fix in file1\n* 56a89f1 Modified file2, added .gitignore\n* b7665f9 Modified file1 and added file2 (in dir1)\n* f02fa26 Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit reflog\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n* be032bf (HEAD -> main) Added file4\n* 18d7062 Bug fix in file1\n* 56a89f1 Modified file2, added .gitignore\n* b7665f9 Modified file1 and added file2 (in dir1)\n* f02fa26 Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig10e.png)\n\n\n## Github as a remote repository\n\nGitHub provides the world's leading centralized platform for version \ncontrol, collaboration, and project management, facilitating seamless\nteamwork, tracking changes, and ensuring the integrity and accessibility\nof code repositories throughout the software development lifecycle.\n\nAlthough anyone can explore (read) public repositories on github, only \nthose with github accounts can contribute and collaborate.\n\n### Setup Github account\n\nTo create a **free** github account:\n\n1. visit <https://github.com> and click \"Sign up for github\"\n2. register by providing your prefered email address, a username and\n   a password when prompted\n3. to complete the account activation, you will need to verify your \n   details via an email sent to your nominated email address\n\nAs of the start of 2024, github now requires Two-Factor Authentication\n(2FA) for enhanced security.  Whenever you login to github (or are\nprompted for a password, you will also need to use 2FA. To setup 2FA:\n\n1. click on your profile picture in the top right corner.\n2. select \"Settings\" from the dropdown menu.\n3. select \"Password and authentication\" in the left sidebar.\n4. under \"Two-factor authentication\" section, click \"Enable\".\n5. choose your preferred method (authenticator app or SMS) and follow \n   the prompts to set it up.\n\nPasswords and Two-Factor Authentication (2FA) are used when you (as a\nhuman) securely login and interact directly with the GitHub website.\nHowever, it is also possible to have other tools (such as `git`)\ninteract with Github on your behalf via an Application Programming\nInterfacet (API).  Passwords/2FA are not appropriate to authenticate \nthese machine to machine communications.  Instead, Github requires the\nuse of a Personal Access Token (PAT). PATs offer a more secure and granular \napproach, allowing users to control access without exposing their\naccount password.\n\nTo generate a Personal Access Token (PAT):\n\n1. click on your profile picture in the top right corner.\n2. select \"Settings\" from the dropdown menu.\n3. select \"Developer settings\" from the bottom of the left sidebar.\n4. select \"Personal access tokens\" from the left sidebar.\n5. select \"Tokens (classic)\" from the dropdown menu\n6. click \"Generate new token\"\n7. select \"Generate new token (classic)\" from the dropdown menu\n8. at this point you will likely be prompted for your password\n9. provide a \"note\" - this is more of a short description of what the\n   token is to be used for (in the example below, I have entered \"git push/pull\"\n   to remind me that this is a simple token for regular push/pull interaction\n   between my local and remote repositories).\n\n   ![](../resources/rstudio_githubtoken1.png)\n\n   You also need to provide an expiration. Although not secure or recommended,\n   I have selected \"No expiration\" as I don't want to have to re-do my PAT\n   across multiple machines too regularly.\n\n   Finally, you also need to indicate **scope** (what activities you are granting permission\n   for the tools to be able to perform).  In this case, I have ticked the \n   \"repo\" box.  This grants general rea/write access to my repositories.  I have \n   not granted permission for more administration like activities such as \n   managing teams, deleting repositories, etc - these activities I am happy to \n   perform myself via the website.\n10. click \"Generate token\" and securely copy the generated token.  Until this is stored\n    safely (see below) do not close the page, because Github will never show you this\n    PAT again.\n\n:::: {.indented}\n::: {.callout-important collapse=\"false\"}\n\nImportant: Store your PAT safely as you won't be able to see it again!\nIdeally, you should store this PAT in a digital wallet. Digital\nwallets vary according to operating systems. R users might like to use\nthe `r` function from the `asdf` package (which you will need to\ninstall prior) as follows in order to store the PAT.\n\n**In an R console, enter:**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngitcreds::gitcreds_set()\n```\n:::\n\n\n\nWhen propted for a password, paste in the copied PAT that hopefully is still in your\nclipboard - else you might need to re-copy it.\n\nTo confirm that you have successfully stored your PAT in your wallet, you can:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngitcreds::gitcreds_get()\n```\n:::\n\n\n\nand confirm that it indicates that there is a hidden password.\n\n\n:::\n::::\n\n### Create remote Github repository\n\n1. login to your Github account\n2. either: \n\n   a. click on the \"Create new..\" button (with the plus sign) to the\n      right of your profile picture in the top right corner and select\n      \"New repository\" from the dropdown menu\n      \n   b. click on \"Repositories\" from the top horizontal menu followed by\n      the big green \"New\" button\n   \n   ![](../resources/rstudio_github1.png)\n   \n3. fill out the details of the Create a new repository for similar to\n   the following\n   \n   ![](../resources/rstudio_github2.png)\n   \n   In particular:\n   \n   - give the repository a name. Typically use the same name as you\n      used for the local repository to avoid confusion\n   \n   - provide a description. Along with the name, this field is\n      searchable so the more detailed it is, the more likely your\n      repository will be discoverable by others as well as yourself in\n      the future\n   - indicate the privacy level. This affects whether your repository\n     is discoverable and readable by anyone (public) or just those you\n     invite (private)\n   - ideally, you also want to include a README file and license in\n     your repository. However, if you enable either of these options\n     in the form, Github will bypass providing a screen with some\n     additional instructions that many find useful for linking your\n     local and remote repository. So on this occasion, we will leave\n     these options as they are\n4. click the \"Create repository\" button at the bottom of the page\n5. Github will present you with the following page:\n\n   ![](../resources/rstudio_github3.png){width=100%}\n\n   This page presents three alternative sets of instructions that you\n   run locally (on your machine) in order to establish a link between\n   the local and remote repository. You need to run the appropriate\n   set of commands in your local terminal\n   \n   - if no local repository exists, follow the first set of instructions\n   - if you already have a local repository (**as is the case with\n     this demonstration**), follow the second set of instructions\n   - if you intend to import a repository from a different versioning\n     system, follow the last set of instructions\n6. once you have run the above commands locally, you can refresh the\n   Github page and you will be presented with your remote repository.\n   From here you can navigate through your code, manage privileges\n   etc.\n   \nIf you would like to allow others to collaborate with you on your\nrepository, then regardless of whether the repository is public or\nprivate, you will need to invite them as a collaborator.  To do so:\n\n1. click on \"Settings\" from the horizontal menu bar\n2. click on \"Collaborators\" from the left sidebar (you may then be\n   asked to submit your password)\n3. click on the green \"Add people\" button\n4. in the popup, enter either the username, full name or email address\n   of the person you want to invite to collaborate with you. Once you\n   click the \"Select a collaborator above\" and select the appropriate\n   candidate, this person will be sent an invite via email.\n5. nominate the role that this collaborator can assume (e.g. what\n   capacity does the collaborator have to edit, invite others, alter\n   settings, delete the repository etc)\n6. repeat steps 3-4 for each additional collaborator you wish to\n   invite\n   \n# Resolving conflicts\n\nIn Git, conflicts arise when changes made in different branches cannot\nbe automatically merged. This typically happens when two branches\nmodify the same part of a file and the changes overlap. Think of it\nlike two writers revising the same sentence differently. Conflicts\nusually arise when merging or rebasing branches.\n\nWhen git identifies a conflict, it will mark the conflicting areas\n(with sets of plain text fences - see below), and it's then up to the\nuser to resolve them manually by making edits the conflicted file(s)\nand choosing which changes to keep. After resolving conflicts, the\nchanges can be staged, and the merge or rebase can be completed.\nConflict resolution is an essential skill in collaborative Git\nworkflows, ensuring smooth integration of changes from multiple\ncontributors.\n\nRecall that pulling from a remote repository is a to stage process.\nFirstly the new commits are \"fetched\" to a new temporary branch and\nthen this branch is merged into the local repository. Hence, conflicts\ncan occur when pulling from remote repositories. Conflict resolution\nin such cases is as outlined above.\n\nTo illustrate a git conflict, we will start with a very simple\nrepository, create a branch and then concurrently make edits to the\nsame part of the same file on each branch before attempting to merge\nthe branches together.  \n\n\n::: {.callout-note collapse=\"true\"}\n## Commands to create the repository\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\nrm -rf ~/tmp/Repo1\nmkdir ~/tmp/Repo1\ncd ~/tmp/Repo1\ngit init \necho 'File 1' > file1\ngit add file1\ngit commit -m 'Initial repo and added file1'\necho '---------------' >> file1\nmkdir dir1\necho '* Notes' > dir1/file2\ngit add file1 dir1/file2\ngit commit -m 'Modified file1 and added file2 (in dir1)'\necho '---' >> dir1/file2\necho 'temp' > dir1/f.tmp\necho '*.tmp' > .gitignore\ngit add .\ngit commit -m 'Modified file2, added .gitignore'\ngit branch Feature\ngit checkout Feature\necho 'some text added on Feature branch' >> file1\necho 'File 3' > dir1/file3\ngit add .\ngit commit -m 'New feature'\ngit checkout main\necho ' a bug fix on the main branch' >> file1\ngit add .\ngit commit -m 'Bug fix in file1'\n\ngit reflog\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitialized empty Git repository in /home/runner/tmp/Repo1/.git/\n[main (root-commit) 888e733] Initial repo and added file1\n 1 file changed, 1 insertion(+)\n create mode 100644 file1\n[main 11f71b1] Modified file1 and added file2 (in dir1)\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file2\n[main 1ae4132] Modified file2, added .gitignore\n 2 files changed, 2 insertions(+)\n create mode 100644 .gitignore\nSwitched to branch 'Feature'\n[Feature 13d44c4] New feature\n 2 files changed, 2 insertions(+)\n create mode 100644 dir1/file3\nSwitched to branch 'main'\n[main 30b3b41] Bug fix in file1\n 1 file changed, 1 insertion(+)\n30b3b41 HEAD@{0}: commit: Bug fix in file1\n1ae4132 HEAD@{1}: checkout: moving from Feature to main\n13d44c4 HEAD@{2}: commit: New feature\n1ae4132 HEAD@{3}: checkout: moving from main to Feature\n1ae4132 HEAD@{4}: commit: Modified file2, added .gitignore\n11f71b1 HEAD@{5}: commit: Modified file1 and added file2 (in dir1)\n888e733 HEAD@{6}: commit (initial): Initial repo and added file1\n* 13d44c4 (Feature) New feature\n| * 30b3b41 (HEAD -> main) Bug fix in file1\n|/  \n* 1ae4132 Modified file2, added .gitignore\n* 11f71b1 Modified file1 and added file2 (in dir1)\n* 888e733 Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n::: {.cell class='tikz'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../resources/Fig11a.png)\n\n\n\n::: {.panel-tabset}\n#### Terminal\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit merge Feature --no-edit\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAuto-merging file1\nCONFLICT (content): Merge conflict in file1\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n\n:::\n:::\n\n\n\n#### Rstudio\n\nMerging is not directly supported by Rstudio, please use the \nterminal.\n\n:::\n\n\nHmmm. It appears that there is a conflict (although we should not be\nsupprised since we deliberately set the repository up to have a conflict!). \nIf we explore the a `git diff`, we will see that on the `master` and \n`Feature` _branches_ have incompatible changes.\n\n::: {.callout-note collapse=\"true\"}\n## More information about the conflict\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOn branch main\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nChanges to be committed:\n\tnew file:   dir1/file3\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\tboth modified:   file1\n```\n\n\n:::\n:::\n\n\n\nThe above status informs us that whilst we were able to successfully \nmerge in the changes in `dir1/file3`, the modifications in `file1`\nremain unmerged (due to conflicts).\n\nIf we run a `git diff` on the two branches, we will be able to \nidentify all the differences within all comparable files between the \ntwo branches.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit diff main Feature\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndiff --git a/dir1/file3 b/dir1/file3\nnew file mode 100644\nindex 0000000..8cf9e18\n--- /dev/null\n+++ b/dir1/file3\n@@ -0,0 +1 @@\n+File 3\ndiff --git a/file1 b/file1\nindex 11c945a..8a32d91 100644\n--- a/file1\n+++ b/file1\n@@ -1,3 +1,3 @@\n File 1\n ---------------\n- a bug fix on the main branch\n+some text added on Feature branch\n```\n\n\n:::\n:::\n\n\n\nThe output indicates that `dir/file3` does not exist on the `main` \nbranch - this is not a conflict.  However, for `file1`, we see that\nline three differs between the two branches.\n\nIt is not so much that they have both made changes to the same file,\nit is more that the changes are to the same part of the file. Lets\nlook at the contents of `file1` in the commit that is the common\nancester of both _branches_:\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit cat-file -p main^:file1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFile 1\n---------------\n```\n\n\n:::\n:::\n\n\n\nSo prior to branching, the `file1` file had two lines of text.\n\nIn the latest commit on the `main` branch, the `file1` has added \na third line with text about a bug fix.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit cat-file -p main:file1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFile 1\n---------------\n a bug fix on the main branch\n```\n\n\n:::\n:::\n\n\n\nYet on the `Feature` branch, the third line of the `file1` file\ncontains `some text added on Feature branch`.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit cat-file -p Feature:file1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFile 1\n---------------\nsome text added on Feature branch\n```\n\n\n:::\n:::\n\n\n\nSo the source of this conflict evidently is the third line of\nthe `file1` file.\n\n:::\n\n\nWe can see that the changes made to `file1` are inconsistent. We need to decide\nwhich edits (if any) we want to use. Recall that the change made in `main` was to\naddress a bug or issue. Perhaps this bug or issue does not arise with\nthe new Feature and thus is superfluous. Alternatively, it might be\nthat this bug fix is required by both branches (if so, we probably\nshould have introduced it to the `Feature` _branch_ at the same time\nas the `main` anyway....\n\nLets address the conflict by rolling back `file1` from the `main` _branch_.\n\nThe following figures depict the `file1` file with conflicts (left) and once\nresolved (right).\n\n![](../resources/rstudio_gitconflict1.png)\n![](../resources/rstudio_gitconflict2.png)\n\n\n::: {.panel-tabset}\n#### Terminal\n\nNormally we would resolve this issue using a code editor to\nedit the actual changes in the file back to the desired condition.\nHowever as we only have the one change and this demo is fully\nscripted, I will instead roll back (checkout) this one file from the\nearlier commit on the `main` branch.\n\n\n\n::: {.cell .bash}\n\n```{.bash .cell-code}\ngit checkout main^ file1\ngit add .\ngit commit -m 'Merge in Feature'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUpdated 1 path from 3c7af0d\n[main 07ec446] Merge in Feature\n```\n\n\n:::\n:::\n\n\n\n#### Rstudio\n\n1. open `file1` for editing\n2. make the necessary changes to the text\n3. save the file\n4. stage (add) the file (you may have to click on the checkbox twice \n   before the tick appears)\n5. commit the changes with a message like \"Merge in Feature\" \n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## More information about this repository\n\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit reflog\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n07ec446 HEAD@{0}: commit (merge): Merge in Feature\n30b3b41 HEAD@{1}: commit: Bug fix in file1\n1ae4132 HEAD@{2}: checkout: moving from Feature to main\n13d44c4 HEAD@{3}: commit: New feature\n1ae4132 HEAD@{4}: checkout: moving from main to Feature\n1ae4132 HEAD@{5}: commit: Modified file2, added .gitignore\n11f71b1 HEAD@{6}: commit: Modified file1 and added file2 (in dir1)\n888e733 HEAD@{7}: commit (initial): Initial repo and added file1\n```\n\n\n:::\n:::\n\n::: {.cell .bash replace='true'}\n\n```{.bash1 .cell-code}\ngit log --graph --decorate --oneline --all\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n*   07ec446 (HEAD -> main) Merge in Feature\n|\\  \n| * 13d44c4 (Feature) New feature\n* | 30b3b41 Bug fix in file1\n|/  \n* 1ae4132 Modified file2, added .gitignore\n* 11f71b1 Modified file1 and added file2 (in dir1)\n* 888e733 Initial repo and added file1\n```\n\n\n:::\n:::\n\n\n:::\n \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}