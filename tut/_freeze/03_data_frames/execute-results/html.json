{
  "hash": "cb9d759417d9b7f6fc9e9352914ec706",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Data frames \nauthor: \"Murray Logan\"\ndate: \"19 July, 2024\"\nformat: \n  html:\n    toc: true\n    toc-float: true\n    page-layout: full\n    number-sections: true\n    number-depth: 3\n    embed-resources: true\n    code-fold: false\n    code-tools: true\n    code-summary: \"Show the code\"\n    code-line-numbers: true\n    code-block-border-left: \"#ccc\"\n    code-copy: true\n    highlight-style: atom-one\n    theme: [default, ../resources/tut-style.scss]\n    css: ../resources/tut-style.css\ncrossref:\n  fig-title: '**Figure**'\n  fig-labels: arabic\n  tbl-title: '**Table**'\n  tbl-labels: arabic\nengine: knitr\nbibliography: ../resources/references.bib\noutput_dir: \"docs\"\n---\n\n\n\n# Preparations\n\n**Step 1**\n\nBefore beginning this tutorial, we should make sure we have all the\ntools in place. We will therefore start by installing the _tidyverse_\necosystem of packages. Among the many packages included under this\numbrella are the packages `readr`, `readxl` and `tibble` - each of\nwhich will be used in this tutorial.\n\nIn addition, the `foreign` package supports importing data from other\nstatistical software (such as Sas, Stata, Systat, System and Minitab).\n\nLet start by installing the `tidyverse` ecosystem of packages along\nwith `foreign`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pkg_install(\"tidyverse\")\npak::pkg_install(\"foreign\")\n```\n:::\n\n\n\nNow we will load these packages so that they are available for the\nrest of the session.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(foreign)\n```\n:::\n\n\n\n::: {.callout-note}\nNotice in the above output, when we load the `tidyverse` package, some\nvalidation steps are performed to indicate which actual packages were\nloaded. Importantly, notice also that a couple of conflicts are\nidentified. The first of these `dplyr::filter() masks stats::filter()`\nindicates that once the `dplyr` package was loaded the previous\ndefinition of a function called `filter` (from the `stats` package)\nwas overwritten (masked) by a definition contained wihin the `dplyr`\npackage.\n\nThis is not an error. Rather, it is a warning to advise that if you\nwere expecting to call the `filter` function and were expecting to get\nthe behaviour defined within the `stats` package, then you should\npreface the call with the `stats` namespace. For example, call\n`stats::filter()` rather than just `filter()`.\n\nNo such issues arose when loading the `foreign` package.\n\n:::\n\n**Step 2**\n\nThe second necessary preparation is to prepare the file system for a\ntidy working environment. Rather than place all R scripts, data and\noutputs into a single (increasingly cluttered folder), it is always\nbetter to organise your project into a set number of folders. For this\ntutorial, I would recommend setting up the following structure.\n\n```\n../\n|-- data\n|-- scripts\n```\n\nNow within your chosen editor, I suggest you create an R script within\nthe `scripts` folder and set this path as the working directory.\n\n**Step 3**\n\nThe final preparation step is to download some data files to use\nduring this tutorial. These files should be placed in the `data`\nfolder. Each of the files are abbreviated versions of the same\n@MacNally-1996-224 data set, yet each is in a different format (some\nare text files, others are in formats of other software). Each format\nis listed below, along with a link to manually access the data and an\nR code snippet that will download the file and place it in the\n`../data` folder.\n\n\n- [macnally.csv](https://github.com/ReefCloud/workshops/tree/main/data/macnally.csv): a comma separated format\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  download.file('https://github.com/ReefCloud/workshops/tree/main/data/macnally.csv', '../data/macnally.csv')\n  ```\n  :::\n\n\n\n- [macnally.txt](https://github.com/ReefCloud/workshops/tree/main/data/macnally.txt): a tab separated format\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  download.file('https://github.com/ReefCloud/workshops/tree/main/data/macnally.txt', '../data/macnally.txt')\n  ```\n  :::\n\n\n\n- [macnally.xlsx](https://github.com/ReefCloud/workshops/tree/main/data/macnally.xlsx): an excel workbook format\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  download.file('https://github.com/ReefCloud/workshops/tree/main/data/macnally.xlsx', '../data/macnally.xlsx')\n  ```\n  :::\n\n\n\n# Constructing data frames\n\n## `data.frame`\n\nData frames are generated by amalgamating vectors of the same length\ntogether. To illustrate the translation of a data set (collection of\nvariables) into an R data frame (collection of vectors), a portion of\na real data set by Mac Nally (1996) in which the bird communities were\ninvestigated from 37 sites across five habitats in southeastern\nAustralia will be used. Although the original data set includes the\nmeasured maximum density of 102 bird species from the 37 sites, for\nsimplicity's sake only two bird species (GST: gray shrike thrush, EYR:\neastern yellow robin) and the first eight of the sites will be\nincluded. The truncated data set, comprises a single factorial (or\ncategorical) variable, two continuous variables, and a set of site\n(row) names, and is as follows:\n\n| Site        | HABITAT     | GST | EYR |\n|-------------|-------------|-----|-----|\n| Reedy Lake  | Mixed       | 3.4 | 0.0 |\n| Pearcedale  | Gipps.Manna | 3.4 | 9.2 |\n| Warneet     | Gipps.Manna | 8.4 | 3.8 |\n| Cranbourne  | Gipps.Manna | 3.0 | 5.0 |\n| Lysterfield | Mixed       | 5.6 | 5.6 |\n| Red Hill    | Mixed       | 8.1 | 4.1 |\n| Devilbend   | Mixed       | 8.3 | 7.1 |\n| Olinda      | Mixed       | 4.6 | 5.3 |\n\n: {.borderless .sm .paperTable}\n\nFirstly, we will generate the three variables (excluding the site\nlabels as they are not variables) separately:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhabitat <- factor(c('Mixed', 'Gipps.Manna', 'Gipps.Manna', 'Gipps.Manna', 'Mixed',\n  'Mixed', 'Mixed', 'Mixed'))\ngst <- c(3.4, 3.4, 8.4, 3.0, 5.6, 8.1, 8.3, 4.6)\neyr <- c(0.0, 9.2, 3.8, 5.0, 5.6, 4.1, 7.1, 5.3)\n```\n:::\n\n\n\nNext, use the list the names of the vectors as arguments in the\n`data.frame()` function to amalgamate the three separate variables into\na single data frame (data set) which we will call `macnally` (after the\nauthor).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmacnally <- data.frame(habitat, gst, eyr)\nmacnally\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      habitat gst eyr\n1       Mixed 3.4 0.0\n2 Gipps.Manna 3.4 9.2\n3 Gipps.Manna 8.4 3.8\n4 Gipps.Manna 3.0 5.0\n5       Mixed 5.6 5.6\n6       Mixed 8.1 4.1\n7       Mixed 8.3 7.1\n8       Mixed 4.6 5.3\n```\n\n\n:::\n:::\n\n\n\nNotice that each vector (variable) becomes a column in the data frame\nand that each row represents a single sampling unit (in this case,\neach row represents a different site). By default, the rows are named\nusing numbers corresponding to the number of rows in the data frame.\nHowever, these can be altered to reflect the names of the sampling\nunits by assigning a list of alternative names to the `row.names()`\n(data frame row names) property of the data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrow.names(macnally) <- c('Reedy Lake', 'Pearcedale', 'Warneet', 'Cranbourne',\n  'Lysterfield', 'Red Hill', 'Devilbend', 'Olinda')\nmacnally\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                habitat gst eyr\nReedy Lake        Mixed 3.4 0.0\nPearcedale  Gipps.Manna 3.4 9.2\nWarneet     Gipps.Manna 8.4 3.8\nCranbourne  Gipps.Manna 3.0 5.0\nLysterfield       Mixed 5.6 5.6\nRed Hill          Mixed 8.1 4.1\nDevilbend         Mixed 8.3 7.1\nOlinda            Mixed 4.6 5.3\n```\n\n\n:::\n:::\n\n\n\n## expand.grid\n\nWhen the data set contains multiple fully crossed categorical\nvariables (factors), the `expand.grid()` function provides a\nconvenient way to create the factor vectors.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpand.grid(rep = 1:4, \n  B = paste(\"b\", 1:2, sep = \"\"), \n  A = paste(\"a\", 1:3, sep = \"\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   rep  B  A\n1    1 b1 a1\n2    2 b1 a1\n3    3 b1 a1\n4    4 b1 a1\n5    1 b2 a1\n6    2 b2 a1\n7    3 b2 a1\n8    4 b2 a1\n9    1 b1 a2\n10   2 b1 a2\n11   3 b1 a2\n12   4 b1 a2\n13   1 b2 a2\n14   2 b2 a2\n15   3 b2 a2\n16   4 b2 a2\n17   1 b1 a3\n18   2 b1 a3\n19   3 b1 a3\n20   4 b1 a3\n21   1 b2 a3\n22   2 b2 a3\n23   3 b2 a3\n24   4 b2 a3\n```\n\n\n:::\n:::\n\n\n\n## `as_tibble`\n\nTibbles are a modern re-imagining of data frames in R that focus on\nclarity, consistency, and user-friendliness. While both data frames\nand tibbles both hold data in rows and columns, tibbles introduce\nseveral key differences:\n\n- **Preserved Data Types:** Unlike data frames which coerce strings to\n  factors, tibbles maintain the original data types, facilitating\n  accurate analysis and avoiding surprises.\n- **Explicit Naming:** Column names are always strings, preventing\n  unintentional creation of numeric or logical variables.\n- **Improved Printing:** Tibbles display a concise overview,\n  presenting only the first 10 rows and all fitting columns to screen,\n  making exploration more efficient.\n- **Streamlined Subsetting:** Accessing specific columns is simpler\n  and safer, minimizing potential errors related to partial matching.\n\nThe `as_tibble` function converts a data frame into a tibble.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmacnally.tbl <- as_tibble(macnally)\nmacnally.tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  habitat       gst   eyr\n  <fct>       <dbl> <dbl>\n1 Mixed         3.4   0  \n2 Gipps.Manna   3.4   9.2\n3 Gipps.Manna   8.4   3.8\n4 Gipps.Manna   3     5  \n5 Mixed         5.6   5.6\n6 Mixed         8.1   4.1\n7 Mixed         8.3   7.1\n8 Mixed         4.6   5.3\n```\n\n\n:::\n:::\n\n\n\nSince the example data set is so small, there is no appreciable\ndifference in how it is presented as either a data frame or a tibble.\nIt is mainly when the data sets get larger that the distinctions\nbecome more apparent.\n\n## `tribble`\n\nThe `tribble()` function allows us to construct _tibbles_ directly.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmacnally.tbl <- tribble(\n  ~habitat, ~gst, ~eyr,\n  \"Mixed\", 3.4, 0.0,\n  \"Gipps.Manna\", 3.4, 9.2,\n  \"Gipps.Manna\", 8.4, 3.8,\n  \"Gipps.Manna\", 3.0, 5.0,\n  \"Mixed\", 5.6, 5.6,\n  \"Mixed\", 8.1, 4.1,\n  \"Mixed\", 8.3, 7.1,\n  \"Mixed\", 4.6, 5.3,\n  )\nmacnally.tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  habitat       gst   eyr\n  <chr>       <dbl> <dbl>\n1 Mixed         3.4   0  \n2 Gipps.Manna   3.4   9.2\n3 Gipps.Manna   8.4   3.8\n4 Gipps.Manna   3     5  \n5 Mixed         5.6   5.6\n6 Mixed         8.1   4.1\n7 Mixed         8.3   7.1\n8 Mixed         4.6   5.3\n```\n\n\n:::\n:::\n\n\n\nNote that the construction of tibbles like this more closely resembles\nthe eventual structure of the data. Compare this to the way data\nframes are constructed (by combining individual vectors).\n\n\n\n\n# Importing data frames\n\nStatistical systems are typically not very well suited to tasks of\ndata entry and management. This is the roll of spreadsheets and\ndatabases, of which there are many available. Although the\nfunctionality of R continues to expand, it is unlikely that R itself\nwill ever duplicate the extensive spreadsheet and database\ncapabilities of other software. However, there are numerous projects\nin early stages of development that are being designed to offer an\ninterface to R from within major spreadsheet packages.\n\nR development has roots in the Unix/Linux programming philosophy that\ndictates that tools should be dedicated to performing specific tasks\nthat they perform very well and rely on other tools to perform other\ntasks. Consequently, the emphasis of R is, and will continue to be,\npurely an environment for statistical and graphical procedures. It is\nexpected that other software will be used to generate and maintain\ndata sets.\n\nUnfortunately, data importation into R can be a painful exercise that\novershadows the benefits of using R for new users. In part, this is\nbecause there are a large number of competing methods that can be used\nto import data and from a wide variety of sources. Moreover, many of\nthe popular spreadsheets use their own proprietary file formats that\nare particularly complex to accommodate fully.\n\nThis section does not intend to cover all the methods. Rather, it will\nhighlight the simplest and most robust methods of importing data from\nthe most popular sources. Unless file path names are specified, all\ndata reading functions will search for files in the current working\ndirectory.\n\n## Importing from text file\n\nThe easiest form of importation is from a pure text file. Since most\nsoftware that accepts file input can read plain text files, text files\ncan be created in all spreadsheet, database and statistical software\npackages and are also the default outputs of most data collection\ndevices.\n\nIn a text file, data are separated (or delimited) by a specific\ncharacter, which in turn defines what sort of text file it is. The\ntext file should broadly represent the format of the data frame.\n\n- variables should be in columns and sampling units in rows. the first\n- row should contain the variable names and if there are row\n  names, these should be in the first column\n\nThe following examples illustrate the format of the abbreviated\n@MacNally-1996-224 data set created as both comma delimited (left) and\ntab delimited (right) files as well as the corresponding read.table()\ncommands used to import the files.\n\n\n::: {.callout-note}\n\nThe following examples assume that the above data will be in the\ncurrent working directory. If the current\nworking directory (which can be checked with the `getwd()` function)\ndoes not contain these files, then either: \n\n- include the full path name (or path relative to the current working\n  directory) as the filename argument \n- change the current working\n  directory of your session prior to continuing (use the `setwd()`\n  function) \n- copy and paste the files into the current working\n  directory.\n:::\n\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n**Comma delimited text file .csv**\n\n\n\n::: {.cell class='plain'}\n\n```{.txt .cell-code}\nLOCATION,HABITAT,GST,EYR\nReedy Lake,Mixed,3.4,0.0\nPearcedale,Gipps.Manna,3.4,9.2\nWarneet,Gipps.Manna,8.4,3.8\nCranbourne,Gipps.Manna,3.0,5.0\n....\n```\n:::\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nmacnally_new <- read_csv(\"../data/macnally.csv\", \n  trim_ws = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 37 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): LOCATION, HABITAT\ndbl (2): GST, EYR\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nmacnally_new\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 37 × 4\n   LOCATION      HABITAT              GST   EYR\n   <chr>         <chr>              <dbl> <dbl>\n 1 Reedy Lake    Mixed                3.4   0  \n 2 Pearcedale    Gipps.Manna          3.4   9.2\n 3 Warneet       Gipps.Manna          8.4   3.8\n 4 Cranbourne    Gipps.Manna          3     5  \n 5 Lysterfield   Mixed                5.6   5.6\n 6 Red Hill      Mixed                8.1   4.1\n 7 Devilbend     Mixed                8.3   7.1\n 8 Olinda        Mixed                4.6   5.3\n 9 Fern Tree Gum Montane Forest       3.2   5.2\n10 Sherwin       Foothills Woodland   4.6   1.2\n# ℹ 27 more rows\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"5%\"}\n:::\n\n::: {.column width=\"45%\"}\n\n**Tab delimited text file .txt**\n\n\n\n::: {.cell class='plain'}\n\n```{.txt .cell-code}\nLOCATION    HABITAT\t    GST\tEYR\nReedy Lake\tMixed\t    3.4\t0.0\nPearcedale\tGipps.Manna\t3.4\t9.2\nWarneet\t    Gipps.Manna\t8.4\t3.8\nCranbourne\tGipps.Manna\t3.0\t5.0\n....\n```\n:::\n\n::: {.cell class='plain'}\n\n```{.r .cell-code}\nmacnally_new <- read_tsv(\"../data/macnally.txt\", \n  trim_ws = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 37 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): LOCATION, HABITAT\ndbl (2): GST, EYR\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nmacnally_new \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 37 × 4\n   LOCATION      HABITAT              GST   EYR\n   <chr>         <chr>              <dbl> <dbl>\n 1 Reedy Lake    Mixed                3.4   0  \n 2 Pearcedale    Gipps.Manna          3.4   9.2\n 3 Warneet       Gipps.Manna          8.4   3.8\n 4 Cranbourne    Gipps.Manna          3     5  \n 5 Lysterfield   Mixed                5.6   5.6\n 6 Red Hill      Mixed                8.1   4.1\n 7 Devilbend     Mixed                8.3   7.1\n 8 Olinda        Mixed                4.6   5.3\n 9 Fern Tree Gum Montane Forest       3.2   5.2\n10 Sherwin       Foothills Woodland   4.6   1.2\n# ℹ 27 more rows\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::::\n\nIn the above, the `trim_ws = TRUE` argument indicates that leading and\ntrailing spaces should be removed from all the data. This is important\nas often spreadsheets (I'm looking at you Excel), add spaces before or\nafter words (in particular). These are invisible, yet can cause huge\nheadaches when running analyses or graphing..\n\nThe `read_csv` and `read_tzv` functions provide feedback about what\nthey have imported. Specifically, they list the number of rows and\ncolumns, what the delimeting character is and the data type assigned\nto each field (variable/column).\n\nThe data are imported as a tibble.\n\nThere are numerous ways to specify the filename.  \n\n- using full paths\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  macnally_new <- read_csv(\"/home/Project/data/macnally.csv\", trim_ws = TRUE)\n  ```\n  :::\n\n\n  ::: {.callout-note}\n  In the above example, the full path used was appropriate for the\n  machine that the code was run on. However, it is unlikely to reflect a\n  valid path on your machine. You may want to adjust it accordingly.\n  :::\n\n- using relative paths\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  macnally_new <- read_csv(\"../data/macnally.csv\", trim_ws = TRUE)\n  ```\n  :::\n\n\n  ::: {.callout-note}\n\n  Recall that `../data/` means navigate out of the current directory\n  and into the `data` directory.\n\n  :::\n\n- using ULRs\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  macnally_new <- read_csv(url(\"https://github.com/ReefCloud/workshops/tree/main/data/macnally.csv\"), trim_ws = TRUE)\n  ```\n  :::\n\n\n\n  In the above example, the data are accessed directly from a remote\n  location.\n\n## Importing from the clipboard\n\nThe `read_tsv()` function can also be used to import data (into a\ntibble) that has been placed on the clipboard by other software,\nthereby providing a very quick and convenient way of obtaining data\nfrom spreadsheets. Simply replace the filename argument with the\n`clipboard()` function. For example, to import data placed on the\nclipboard from Microsoft Excel, select the relevant cells, click copy\nand then in R, use the following syntax;\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmacnally_new <- read_tsv(clipboard(), trim_ws = TRUE)\n```\n:::\n\n\n\n::: {.callout-warning}\n\nAlthough importing data from the clipboard can be convenient for\nquickly exploring something, it should mostly be discouraged from a\nreproducibility perspective:\n\n- when such code is included in a script, the script will just import\n  whatever is present on the clipboard at the time - which may or may\n  not be what you expect it to be\n- there is no way to record the providence of the data because it is\n  not pointing to a specific file or source.\n:::\n\n## Importing from Excel\n\nMicrosoft Excel is more than just a spreadsheet, it can contain\nmacros, formulae, multiple worksheets and formatting. There are\nnumerous ways to import xlsx files into R, yet depending on the\ncomplexity of the original files, the translations can be incomplete\nand inconsistent.\n\nOne of the easiest and safest ways to import data from Excel is either to\nsave the worksheet as a text file (comma or tab delimited) and import\nthe data as a text file (see above), or to copy the data to the\nclipboard in Excel and import the clipboard data into R.\n\nNevertheless, it is also possible to directly import a sheet from an\nexcel workbook. Tidyverse includes a package called `readxl`, however\nas it is not one of the 'core' packages, it is not automatically\nloaded as part of the ecosystem when the `tidyverse` package is\nloaded. Hence to use the `readxl` package, it must be explicitly\nloaded.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\nmacnally_new <- read_xlsx(\"../data/macnally.xlsx\", sheet = \"macnally\", trim_ws = TRUE)\n```\n:::\n\n\n\n\n# Viewing data frames\n\nFor very small and simple data.frame's like the macnally example\nabove, the whole data data.frame can be comfortably displayed in the\nconsole. However for much larger data.frame's, displaying all the data\ncan be overwhelming and not very useful. There are a number of\nconvenient functions that provide overviews of data. To appreciate the\nparticulars of each routine as well as the differences between the\ndifferent routines, we will add some other data types to our macnally\ndata.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmacnally$bool <- rep(c(TRUE, FALSE), 4)\nmacnally$char <- rep(c('Large', 'Small'), 4)\nmacnally$date <- seq(as.Date('2000-02-29'),\n  as.Date('2000-05-12'), \n  len=8)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmacnally\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                habitat gst eyr  bool  char       date\nReedy Lake        Mixed 3.4 0.0  TRUE Large 2000-02-29\nPearcedale  Gipps.Manna 3.4 9.2 FALSE Small 2000-03-10\nWarneet     Gipps.Manna 8.4 3.8  TRUE Large 2000-03-20\nCranbourne  Gipps.Manna 3.0 5.0 FALSE Small 2000-03-31\nLysterfield       Mixed 5.6 5.6  TRUE Large 2000-04-10\nRed Hill          Mixed 8.1 4.1 FALSE Small 2000-04-21\nDevilbend         Mixed 8.3 7.1  TRUE Large 2000-05-01\nOlinda            Mixed 4.6 5.3 FALSE Small 2000-05-12\n```\n\n\n:::\n:::\n\n\n\n## `summary()`\n\nThe `summary()` function is an overloaded function whose behaviour\ndepends on the object passed to the function. When `summary()` is called\nwith a data.frame, a summary is provided in which:\n\n- numeric vectors (variables) are summarized by the standard 5 number\n  statistics and if there are any missing values, the number of\n  missing values is also provided\n- categorical (factors) vectors are tallied up - that is, the number\n  of instances of each level are counted.\n- boolean states are also tallied\n- character vectors are only described by their length\n- date (and POSIX) vectors are summarized by 5 number summaries\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(macnally)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        habitat       gst            eyr           bool        \n Gipps.Manna:3   Min.   :3.00   Min.   :0.000   Mode :logical  \n Mixed      :5   1st Qu.:3.40   1st Qu.:4.025   FALSE:4        \n                 Median :5.10   Median :5.150   TRUE :4        \n                 Mean   :5.60   Mean   :5.013                  \n                 3rd Qu.:8.15   3rd Qu.:5.975                  \n                 Max.   :8.40   Max.   :9.200                  \n     char                date           \n Length:8           Min.   :2000-02-29  \n Class :character   1st Qu.:2000-03-18  \n Mode  :character   Median :2000-04-05  \n                    Mean   :2000-04-05  \n                    3rd Qu.:2000-04-23  \n                    Max.   :2000-05-12  \n```\n\n\n:::\n:::\n\n\n\n## `str()`\n\nSimilar to `summary()`, the `str()` function is an overloaded. The `str()`\nfunction generally produces a compact view of the structure of an\nobject. When `str()` is called with a data.frame, this compact view\ncomprises a nested list of abbreviated structures.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(macnally)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t8 obs. of  6 variables:\n $ habitat: Factor w/ 2 levels \"Gipps.Manna\",..: 2 1 1 1 2 2 2 2\n $ gst    : num  3.4 3.4 8.4 3 5.6 8.1 8.3 4.6\n $ eyr    : num  0 9.2 3.8 5 5.6 4.1 7.1 5.3\n $ bool   : logi  TRUE FALSE TRUE FALSE TRUE FALSE ...\n $ char   : chr  \"Large\" \"Small\" \"Large\" \"Small\" ...\n $ date   : Date, format: \"2000-02-29\" \"2000-03-10\" ...\n```\n\n\n:::\n:::\n\n\n\n## `glimpse()`\n\nThe `glimpse()` function in the `tibble` package is similar to `str()`\nexcept that it attempts to maximize the amount of data displayed\naccording to the dimensions of the output.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(macnally)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 8\nColumns: 6\n$ habitat <fct> Mixed, Gipps.Manna, Gipps.Manna, Gipps.Manna, Mixed, Mixed, Mi…\n$ gst     <dbl> 3.4, 3.4, 8.4, 3.0, 5.6, 8.1, 8.3, 4.6\n$ eyr     <dbl> 0.0, 9.2, 3.8, 5.0, 5.6, 4.1, 7.1, 5.3\n$ bool    <lgl> TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE\n$ char    <chr> \"Large\", \"Small\", \"Large\", \"Small\", \"Large\", \"Small\", \"Large\",…\n$ date    <date> 2000-02-29, 2000-03-10, 2000-03-20, 2000-03-31, 2000-04-10, 20…\n```\n\n\n:::\n:::\n\n\n\n## Others\n\nThere are also numerous graphical methods including `view()` and `fix()`,\nhowever, I have focused on the script friendly routines. As the\ngraphical routines require user input, they are inappropriate to\ninclude in scripts.\n\nWithin Rstudio, a data frame can be viewed like a spreadsheet. To view\nthe data this way, click on the name of the data frame within the\nEnvironment pane. Furthermore, when in R Notebook mode, a simple\nfunctioning spreadsheet will be embedded within the notebook.\n\n# Exporting data\n\nAlthough plain text files are not the most compact storage formats,\nthey do offer two very important characteristics. Firstly, they can be\nread by a wide variety of other applications, ensuring that the\nability to retrieve the data will continue indefinitely. Secondly, as\nthey are neither compressed nor encoded, a corruption to one section\nof the file does not necessarily reduce the ability to correctly read\nother parts of the file. Hence, this is also an important\nconsideration for the storage of datasets.\n\nThe `write_csv()` function is used to save data frames and tibbles.\nAlthough there are a large number of optional arguments available for\ncontrolling the exact format of the output file, typically only a few\nare required. The following example illustrates the exportation of the\n@MacNally-1996-224 data set as a comma delimited text file.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(macnally, file = \"macnally.csv\")\n```\n:::\n\n\n\nThe first and second arguments specify respectively the name of the\ndata frame (or tibble) and filename (and path if necessary) to be\nexported. Alternatively, it is possible to export to text files with\nother delimeter characters using the `write_delim()` function.\n\n# Saving and loading R objects\n\nAny object in R (including data frames and tibbles) can also be saved\ninto a native R workspace image file (`*.RData`) either individually, or\nas a collection of objects using the `save()` function.\n\nWhilst this native R storage format is not recommended for long-term\ndata storage and archival (as it is a binary format and thus less\nlikely to be universally and indefinitely readable), saving and\nloading of R objects does provide very useful temporary storage of\nlarge R objects between sessions.\n\nIn particular, if one or more objects require processing or\nmanipulations that take some time to regenerate, saving and loading of\nR objects can permit the analyst to skip straight to a specific\nsection of a script and continue development or analysis. Moreover,\nthis is very useful for tweaking and regenerating summary figures -\nrather than have to go through an entire sequence of data reading,\nprocessing and analysis, strategic use of saving/loading of R objects\ncan allow the researcher to commence directly at the point at which\nmodification is required.\n\n## `saveRDS/readRDS`\n\nFor example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## save just the macnally data frame to the data folder\nsaveRDS(macnally, file = \"../data/macnally.rds\")\n```\n:::\n\n\n\nThis will save a single object in a compressed format.\n\nThe saved object(s) can be loaded during subsequent sessions by\nproviding the name of the saved workspace image file as an argument to\nthe `load()` function. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmacnally <- readRDS(\"../data/macnally_stats.rds\")\n```\n:::\n\n\n\n## `save/load`\n\nWhen you want to save multiple objects, the `save()` function is\nconvenient. This stores multiple objects in a binary (non-compressed)\nformat.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## save just the macnally data frame to the data folder\nsave(macnally, file = \"../data/macnally.RData\")\n## calculate the mean gst\nmean_gst <- mean(macnally$gst)\n## display the mean gst\nmean_gst\n## save the macnally data frame as well as the mean gst object\nsave(macnally, mean_gst, file = \"../data/macnally_stats.RData\")\n```\n:::\n\n\n\nThe saved object(s) can be loaded during subsequent sessions by\nproviding the name of the saved workspace image file as an argument to\nthe `load()` function. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(\"../data/macnally_stats.RData\")\n```\n:::\n\n\n\nNote, the `load()` reads the object(s) into the current environment\nwith each object being assigned the names they were originally\nassigned when they were saved.\n\n## `dump`\n\nSimilarly, a straight un-encoded text version of an object (including\ndataframes and tibbles) can be saved or added to a text file (such as\nan R script) using the `dump()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndump(\"macnally\", file = \"../data/macnally\")\n```\n:::\n\n\n\nIf the file character string is left empty, the text representation of\nthe object will be written to the console. This output can then be\nviewed or copied and pasted into a script file, thereby providing a\nconvenient way to bundle together data sets along with graphical and\nanalysis commands that act on the data sets. It can even be used to\npaste data into an email.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndump(\"macnally\", file = \"\")\n```\n:::\n\n\n\nThereafter, the dataset is automatically included when the script is\nsourced and cannot accidentally become separated from the script.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}